{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ANTLRInputStream.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/Dependents.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/DiagnosticErrorListener.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/LexerInterpreter.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/RuleContextWithAltNum.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/RuleDependency.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/RuleVersion.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/TokenStreamRewriter.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/index.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n// ConvertTo-TS run at 2016-10-04T11:26:49.0828748-07:00\r\n\r\nimport * as assert from \"assert\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { Arrays } from \"./misc/Arrays\";\r\nimport { Override } from \"./Decorators\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { Interval } from \"./misc/Interval\";\r\n\r\nconst READ_BUFFER_SIZE: number = 1024;\r\nconst INITIAL_BUFFER_SIZE: number = 1024;\r\n\r\n/**\r\n * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it\r\n * like a `char[]` buffer. Can also pass in a {@link String} or\r\n * `char[]` to use.\r\n *\r\n * If you need encoding, pass in stream/reader with correct encoding.\r\n *\r\n * @deprecated as of 4.7, please use `CharStreams` interface.\r\n */\r\nexport class ANTLRInputStream implements CharStream {\r\n\t/** The data being scanned */\r\n\tprotected data: string;\r\n\r\n\t/** How many characters are actually in the buffer */\r\n\tprotected n: number;\r\n\r\n\t/** 0..n-1 index into string of next char */\r\n\tprotected p: number = 0;\r\n\r\n\t/** What is name or source of this char stream? */\r\n\tpublic name?: string;\r\n\r\n\t/** Copy data in string to a local char array */\r\n\tconstructor(input: string) {\r\n\t\tthis.data = input;\r\n\t\tthis.n = input.length;\r\n\t}\r\n\r\n\t/** Reset the stream so that it's in the same state it was\r\n\t *  when the object was created *except* the data array is not\r\n\t *  touched.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis.p = 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic consume(): void {\r\n\t\tif (this.p >= this.n) {\r\n\t\t\tassert(this.LA(1) === IntStream.EOF);\r\n\t\t\tthrow new Error(\"cannot consume EOF\");\r\n\t\t}\r\n\r\n\t\t//System.out.println(\"prev p=\"+p+\", c=\"+(char)data[p]);\r\n\t\tif (this.p < this.n) {\r\n\t\t\tthis.p++;\r\n\t\t\t//System.out.println(\"p moves to \"+p+\" (c='\"+(char)data[p]+\"')\");\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic LA(i: number): number {\r\n\t\tif (i === 0) {\r\n\t\t\treturn 0; // undefined\r\n\t\t}\r\n\t\tif (i < 0) {\r\n\t\t\ti++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]\r\n\t\t\tif ((this.p + i - 1) < 0) {\r\n\t\t\t\treturn IntStream.EOF; // invalid; no char before first char\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ((this.p + i - 1) >= this.n) {\r\n\t\t\t//System.out.println(\"char LA(\"+i+\")=EOF; p=\"+p);\r\n\t\t\treturn IntStream.EOF;\r\n\t\t}\r\n\t\t//System.out.println(\"char LA(\"+i+\")=\"+(char)data[p+i-1]+\"; p=\"+p);\r\n\t\t//System.out.println(\"LA(\"+i+\"); p=\"+p+\" n=\"+n+\" data.length=\"+data.length);\r\n\t\treturn this.data.charCodeAt(this.p + i - 1);\r\n\t}\r\n\r\n\tpublic LT(i: number): number {\r\n\t\treturn this.LA(i);\r\n\t}\r\n\r\n\t/** Return the current input symbol index 0..n where n indicates the\r\n\t *  last symbol has been read.  The index is the index of char to\r\n\t *  be returned from LA(1).\r\n\t */\r\n\t@Override\r\n\tget index(): number {\r\n\t\treturn this.p;\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn this.n;\r\n\t}\r\n\r\n\t/** mark/release do nothing; we have entire buffer */\r\n\t@Override\r\n\tpublic mark(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic release(marker: number): void {\r\n\t\t// No default implementation since this stream buffers the entire input\r\n\t}\r\n\r\n\t/** consume() ahead until p==index; can't just set p=index as we must\r\n\t *  update line and charPositionInLine. If we seek backwards, just set p\r\n\t */\r\n\t@Override\r\n\tpublic seek(index: number): void {\r\n\t\tif (index <= this.p) {\r\n\t\t\tthis.p = index; // just jump; don't update stream state (line, ...)\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// seek forward, consume until p hits index or n (whichever comes first)\r\n\t\tindex = Math.min(index, this.n);\r\n\t\twhile (this.p < index) {\r\n\t\t\tthis.consume();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getText(interval: Interval): string {\r\n\t\tlet start: number = interval.a;\r\n\t\tlet stop: number = interval.b;\r\n\t\tif (stop >= this.n) {\r\n\t\t\tstop = this.n - 1;\r\n\t\t}\r\n\t\tlet count: number = stop - start + 1;\r\n\t\tif (start >= this.n) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\t// System.err.println(\"data: \"+Arrays.toString(data)+\", n=\"+n+\r\n\t\t// \t\t\t\t   \", start=\"+start+\r\n\t\t// \t\t\t\t   \", stop=\"+stop);\r\n\t\treturn this.data.substr(start, count);\r\n\t}\r\n\r\n\t@Override\r\n\tget sourceName(): string {\r\n\t\tif (!this.name) {\r\n\t\t\treturn IntStream.UNKNOWN_SOURCE_NAME;\r\n\t\t}\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString() { return this.data; }\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.1349829-07:00\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport enum Dependents {\r\n\r\n\t/**\r\n\t * The element is dependent upon the specified rule.\r\n\t */\r\n\tSELF,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's parents\r\n\t * (rules which directly reference it).\r\n\t */\r\n\tPARENTS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's children\r\n\t * (rules which it directly references).\r\n\t */\r\n\tCHILDREN,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's ancestors\r\n\t * (the transitive closure of `PARENTS` rules).\r\n\t */\r\n\tANCESTORS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's descendants\r\n\t * (the transitive closure of `CHILDREN` rules).\r\n\t */\r\n\tDESCENDANTS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's siblings\r\n\t * (the union of `CHILDREN` of its `PARENTS`).\r\n\t */\r\n\tSIBLINGS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's preceeding\r\n\t * siblings (the union of `CHILDREN` of its `PARENTS` which\r\n\t * appear before a reference to the rule).\r\n\t */\r\n\tPRECEEDING_SIBLINGS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's following\r\n\t * siblings (the union of `CHILDREN` of its `PARENTS` which\r\n\t * appear after a reference to the rule).\r\n\t */\r\n\tFOLLOWING_SIBLINGS,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's preceeding\r\n\t * elements (rules which might end before the start of the specified rule\r\n\t * while parsing). This is calculated by taking the\r\n\t * `PRECEEDING_SIBLINGS` of the rule and each of its\r\n\t * `ANCESTORS`, along with the `DESCENDANTS` of those\r\n\t * elements.\r\n\t */\r\n\tPRECEEDING,\r\n\t/**\r\n\t * The element is dependent upon the set of the specified rule's following\r\n\t * elements (rules which might start after the end of the specified rule\r\n\t * while parsing). This is calculated by taking the\r\n\t * `FOLLOWING_SIBLINGS` of the rule and each of its\r\n\t * `ANCESTORS`, along with the `DESCENDANTS` of those\r\n\t * elements.\r\n\t */\r\n\tFOLLOWING,\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.2133685-07:00\r\n\r\nimport { ATNConfig } from \"./atn/ATNConfig\";\r\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\r\nimport { BitSet } from \"./misc/BitSet\";\r\nimport { DFA } from \"./dfa/DFA\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserErrorListener } from \"./ParserErrorListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { SimulatorState } from \"./atn/SimulatorState\";\r\nimport { Token } from \"./Token\";\r\nimport { Override, NotNull } from \"./Decorators\";\r\nimport { Interval } from \"./misc/Interval\";\r\n\r\n/**\r\n * This implementation of {@link ANTLRErrorListener} can be used to identify\r\n * certain potential correctness and performance problems in grammars. \"Reports\"\r\n * are made by calling {@link Parser#notifyErrorListeners} with the appropriate\r\n * message.\r\n *\r\n * * **Ambiguities**: These are cases where more than one path through the\r\n *   grammar can match the input.\r\n * * **Weak context sensitivity**: These are cases where full-context\r\n *   prediction resolved an SLL conflict to a unique alternative which equaled the\r\n *   minimum alternative of the SLL conflict.\r\n * * **Strong (forced) context sensitivity**: These are cases where the\r\n *   full-context prediction resolved an SLL conflict to a unique alternative,\r\n *   *and* the minimum alternative of the SLL conflict was found to not be\r\n *   a truly viable alternative. Two-stage parsing cannot be used for inputs where\r\n *   this situation occurs.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class DiagnosticErrorListener implements ParserErrorListener {\r\n\r\n\t/**\r\n\t * Initializes a new instance of {@link DiagnosticErrorListener}, specifying\r\n\t * whether all ambiguities or only exact ambiguities are reported.\r\n\t *\r\n\t * @param exactOnly `true` to report only exact ambiguities, otherwise\r\n\t * `false` to report all ambiguities.  Defaults to true.\r\n\t */\r\n\tconstructor(protected exactOnly: boolean = true) {\r\n\t\tthis.exactOnly = exactOnly;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic syntaxError<T extends Token>(\r\n\t\t/*@NotNull*/\r\n\t\trecognizer: Recognizer<T, any>,\r\n\t\toffendingSymbol: T | undefined,\r\n\t\tline: number,\r\n\t\tcharPositionInLine: number,\r\n\t\t/*@NotNull*/\r\n\t\tmsg: string,\r\n\t\te: RecognitionException | undefined): void\r\n\t{\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportAmbiguity(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull dfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\texact: boolean,\r\n\t\tambigAlts: BitSet | undefined,\r\n\t\t@NotNull configs: ATNConfigSet): void {\r\n\t\tif (this.exactOnly && !exact) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\r\n\t\tlet conflictingAlts: BitSet = this.getConflictingAlts(ambigAlts, configs);\r\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\r\n\t\tlet message: string = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\r\n\t\trecognizer.notifyErrorListeners(message);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportAttemptingFullContext(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull dfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tconflictingAlts: BitSet | undefined,\r\n\t\t@NotNull conflictState: SimulatorState): void {\r\n\t\tlet format: string = \"reportAttemptingFullContext d=%s, input='%s'\";\r\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\r\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\r\n\t\tlet message: string = `reportAttemptingFullContext d=${decision}, input='${text}'`;\r\n\t\trecognizer.notifyErrorListeners(message);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportContextSensitivity(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull dfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tprediction: number,\r\n\t\t@NotNull acceptState: SimulatorState): void {\r\n\t\tlet format: string = \"reportContextSensitivity d=%s, input='%s'\";\r\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\r\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\r\n\t\tlet message: string = `reportContextSensitivity d=${decision}, input='${text}'`;\r\n\t\trecognizer.notifyErrorListeners(message);\r\n\t}\r\n\r\n\tprotected getDecisionDescription(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull dfa: DFA): string {\r\n\t\tlet decision: number = dfa.decision;\r\n\t\tlet ruleIndex: number = dfa.atnStartState.ruleIndex;\r\n\r\n\t\tlet ruleNames: string[] = recognizer.ruleNames;\r\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\r\n\t\t\treturn decision.toString();\r\n\t\t}\r\n\r\n\t\tlet ruleName: string = ruleNames[ruleIndex];\r\n\t\tif (!ruleName) {\r\n\t\t\treturn decision.toString();\r\n\t\t}\r\n\r\n\t\treturn `${decision} (${ruleName})`;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the set of conflicting or ambiguous alternatives from a\r\n\t * configuration set, if that information was not already provided by the\r\n\t * parser.\r\n\t *\r\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\r\n\t * reported by the parser.\r\n\t * @param configs The conflicting or ambiguous configuration set.\r\n\t * @returns Returns `reportedAlts` if it is not `undefined`, otherwise\r\n\t * returns the set of alternatives represented in `configs`.\r\n\t */\r\n\t@NotNull\r\n\tprotected getConflictingAlts(reportedAlts: BitSet | undefined, @NotNull configs: ATNConfigSet): BitSet {\r\n\t\tif (reportedAlts != null) {\r\n\t\t\treturn reportedAlts;\r\n\t\t}\r\n\r\n\t\tlet result: BitSet = new BitSet();\r\n\t\tfor (let config of configs) {\r\n\t\t\tresult.set(config.alt);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.9954566-07:00\r\n\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNType } from \"./atn/ATNType\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { Lexer } from \"./Lexer\";\r\nimport { LexerATNSimulator } from \"./atn/LexerATNSimulator\";\r\nimport { NotNull } from \"./Decorators\";\r\nimport { Override } from \"./Decorators\";\r\nimport { Vocabulary } from \"./Vocabulary\";\r\n\r\nexport class LexerInterpreter extends Lexer {\r\n\tprotected _grammarFileName: string;\r\n\tprotected _atn: ATN;\r\n\r\n\tprotected _ruleNames: string[];\r\n\tprotected _channelNames: string[];\r\n\tprotected _modeNames: string[];\r\n\t@NotNull\r\n\tprivate _vocabulary: Vocabulary;\r\n\r\n\tconstructor(grammarFileName: string, @NotNull vocabulary: Vocabulary, ruleNames: string[], channelNames: string[], modeNames: string[], atn: ATN, input: CharStream) {\r\n\t\tsuper(input);\r\n\r\n\t\tif (atn.grammarType !== ATNType.LEXER) {\r\n\t\t\tthrow new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\r\n\t\t}\r\n\r\n\t\tthis._grammarFileName = grammarFileName;\r\n\t\tthis._atn = atn;\r\n\r\n\t\tthis._ruleNames = ruleNames.slice(0);\r\n\t\tthis._channelNames = channelNames.slice(0);\r\n\t\tthis._modeNames = modeNames.slice(0);\r\n\t\tthis._vocabulary = vocabulary;\r\n\t\tthis._interp = new LexerATNSimulator(atn, this);\r\n\t}\r\n\r\n\t@Override\r\n\tget atn(): ATN {\r\n\t\treturn this._atn;\r\n\t}\r\n\r\n\t@Override\r\n\tget grammarFileName(): string {\r\n\t\treturn this._grammarFileName;\r\n\t}\r\n\r\n\t@Override\r\n\tget ruleNames(): string[] {\r\n\t\treturn this._ruleNames;\r\n\t}\r\n\r\n\t@Override\r\n\tget channelNames(): string[] {\r\n\t\treturn this._channelNames;\r\n\t}\r\n\r\n\t@Override\r\n\tget modeNames(): string[] {\r\n\t\treturn this._modeNames;\r\n\t}\r\n\r\n\t@Override\r\n\tget vocabulary(): Vocabulary {\r\n\t\treturn this._vocabulary;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.4741196-07:00\r\n\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { Override } from \"./Decorators\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\n\r\n/** A handy class for use with\r\n *\r\n *  options {contextSuperClass=org.antlr.v4.runtime.RuleContextWithAltNum;}\r\n *\r\n *  that provides a backing field / impl for the outer alternative number\r\n *  matched for an internal parse tree node.\r\n *\r\n *  I'm only putting into Java runtime as I'm certain I'm the only one that\r\n *  will really every use this.\r\n */\r\nexport class RuleContextWithAltNum extends ParserRuleContext {\r\n\tprivate _altNumber: number;\r\n\r\n\tconstructor();\r\n\tconstructor(parent: ParserRuleContext | undefined, invokingStateNumber: number);\r\n\tconstructor(parent?: ParserRuleContext, invokingStateNumber?: number) {\r\n\t\tif (invokingStateNumber !== undefined) {\r\n\t\t\tsuper(parent, invokingStateNumber);\r\n\t\t} else {\r\n\t\t\tsuper();\r\n\t\t}\r\n\r\n\t\tthis._altNumber = ATN.INVALID_ALT_NUMBER;\r\n\t}\r\n\r\n\t@Override\r\n\tget altNumber(): number {\r\n\t\treturn this._altNumber;\r\n\t}\r\n\r\n\t// @Override\r\n\tset altNumber(altNum: number) {\r\n\t\tthis._altNumber = altNum;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.6271221-07:00\r\n\r\nimport { Dependents } from \"./Dependents\";\r\nimport { Parser } from \"./Parser\";\r\n\r\n/**\r\n * Declares a dependency upon a grammar rule, along with a set of zero or more dependent rules.\r\n *\r\n * Version numbers within a grammar should be assigned on a monotonically increasing basis to allow for accurate\r\n * tracking of dependent rules.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport function RuleDependency(dependency: DependencySpecification) {\r\n\treturn (target: object, propertyKey: PropertyKey, propertyDescriptor: PropertyDescriptor) => {\r\n\t\t// intentionally empty\r\n\t};\r\n}\r\n\r\nexport interface DependencySpecification {\r\n\treadonly recognizer: { new (...args: any[]): Parser; };\r\n\r\n\treadonly rule: number;\r\n\r\n\treadonly version: number;\r\n\r\n\t/**\r\n\t * Specifies the set of grammar rules related to `rule` which the annotated element depends on. Even when absent\r\n\t * from this set, the annotated element is implicitly dependent upon the explicitly specified `rule`, which\r\n\t * corresponds to the `Dependents.SELF` element.\r\n\t *\r\n\t * By default, the annotated element is dependent upon the specified `rule` and its `Dependents.PARENTS`, i.e. the\r\n\t * rule within one level of context information. The parents are included since the most frequent assumption about a\r\n\t * rule is where it's used in the grammar.\r\n\t */\r\n\treadonly dependents?: Dependents[];\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.7170027-07:00\r\n\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport function RuleVersion(version: number) {\r\n\r\n\treturn <T extends ParserRuleContext>(target: Parser, propertyKey: PropertyKey, propertyDescriptor: TypedPropertyDescriptor<(...args: any[]) => T>) => {\r\n\t\t// intentionally empty\r\n\t};\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00\r\n\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Override } from \"./Decorators\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenStream } from \"./TokenStream\";\r\n\r\nimport * as Utils from \"./misc/Utils\";\r\n\r\n/**\r\n * Useful for rewriting out a buffered input token stream after doing some\r\n * augmentation or other manipulations on it.\r\n *\r\n * You can insert stuff, replace, and delete chunks. Note that the operations\r\n * are done lazily--only if you convert the buffer to a {@link String} with\r\n * {@link TokenStream#getText()}. This is very efficient because you are not\r\n * moving data around all the time. As the buffer of tokens is converted to\r\n * strings, the {@link #getText()} method(s) scan the input token stream and\r\n * check to see if there is an operation at the current index. If so, the\r\n * operation is done and then normal {@link String} rendering continues on the\r\n * buffer. This is like having multiple Turing machine instruction streams\r\n * (programs) operating on a single input tape. :)\r\n *\r\n * This rewriter makes no modifications to the token stream. It does not ask the\r\n * stream to fill itself up nor does it advance the input cursor. The token\r\n * stream `TokenStream.index` will return the same value before and\r\n * after any {@link #getText()} call.\r\n *\r\n * The rewriter only works on tokens that you have in the buffer and ignores the\r\n * current input cursor. If you are buffering tokens on-demand, calling\r\n * {@link #getText()} halfway through the input will only do rewrites for those\r\n * tokens in the first half of the file.\r\n *\r\n * Since the operations are done lazily at {@link #getText}-time, operations do\r\n * not screw up the token index values. That is, an insert operation at token\r\n * index `i` does not change the index values for tokens\r\n * `i`+1..n-1.\r\n *\r\n * Because operations never actually alter the buffer, you may always get the\r\n * original token stream back without undoing anything. Since the instructions\r\n * are queued up, you can easily simulate transactions and roll back any changes\r\n * if there is an error just by removing instructions. For example,\r\n *\r\n * ```\r\n * CharStream input = new ANTLRFileStream(\"input\");\r\n * TLexer lex = new TLexer(input);\r\n * CommonTokenStream tokens = new CommonTokenStream(lex);\r\n * T parser = new T(tokens);\r\n * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);\r\n * parser.startRule();\r\n * ```\r\n *\r\n * Then in the rules, you can execute (assuming rewriter is visible):\r\n *\r\n * ```\r\n * Token t,u;\r\n * ...\r\n * rewriter.insertAfter(t, \"text to put after t\");}\r\n * rewriter.insertAfter(u, \"text after u\");}\r\n * System.out.println(rewriter.getText());\r\n * ```\r\n *\r\n * You can also have multiple \"instruction streams\" and get multiple rewrites\r\n * from a single pass over the input. Just name the instruction streams and use\r\n * that name again when printing the buffer. This could be useful for generating\r\n * a C file and also its header file--all from the same buffer:\r\n *\r\n * ```\r\n * rewriter.insertAfter(\"pass1\", t, \"text to put after t\");}\r\n * rewriter.insertAfter(\"pass2\", u, \"text after u\");}\r\n * System.out.println(rewriter.getText(\"pass1\"));\r\n * System.out.println(rewriter.getText(\"pass2\"));\r\n * ```\r\n *\r\n * If you don't use named rewrite streams, a \"default\" stream is used as the\r\n * first example shows.\r\n */\r\nexport class TokenStreamRewriter {\r\n\tpublic static readonly DEFAULT_PROGRAM_NAME: string =  \"default\";\r\n\tpublic static readonly PROGRAM_INIT_SIZE: number =  100;\r\n\tpublic static readonly MIN_TOKEN_INDEX: number =  0;\r\n\r\n\t/** Our source stream */\r\n\tprotected tokens: TokenStream;\r\n\r\n\t/** You may have multiple, named streams of rewrite operations.\r\n\t *  I'm calling these things \"programs.\"\r\n\t *  Maps String (name) &rarr; rewrite (List)\r\n\t */\r\n\tprotected programs: Map<string, RewriteOperation[]>;\r\n\r\n\t/** Map String (program name) &rarr; Integer index */\r\n\tprotected lastRewriteTokenIndexes: Map<string, number>;\r\n\r\n\tconstructor(tokens: TokenStream)  {\r\n\t\tthis.tokens = tokens;\r\n\t\tthis.programs = new Map<string, RewriteOperation[]>();\r\n\t\tthis.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);\r\n\t\tthis.lastRewriteTokenIndexes = new Map<string, number>();\r\n\t}\r\n\r\n\tpublic getTokenStream(): TokenStream {\r\n\t\treturn this.tokens;\r\n\t}\r\n\r\n\tpublic rollback(instructionIndex: number): void;\r\n\t/** Rollback the instruction stream for a program so that\r\n\t *  the indicated instruction (via instructionIndex) is no\r\n\t *  longer in the stream. UNTESTED!\r\n\t */\r\n\tpublic rollback(instructionIndex: number, programName: string): void;\r\n\tpublic rollback(instructionIndex: number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tlet is: RewriteOperation[] | undefined =  this.programs.get(programName);\r\n\t\tif ( is != null ) {\r\n\t\t\tthis.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic deleteProgram(): void;\r\n\r\n\t/** Reset the program so that no instructions exist */\r\n\tpublic deleteProgram(programName: string): void;\r\n\tpublic deleteProgram(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tthis.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);\r\n\t}\r\n\r\n\tpublic insertAfter(t: Token, text: {}): void;\r\n\tpublic insertAfter(index: number, text: {}): void;\r\n\tpublic insertAfter(t: Token, text: {}, programName: string): void;\r\n\tpublic insertAfter(index: number, text: {}, programName: string): void;\r\n\tpublic insertAfter(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tlet index: number;\r\n\t\tif (typeof tokenOrIndex === \"number\") {\r\n\t\t\tindex = tokenOrIndex;\r\n\t\t} else {\r\n\t\t\tindex = tokenOrIndex.tokenIndex;\r\n\t\t}\r\n\r\n\t\t// to insert after, just insert before next index (even if past end)\r\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\r\n\t\tlet op = new InsertAfterOp(this.tokens, index, rewrites.length, text);\r\n\t\trewrites.push(op);\r\n\t}\r\n\r\n\tpublic insertBefore(t: Token, text: {}): void;\r\n\tpublic insertBefore(index: number, text: {}): void;\r\n\tpublic insertBefore(t: Token, text: {}, programName: string): void;\r\n\tpublic insertBefore(index: number, text: {}, programName: string): void;\r\n\tpublic insertBefore(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tlet index: number;\r\n\t\tif (typeof tokenOrIndex === \"number\") {\r\n\t\t\tindex = tokenOrIndex;\r\n\t\t} else {\r\n\t\t\tindex = tokenOrIndex.tokenIndex;\r\n\t\t}\r\n\r\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\r\n\t\tlet op: RewriteOperation = new InsertBeforeOp(this.tokens, index, rewrites.length, text);\r\n\t\trewrites.push(op);\r\n\t}\r\n\r\n\tpublic replaceSingle(index: number, text: {}): void;\r\n\tpublic replaceSingle(indexT: Token, text: {}): void;\r\n\tpublic replaceSingle(index: Token | number, text: {}): void {\r\n\t\tif (typeof index === \"number\") {\r\n\t\t\tthis.replace(index, index, text);\r\n\t\t} else {\r\n\t\t\tthis.replace(index, index, text);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic replace(from: number, to: number, text: {}): void;\r\n\r\n\tpublic replace(from: Token, to: Token, text: {}): void;\r\n\r\n\tpublic replace(from: number, to: number, text: {}, programName: string): void;\r\n\r\n\tpublic replace(from: Token, to: Token, text: {}, programName: string): void;\r\n\r\n\tpublic replace(from: Token | number, to: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tif (typeof from !== \"number\") {\r\n\t\t\tfrom = from.tokenIndex;\r\n\t\t}\r\n\r\n\t\tif (typeof to !== \"number\") {\r\n\t\t\tto = to.tokenIndex;\r\n\t\t}\r\n\r\n\t\tif ( from > to || from < 0 || to < 0 || to >= this.tokens.size ) {\r\n\t\t\tthrow new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\r\n\t\t}\r\n\r\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\r\n\t\tlet op: RewriteOperation =  new ReplaceOp(this.tokens, from, to, rewrites.length, text);\r\n\t\trewrites.push(op);\r\n\t}\r\n\r\n\tpublic delete(index: number): void;\r\n\r\n\tpublic delete(from: number, to: number): void;\r\n\r\n\tpublic delete(indexT: Token): void;\r\n\r\n\tpublic delete(from: Token, to: Token): void;\r\n\r\n\tpublic delete(from: number, to: number, programName: string): void;\r\n\r\n\tpublic delete(from: Token, to: Token, programName: string): void;\r\n\r\n\tpublic delete(from: Token | number, to?: Token | number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\r\n\t\tif (to === undefined) {\r\n\t\t\tto = from;\r\n\t\t}\r\n\r\n\t\tif (typeof from === \"number\") {\r\n\t\t\tthis.replace(from, to as number, \"\", programName);\r\n\t\t} else {\r\n\t\t\tthis.replace(from, to as Token, \"\", programName);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getLastRewriteTokenIndex(): number;\r\n\r\n\tprotected getLastRewriteTokenIndex(programName: string): number;\r\n\r\n\tprotected getLastRewriteTokenIndex(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): number {\r\n\t\tlet I: number | undefined = this.lastRewriteTokenIndexes.get(programName);\r\n\t\tif ( I == null ) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\treturn I;\r\n\t}\r\n\r\n\tprotected setLastRewriteTokenIndex(programName: string, i: number): void {\r\n\t\tthis.lastRewriteTokenIndexes.set(programName, i);\r\n\t}\r\n\r\n\tprotected getProgram(name: string): RewriteOperation[] {\r\n\t\tlet is: RewriteOperation[] | undefined = this.programs.get(name);\r\n\t\tif ( is == null ) {\r\n\t\t\tis = this.initializeProgram(name);\r\n\t\t}\r\n\r\n\t\treturn is;\r\n\t}\r\n\r\n\tprivate initializeProgram(name: string): RewriteOperation[] {\r\n\t\tlet is: RewriteOperation[] = [];\r\n\t\tthis.programs.set(name, is);\r\n\t\treturn is;\r\n\t}\r\n\r\n\t/** Return the text from the original tokens altered per the\r\n\t *  instructions given to this rewriter.\r\n\t */\r\n\tpublic getText(): string;\r\n\r\n\t/** Return the text from the original tokens altered per the\r\n\t *  instructions given to this rewriter in programName.\r\n\t *\r\n\t * @since 4.5\r\n\t */\r\n\tpublic getText(programName: string): string;\r\n\r\n\t/** Return the text associated with the tokens in the interval from the\r\n\t *  original token stream but with the alterations given to this rewriter.\r\n\t *  The interval refers to the indexes in the original token stream.\r\n\t *  We do not alter the token stream in any way, so the indexes\r\n\t *  and intervals are still consistent. Includes any operations done\r\n\t *  to the first and last token in the interval. So, if you did an\r\n\t *  insertBefore on the first token, you would get that insertion.\r\n\t *  The same is true if you do an insertAfter the stop token.\r\n\t */\r\n\tpublic getText(interval: Interval): string;\r\n\r\n\tpublic getText(interval: Interval, programName: string): string;\r\n\r\n\tpublic getText(intervalOrProgram?: Interval | string, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): string {\r\n\t\tlet interval: Interval;\r\n\t\tif (intervalOrProgram instanceof Interval) {\r\n\t\t\tinterval = intervalOrProgram;\r\n\t\t} else {\r\n\t\t\tinterval = Interval.of(0, this.tokens.size - 1);\r\n\t\t}\r\n\r\n\t\tif (typeof intervalOrProgram === \"string\") {\r\n\t\t\tprogramName = intervalOrProgram;\r\n\t\t}\r\n\r\n\t\tlet rewrites: RewriteOperation[] | undefined = this.programs.get(programName);\r\n\t\tlet start: number =  interval.a;\r\n\t\tlet stop: number =  interval.b;\r\n\r\n\t\t// ensure start/end are in range\r\n\t\tif ( stop > this.tokens.size - 1 ) {\r\n\t\t\tstop = this.tokens.size - 1;\r\n\t\t}\r\n\t\tif ( start < 0 ) {\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\r\n\t\tif ( rewrites == null || rewrites.length === 0 ) {\r\n\t\t\treturn this.tokens.getText(interval); // no instructions to execute\r\n\t\t}\r\n\r\n\t\tlet buf: string[] = [];\r\n\r\n\t\t// First, optimize instruction stream\r\n\t\tlet indexToOp: Map<number, RewriteOperation> = this.reduceToSingleOperationPerIndex(rewrites);\r\n\r\n\t\t// Walk buffer, executing instructions and emitting tokens\r\n\t\tlet i: number =  start;\r\n\t\twhile ( i <= stop && i < this.tokens.size ) {\r\n\t\t\tlet op: RewriteOperation | undefined =  indexToOp.get(i);\r\n\t\t\tindexToOp.delete(i); // remove so any left have index size-1\r\n\t\t\tlet t: Token = this.tokens.get(i);\r\n\t\t\tif ( op == null ) {\r\n\t\t\t\t// no operation at that index, just dump token\r\n\t\t\t\tif ( t.type !== Token.EOF ) {\r\n\t\t\t\t\tbuf.push(String(t.text));\r\n\t\t\t\t}\r\n\t\t\t\ti++; // move to next token\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ti = op.execute(buf); // execute operation and skip\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// include stuff after end if it's last index in buffer\r\n\t\t// So, if they did an insertAfter(lastValidIndex, \"foo\"), include\r\n\t\t// foo if end==lastValidIndex.\r\n\t\tif ( stop === this.tokens.size - 1 ) {\r\n\t\t\t// Scan any remaining operations after last token\r\n\t\t\t// should be included (they will be inserts).\r\n\t\t\tfor (let op of indexToOp.values()) {\r\n\t\t\t\tif ( op.index >= this.tokens.size - 1 ) {\r\n\t\t\t\t\tbuf.push(op.text.toString());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn buf.join(\"\");\r\n\t}\r\n\r\n\t/** We need to combine operations and report invalid operations (like\r\n\t *  overlapping replaces that are not completed nested). Inserts to\r\n\t *  same index need to be combined etc...  Here are the cases:\r\n\t *\r\n\t *  I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping\r\n\t *  I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu\r\n\t *\r\n\t *  R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R\r\n\t *  R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R\r\n\t *  R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR\r\n\t *  R.i-j.u R.x-y.v\t| boundaries overlap\tERROR\r\n\t *\r\n\t *  Delete special case of replace (text==undefined):\r\n\t *  D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\r\n\t *\r\n\t *  I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before\r\n\t * \t\t\t\t\t\t\t\t\t\t\twe're not deleting i)\r\n\t *  I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping\r\n\t *  R.x-y.v I.i.u | i in x-y\t\t\t\tERROR\r\n\t *  R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I)\r\n\t *  R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping\r\n\t *\r\n\t *  I.i.u = insert u before op @ index i\r\n\t *  R.x-y.u = replace x-y indexed tokens with u\r\n\t *\r\n\t *  First we need to examine replaces. For any replace op:\r\n\t *\r\n\t * \t\t1. wipe out any insertions before op within that range.\r\n\t * \t\t2. Drop any replace op before that is contained completely within\r\n\t * \t that range.\r\n\t * \t\t3. Throw exception upon boundary overlap with any previous replace.\r\n\t *\r\n\t *  Then we can deal with inserts:\r\n\t *\r\n\t * \t\t1. for any inserts to same index, combine even if not adjacent.\r\n\t * \t\t2. for any prior replace with same left boundary, combine this\r\n\t * \t insert with replace and delete this replace.\r\n\t * \t\t3. throw exception if index in same range as previous replace\r\n\t *\r\n\t *  Don't actually delete; make op undefined in list. Easier to walk list.\r\n\t *  Later we can throw as we add to index &rarr; op map.\r\n\t *\r\n\t *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the\r\n\t *  inserted stuff would be before the replace range. But, if you\r\n\t *  add tokens in front of a method body '{' and then delete the method\r\n\t *  body, I think the stuff before the '{' you added should disappear too.\r\n\t *\r\n\t *  Return a map from token index to operation.\r\n\t */\r\n\tprotected reduceToSingleOperationPerIndex(rewrites: Array<RewriteOperation | undefined>): Map<number, RewriteOperation> {\r\n\t\t// console.log(`rewrites=[${Utils.join(rewrites, \", \")}]`);\r\n\r\n\t\t// WALK REPLACES\r\n\t\tfor (let i = 0; i < rewrites.length; i++) {\r\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\r\n\t\t\tif ( op == null ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ( !(op instanceof ReplaceOp) ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet rop: ReplaceOp = op;\r\n\t\t\t// Wipe prior inserts within range\r\n\t\t\tlet inserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\r\n\t\t\tfor (let iop of inserts) {\r\n\t\t\t\tif ( iop.index === rop.index ) {\r\n\t\t\t\t\t// E.g., insert before 2, delete 2..2; update replace\r\n\t\t\t\t\t// text to include insert before, kill insert\r\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\r\n\t\t\t\t\trop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\r\n\t\t\t\t}\r\n\t\t\t\telse if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\r\n\t\t\t\t\t// delete insert as it's a no-op.\r\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Drop any prior replaces contained within\r\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\r\n\t\t\tfor (let prevRop of prevReplaces) {\r\n\t\t\t\tif ( prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex ) {\r\n\t\t\t\t\t// delete replace as it's a no-op.\r\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// throw exception unless disjoint or identical\r\n\t\t\t\tlet disjoint: boolean =\r\n\t\t\t\t\tprevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\r\n\t\t\t\t// Delete special case of replace (text==null):\r\n\t\t\t\t// D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\r\n\t\t\t\tif ( prevRop.text == null && rop.text == null && !disjoint ) {\r\n\t\t\t\t\t// console.log(`overlapping deletes: ${prevRop}, ${rop}`);\r\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined; // kill first delete\r\n\t\t\t\t\trop.index = Math.min(prevRop.index, rop.index);\r\n\t\t\t\t\trop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\r\n\t\t\t\t\t// console.log(`new rop ${rop}`);\r\n\t\t\t\t}\r\n\t\t\t\telse if ( !disjoint ) {\r\n\t\t\t\t\tthrow new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// WALK INSERTS\r\n\t\tfor (let i = 0; i < rewrites.length; i++) {\r\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\r\n\t\t\tif ( op == null ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ( !(op instanceof InsertBeforeOp) ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet iop: InsertBeforeOp =  op;\r\n\t\t\t// combine current insert with prior if any at same index\r\n\t\t\tlet prevInserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\r\n\t\t\tfor (let prevIop of prevInserts) {\r\n\t\t\t\tif ( prevIop.index === iop.index ) {\r\n\t\t\t\t\tif (prevIop instanceof InsertAfterOp) {\r\n\t\t\t\t\t\tiop.text = this.catOpText(prevIop.text, iop.text);\r\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (prevIop instanceof InsertBeforeOp) { // combine objects\r\n\t\t\t\t\t\t// convert to strings...we're in process of toString'ing\r\n\t\t\t\t\t\t// whole token buffer so no lazy eval issue with any templates\r\n\t\t\t\t\t\tiop.text = this.catOpText(iop.text, prevIop.text);\r\n\t\t\t\t\t\t// delete redundant prior insert\r\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// look for replaces where iop.index is in range; error\r\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\r\n\t\t\tfor (let rop of prevReplaces) {\r\n\t\t\t\tif ( iop.index === rop.index ) {\r\n\t\t\t\t\trop.text = this.catOpText(iop.text, rop.text);\r\n\t\t\t\t\trewrites[i] = undefined;\t// delete current insert\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {\r\n\t\t\t\t\tthrow new Error(`insert op ${iop} within boundaries of previous ${rop}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// console.log(`rewrites after=[${Utils.join(rewrites, \", \")}]`);\r\n\t\tlet m: Map<number, RewriteOperation> =  new Map<number, RewriteOperation>();\r\n\t\tfor (let op of rewrites) {\r\n\t\t\tif ( op == null ) {\r\n\t\t\t\t// ignore deleted ops\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ( m.get(op.index) != null ) {\r\n\t\t\t\tthrow new Error(\"should only be one op per index\");\r\n\t\t\t}\r\n\t\t\tm.set(op.index, op);\r\n\t\t}\r\n\t\t// console.log(`index to op: ${m}`);\r\n\t\treturn m;\r\n\t}\r\n\r\n\tprotected catOpText(a: {}, b: {}): string {\r\n\t\tlet x: string =  \"\";\r\n\t\tlet y: string =  \"\";\r\n\t\tif ( a != null ) {\r\n\t\t\tx = a.toString();\r\n\t\t}\r\n\t\tif ( b != null ) {\r\n\t\t\ty = b.toString();\r\n\t\t}\r\n\t\treturn x + y;\r\n\t}\r\n\r\n\t/** Get all operations before an index of a particular kind */\r\n\tprotected getKindOfOps<T extends RewriteOperation>(rewrites: Array<RewriteOperation | undefined>, kind: {new(...args: any[]): T}, before: number): T[] {\r\n\t\tlet ops: T[] = [];\r\n\t\tfor (let i = 0; i < before && i < rewrites.length; i++) {\r\n\t\t\tlet op: RewriteOperation | undefined =  rewrites[i];\r\n\t\t\tif ( op == null ) {\r\n\t\t\t\t// ignore deleted\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ( op instanceof kind ) {\r\n\t\t\t\tops.push(op);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ops;\r\n\t}\r\n}\r\n\r\n// Define the rewrite operation hierarchy\r\n\r\nexport class RewriteOperation {\r\n\tprotected readonly tokens: TokenStream;\r\n\t/** What index into rewrites List are we? */\r\n\tpublic readonly instructionIndex: number;\r\n\t/** Token buffer index. */\r\n\tpublic index: number;\r\n\tpublic text: {};\r\n\r\n\tconstructor(tokens: TokenStream, index: number, instructionIndex: number);\r\n\tconstructor(tokens: TokenStream, index: number, instructionIndex: number, text: {});\r\n\tconstructor(tokens: TokenStream, index: number, instructionIndex: number, text?: {}) {\r\n\t\tthis.tokens = tokens;\r\n\t\tthis.instructionIndex = instructionIndex;\r\n\t\tthis.index = index;\r\n\t\tthis.text = text === undefined ? \"\" : text;\r\n\t}\r\n\r\n\t/** Execute the rewrite operation by possibly adding to the buffer.\r\n\t *  Return the index of the next token to operate on.\r\n\t */\r\n\tpublic execute(buf: string[]): number {\r\n\t\treturn this.index;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tlet opName: string = this.constructor.name;\r\n\t\tlet $index = opName.indexOf(\"$\");\r\n\t\topName = opName.substring($index + 1, opName.length);\r\n\t\treturn \"<\" + opName + \"@\" + this.tokens.get(this.index) +\r\n\t\t\t\t\":\\\"\" + this.text + \"\\\">\";\r\n\t}\r\n}\r\n\r\nclass InsertBeforeOp extends RewriteOperation {\r\n\tconstructor(tokens: TokenStream, index: number, instructionIndex: number, text: {}) {\r\n\t\tsuper(tokens, index, instructionIndex, text);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic execute(buf: string[]): number {\r\n\t\tbuf.push(this.text.toString());\r\n\t\tif ( this.tokens.get(this.index).type !== Token.EOF ) {\r\n\t\t\tbuf.push(String(this.tokens.get(this.index).text));\r\n\t\t}\r\n\t\treturn this.index + 1;\r\n\t}\r\n}\r\n\r\n/** Distinguish between insert after/before to do the \"insert afters\"\r\n *  first and then the \"insert befores\" at same index. Implementation\r\n *  of \"insert after\" is \"insert before index+1\".\r\n */\r\nclass InsertAfterOp extends InsertBeforeOp {\r\n\tconstructor(tokens: TokenStream, index: number, instructionIndex: number, text: {}) {\r\n\t\tsuper(tokens, index + 1, instructionIndex, text); // insert after is insert before index+1\r\n\t}\r\n}\r\n\r\n/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp\r\n *  instructions.\r\n */\r\nclass ReplaceOp extends RewriteOperation {\r\n\tpublic lastIndex: number;\r\n\tconstructor(tokens: TokenStream, from: number, to: number, instructionIndex: number, text: {}) {\r\n\t\tsuper(tokens, from, instructionIndex, text);\r\n\t\tthis.lastIndex = to;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic execute(buf: string[]): number {\r\n\t\tif ( this.text != null ) {\r\n\t\t\tbuf.push(this.text.toString());\r\n\t\t}\r\n\t\treturn this.lastIndex + 1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tif ( this.text == null ) {\r\n\t\t\treturn \"<DeleteOp@\" + this.tokens.get(this.index) +\r\n\t\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \">\";\r\n\t\t}\r\n\t\treturn \"<ReplaceOp@\" + this.tokens.get(this.index) +\r\n\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \":\\\"\" + this.text + \"\\\">\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nexport * from \"./ANTLRErrorListener\";\r\nexport * from \"./ANTLRErrorStrategy\";\r\n// export * from \"./ANTLRFileStream\";\r\nexport * from \"./ANTLRInputStream\";\r\nexport * from \"./BailErrorStrategy\";\r\nexport * from \"./BufferedTokenStream\";\r\nexport * from \"./CharStream\";\r\nexport * from \"./CharStreams\";\r\nexport * from \"./CodePointBuffer\";\r\nexport * from \"./CodePointCharStream\";\r\nexport * from \"./CommonToken\";\r\nexport * from \"./CommonTokenFactory\";\r\nexport * from \"./CommonTokenStream\";\r\nexport * from \"./ConsoleErrorListener\";\r\nexport * from \"./DefaultErrorStrategy\";\r\nexport * from \"./Dependents\";\r\nexport * from \"./DiagnosticErrorListener\";\r\nexport * from \"./FailedPredicateException\";\r\nexport * from \"./InputMismatchException\";\r\nexport * from \"./InterpreterRuleContext\";\r\nexport * from \"./IntStream\";\r\nexport * from \"./Lexer\";\r\nexport * from \"./LexerInterpreter\";\r\nexport * from \"./LexerNoViableAltException\";\r\nexport * from \"./ListTokenSource\";\r\nexport * from \"./NoViableAltException\";\r\nexport * from \"./Parser\";\r\nexport * from \"./ParserErrorListener\";\r\nexport * from \"./ParserInterpreter\";\r\nexport * from \"./ParserRuleContext\";\r\nexport * from \"./ProxyErrorListener\";\r\nexport * from \"./ProxyParserErrorListener\";\r\nexport * from \"./RecognitionException\";\r\nexport * from \"./Recognizer\";\r\nexport * from \"./RuleContext\";\r\nexport * from \"./RuleContextWithAltNum\";\r\nexport * from \"./RuleDependency\";\r\nexport * from \"./RuleVersion\";\r\nexport * from \"./Token\";\r\nexport * from \"./TokenFactory\";\r\nexport * from \"./TokenSource\";\r\nexport * from \"./TokenStream\";\r\nexport * from \"./TokenStreamRewriter\";\r\n// export * from \"./UnbufferedCharStream\";\r\n// export * from \"./UnbufferedTokenStream\";\r\nexport * from \"./Vocabulary\";\r\nexport * from \"./VocabularyImpl\";\r\nexport * from \"./WritableToken\";\r\n"],
  "mappings": "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",
  "names": ["Dependents"]
}
