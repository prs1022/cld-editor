import {
  require_ErrorNode,
  require_RuleNode,
  require_TerminalNode,
  require_Trees
} from "./chunk-FXRVVXGU.js";
import "./chunk-22QXU36G.js";
import "./chunk-LBKHYZ7U.js";
import "./chunk-XPQAULV4.js";
import "./chunk-ROIGMS2W.js";
import "./chunk-AVXGVIZ3.js";
import {
  require_Decorators
} from "./chunk-U6TX4QV4.js";
import "./chunk-TJPYJIIH.js";
import "./chunk-AEX2UWXW.js";
import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js
var require_AbstractParseTreeVisitor = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractParseTreeVisitor = void 0;
    var Decorators_1 = require_Decorators();
    var AbstractParseTreeVisitor = class {
      /**
       * {@inheritDoc}
       *
       * The default implementation calls {@link ParseTree#accept} on the
       * specified tree.
       */
      visit(tree) {
        return tree.accept(this);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation initializes the aggregate result to
       * {@link #defaultResult defaultResult()}. Before visiting each child, it
       * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result
       * is `false` no more children are visited and the current aggregate
       * result is returned. After visiting a child, the aggregate result is
       * updated by calling {@link #aggregateResult aggregateResult} with the
       * previous aggregate result and the result of visiting the child.
       *
       * The default implementation is not safe for use in visitors that modify
       * the tree structure. Visitors that modify the tree should override this
       * method to behave properly in respect to the specific algorithm in use.
       */
      visitChildren(node) {
        let result = this.defaultResult();
        let n = node.childCount;
        for (let i = 0; i < n; i++) {
          if (!this.shouldVisitNextChild(node, result)) {
            break;
          }
          let c = node.getChild(i);
          let childResult = c.accept(this);
          result = this.aggregateResult(result, childResult);
        }
        return result;
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation returns the result of
       * {@link #defaultResult defaultResult}.
       */
      visitTerminal(node) {
        return this.defaultResult();
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation returns the result of
       * {@link #defaultResult defaultResult}.
       */
      visitErrorNode(node) {
        return this.defaultResult();
      }
      /**
       * Aggregates the results of visiting multiple children of a node. After
       * either all children are visited or {@link #shouldVisitNextChild} returns
       * `false`, the aggregate value is returned as the result of
       * {@link #visitChildren}.
       *
       * The default implementation returns `nextResult`, meaning
       * {@link #visitChildren} will return the result of the last child visited
       * (or return the initial value if the node has no children).
       *
       * @param aggregate The previous aggregate value. In the default
       * implementation, the aggregate value is initialized to
       * {@link #defaultResult}, which is passed as the `aggregate` argument
       * to this method after the first child node is visited.
       * @param nextResult The result of the immediately preceeding call to visit
       * a child node.
       *
       * @returns The updated aggregate result.
       */
      aggregateResult(aggregate, nextResult) {
        return nextResult;
      }
      /**
       * This method is called after visiting each child in
       * {@link #visitChildren}. This method is first called before the first
       * child is visited; at that point `currentResult` will be the initial
       * value (in the default implementation, the initial value is returned by a
       * call to {@link #defaultResult}. This method is not called after the last
       * child is visited.
       *
       * The default implementation always returns `true`, indicating that
       * `visitChildren` should only return after all children are visited.
       * One reason to override this method is to provide a "short circuit"
       * evaluation option for situations where the result of visiting a single
       * child has the potential to determine the result of the visit operation as
       * a whole.
       *
       * @param node The {@link RuleNode} whose children are currently being
       * visited.
       * @param currentResult The current aggregate result of the children visited
       * to the current point.
       *
       * @returns `true` to continue visiting children. Otherwise return
       * `false` to stop visiting children and immediately return the
       * current aggregate result from {@link #visitChildren}.
       */
      shouldVisitNextChild(node, currentResult) {
        return true;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor.prototype, "visit", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor.prototype, "visitChildren", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor.prototype, "visitTerminal", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor.prototype, "visitErrorNode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], AbstractParseTreeVisitor.prototype, "shouldVisitNextChild", null);
    exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTree.js
var require_ParseTree = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeListener.js
var require_ParseTreeListener = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeProperty.js
var require_ParseTreeProperty = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeProperty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeProperty = void 0;
    var ParseTreeProperty = class {
      constructor(name = "ParseTreeProperty") {
        this._symbol = Symbol(name);
      }
      get(node) {
        return node[this._symbol];
      }
      set(node, value) {
        node[this._symbol] = value;
      }
      removeFrom(node) {
        let result = node[this._symbol];
        delete node[this._symbol];
        return result;
      }
    };
    exports.ParseTreeProperty = ParseTreeProperty;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeVisitor.js
var require_ParseTreeVisitor = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeVisitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeWalker.js
var require_ParseTreeWalker = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ParseTreeWalker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeWalker = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var TerminalNode_1 = require_TerminalNode();
    var RuleNode_1 = require_RuleNode();
    var ParseTreeWalker = class {
      /**
       * Performs a walk on the given parse tree starting at the root and going down recursively
       * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before
       * recursively walking down into child nodes, then
       * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.
       * @param listener The listener used by the walker to process grammar rules
       * @param t The parse tree to be walked on
       */
      walk(listener, t) {
        let nodeStack = [];
        let indexStack = [];
        let currentNode = t;
        let currentIndex = 0;
        while (currentNode) {
          if (currentNode instanceof ErrorNode_1.ErrorNode) {
            if (listener.visitErrorNode) {
              listener.visitErrorNode(currentNode);
            }
          } else if (currentNode instanceof TerminalNode_1.TerminalNode) {
            if (listener.visitTerminal) {
              listener.visitTerminal(currentNode);
            }
          } else {
            this.enterRule(listener, currentNode);
          }
          if (currentNode.childCount > 0) {
            nodeStack.push(currentNode);
            indexStack.push(currentIndex);
            currentIndex = 0;
            currentNode = currentNode.getChild(0);
            continue;
          }
          do {
            if (currentNode instanceof RuleNode_1.RuleNode) {
              this.exitRule(listener, currentNode);
            }
            if (nodeStack.length === 0) {
              currentNode = void 0;
              currentIndex = 0;
              break;
            }
            let last = nodeStack[nodeStack.length - 1];
            currentIndex++;
            currentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : void 0;
            if (currentNode) {
              break;
            }
            currentNode = nodeStack.pop();
            currentIndex = indexStack.pop();
          } while (currentNode);
        }
      }
      /**
       * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}
       * then by triggering the event specific to the given parse tree node
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      enterRule(listener, r) {
        let ctx = r.ruleContext;
        if (listener.enterEveryRule) {
          listener.enterEveryRule(ctx);
        }
        ctx.enterRule(listener);
      }
      /**
       * Exits a grammar rule by first triggering the event specific to the given parse tree node
       * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}
       * @param listener The listener responding to the trigger events
       * @param r The grammar rule containing the rule context
       */
      exitRule(listener, r) {
        let ctx = r.ruleContext;
        ctx.exitRule(listener);
        if (listener.exitEveryRule) {
          listener.exitEveryRule(ctx);
        }
      }
    };
    exports.ParseTreeWalker = ParseTreeWalker;
    (function(ParseTreeWalker2) {
      ParseTreeWalker2.DEFAULT = new ParseTreeWalker2();
    })(ParseTreeWalker = exports.ParseTreeWalker || (exports.ParseTreeWalker = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/SyntaxTree.js
var require_SyntaxTree = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/SyntaxTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/Tree.js
var require_Tree = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/Tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/index.js
var require_tree = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_AbstractParseTreeVisitor(), exports);
    __exportStar(require_ErrorNode(), exports);
    __exportStar(require_ParseTree(), exports);
    __exportStar(require_ParseTreeListener(), exports);
    __exportStar(require_ParseTreeProperty(), exports);
    __exportStar(require_ParseTreeVisitor(), exports);
    __exportStar(require_ParseTreeWalker(), exports);
    __exportStar(require_RuleNode(), exports);
    __exportStar(require_SyntaxTree(), exports);
    __exportStar(require_TerminalNode(), exports);
    __exportStar(require_Tree(), exports);
    __exportStar(require_Trees(), exports);
  }
});
export default require_tree();
/*! Bundled license information:

antlr4ts/tree/AbstractParseTreeVisitor.js:
antlr4ts/tree/ParseTree.js:
antlr4ts/tree/ParseTreeListener.js:
antlr4ts/tree/ParseTreeProperty.js:
antlr4ts/tree/ParseTreeVisitor.js:
antlr4ts/tree/ParseTreeWalker.js:
antlr4ts/tree/SyntaxTree.js:
antlr4ts/tree/Tree.js:
antlr4ts/tree/index.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
//# sourceMappingURL=antlr4ts_tree.js.map
