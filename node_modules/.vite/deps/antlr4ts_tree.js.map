{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/AbstractParseTreeVisitor.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/ParseTreeProperty.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/ParseTreeWalker.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/index.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.3092279-07:00\r\n\r\nimport { ErrorNode } from \"./ErrorNode\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\n\r\nexport abstract class AbstractParseTreeVisitor<Result> implements ParseTreeVisitor<Result> {\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation calls {@link ParseTree#accept} on the\r\n\t * specified tree.\r\n\t */\r\n\t@Override\r\n\tpublic visit(@NotNull tree: ParseTree): Result {\r\n\t\treturn tree.accept(this);\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation initializes the aggregate result to\r\n\t * {@link #defaultResult defaultResult()}. Before visiting each child, it\r\n\t * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result\r\n\t * is `false` no more children are visited and the current aggregate\r\n\t * result is returned. After visiting a child, the aggregate result is\r\n\t * updated by calling {@link #aggregateResult aggregateResult} with the\r\n\t * previous aggregate result and the result of visiting the child.\r\n\t *\r\n\t * The default implementation is not safe for use in visitors that modify\r\n\t * the tree structure. Visitors that modify the tree should override this\r\n\t * method to behave properly in respect to the specific algorithm in use.\r\n\t */\r\n\t@Override\r\n\tpublic visitChildren(@NotNull node: RuleNode): Result {\r\n\t\tlet result: Result = this.defaultResult();\r\n\t\tlet n: number = node.childCount;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tif (!this.shouldVisitNextChild(node, result)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlet c: ParseTree = node.getChild(i);\r\n\t\t\tlet childResult: Result = c.accept(this);\r\n\t\t\tresult = this.aggregateResult(result, childResult);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation returns the result of\r\n\t * {@link #defaultResult defaultResult}.\r\n\t */\r\n\t@Override\r\n\tpublic visitTerminal(@NotNull node: TerminalNode): Result {\r\n\t\treturn this.defaultResult();\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation returns the result of\r\n\t * {@link #defaultResult defaultResult}.\r\n\t */\r\n\t@Override\r\n\tpublic visitErrorNode(@NotNull node: ErrorNode): Result {\r\n\t\treturn this.defaultResult();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the default value returned by visitor methods. This value is\r\n\t * returned by the default implementations of\r\n\t * {@link #visitTerminal visitTerminal}, {@link #visitErrorNode visitErrorNode}.\r\n\t * The default implementation of {@link #visitChildren visitChildren}\r\n\t * initializes its aggregate result to this value.\r\n\t *\r\n\t * @returns The default value returned by visitor methods.\r\n\t */\r\n\tprotected abstract defaultResult(): Result;\r\n\r\n\t/**\r\n\t * Aggregates the results of visiting multiple children of a node. After\r\n\t * either all children are visited or {@link #shouldVisitNextChild} returns\r\n\t * `false`, the aggregate value is returned as the result of\r\n\t * {@link #visitChildren}.\r\n\t *\r\n\t * The default implementation returns `nextResult`, meaning\r\n\t * {@link #visitChildren} will return the result of the last child visited\r\n\t * (or return the initial value if the node has no children).\r\n\t *\r\n\t * @param aggregate The previous aggregate value. In the default\r\n\t * implementation, the aggregate value is initialized to\r\n\t * {@link #defaultResult}, which is passed as the `aggregate` argument\r\n\t * to this method after the first child node is visited.\r\n\t * @param nextResult The result of the immediately preceeding call to visit\r\n\t * a child node.\r\n\t *\r\n\t * @returns The updated aggregate result.\r\n\t */\r\n\tprotected aggregateResult(aggregate: Result, nextResult: Result): Result {\r\n\t\treturn nextResult;\r\n\t}\r\n\r\n\t/**\r\n\t * This method is called after visiting each child in\r\n\t * {@link #visitChildren}. This method is first called before the first\r\n\t * child is visited; at that point `currentResult` will be the initial\r\n\t * value (in the default implementation, the initial value is returned by a\r\n\t * call to {@link #defaultResult}. This method is not called after the last\r\n\t * child is visited.\r\n\t *\r\n\t * The default implementation always returns `true`, indicating that\r\n\t * `visitChildren` should only return after all children are visited.\r\n\t * One reason to override this method is to provide a \"short circuit\"\r\n\t * evaluation option for situations where the result of visiting a single\r\n\t * child has the potential to determine the result of the visit operation as\r\n\t * a whole.\r\n\t *\r\n\t * @param node The {@link RuleNode} whose children are currently being\r\n\t * visited.\r\n\t * @param currentResult The current aggregate result of the children visited\r\n\t * to the current point.\r\n\t *\r\n\t * @returns `true` to continue visiting children. Otherwise return\r\n\t * `false` to stop visiting children and immediately return the\r\n\t * current aggregate result from {@link #visitChildren}.\r\n\t */\r\n\tprotected shouldVisitNextChild(@NotNull node: RuleNode, currentResult: Result): boolean {\r\n\t\treturn true;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.6782223-07:00\r\n\r\nimport { ParseTree } from \"./ParseTree\";\r\n\r\n/**\r\n * Associate a property with a parse tree node. Useful with parse tree listeners\r\n * that need to associate values with particular tree nodes, kind of like\r\n * specifying a return value for the listener event method that visited a\r\n * particular node. Example:\r\n *\r\n * ```\r\n * ParseTreeProperty<Integer> values = new ParseTreeProperty<Integer>();\r\n * values.put(tree, 36);\r\n * int x = values.get(tree);\r\n * values.removeFrom(tree);\r\n * ```\r\n *\r\n * You would make one decl (values here) in the listener and use lots of times\r\n * in your event methods.\r\n */\r\nexport class ParseTreeProperty<V> {\r\n\tprivate _symbol: symbol;\r\n\r\n\tconstructor(name: string = \"ParseTreeProperty\") {\r\n\t\tthis._symbol = Symbol(name);\r\n\t}\r\n\r\n\tpublic get(node: ParseTree): V {\r\n\t\treturn (node as any)[this._symbol] as V;\r\n\t}\r\n\r\n\tpublic set(node: ParseTree, value: V): void {\r\n\t\t(node as any)[this._symbol] = value;\r\n\t}\r\n\r\n\tpublic removeFrom(node: ParseTree): V {\r\n\t\tlet result = (node as any)[this._symbol] as V;\r\n\t\tdelete (node as any)[this._symbol];\r\n\t\treturn result;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.8252451-07:00\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeListener } from \"./ParseTreeListener\";\r\nimport { ErrorNode } from \"./ErrorNode\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\n\r\nexport class ParseTreeWalker {\r\n\t/**\r\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\r\n\t * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before\r\n\t * recursively walking down into child nodes, then\r\n\t * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.\r\n\t * @param listener The listener used by the walker to process grammar rules\r\n\t * @param t The parse tree to be walked on\r\n\t */\r\n\tpublic walk<T extends ParseTreeListener>(listener: T, t: ParseTree): void {\r\n\t\tlet nodeStack: ParseTree[] = [];\r\n\t\tlet indexStack: number[] = [];\r\n\r\n\t\tlet currentNode: ParseTree | undefined = t;\r\n\t\tlet currentIndex: number = 0;\r\n\r\n\t\twhile (currentNode) {\r\n\t\t\t// pre-order visit\r\n\t\t\tif (currentNode instanceof ErrorNode) {\r\n\t\t\t\tif (listener.visitErrorNode) {\r\n\t\t\t\t\tlistener.visitErrorNode(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else if (currentNode instanceof TerminalNode) {\r\n\t\t\t\tif (listener.visitTerminal) {\r\n\t\t\t\t\tlistener.visitTerminal(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.enterRule(listener, currentNode as RuleNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Move down to first child, if exists\r\n\t\t\tif (currentNode.childCount > 0) {\r\n\t\t\t\tnodeStack.push(currentNode);\r\n\t\t\t\tindexStack.push(currentIndex);\r\n\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\tcurrentNode = currentNode.getChild(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// No child nodes, so walk tree\r\n\t\t\tdo {\r\n\t\t\t\t// post-order visit\r\n\t\t\t\tif (currentNode instanceof RuleNode) {\r\n\t\t\t\t\tthis.exitRule(listener, currentNode);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No parent, so no siblings\r\n\t\t\t\tif (nodeStack.length === 0) {\r\n\t\t\t\t\tcurrentNode = undefined;\r\n\t\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move to next sibling if possible\r\n\t\t\t\tlet last = nodeStack[nodeStack.length - 1];\r\n\t\t\t\tcurrentIndex++;\r\n\t\t\t\tcurrentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;\r\n\t\t\t\tif (currentNode) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No next sibling, so move up\r\n\t\t\t\tcurrentNode = nodeStack.pop();\r\n\t\t\t\tcurrentIndex = indexStack.pop()!;\r\n\t\t\t} while (currentNode);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}\r\n\t * then by triggering the event specific to the given parse tree node\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected enterRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tif (listener.enterEveryRule) {\r\n\t\t\tlistener.enterEveryRule(ctx);\r\n\t\t}\r\n\r\n\t\tctx.enterRule(listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\r\n\t * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected exitRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tctx.exitRule(listener);\r\n\t\tif (listener.exitEveryRule) {\r\n\t\t\tlistener.exitEveryRule(ctx);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport namespace ParseTreeWalker {\r\n\texport const DEFAULT: ParseTreeWalker = new ParseTreeWalker();\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nexport * from \"./AbstractParseTreeVisitor\";\r\nexport * from \"./ErrorNode\";\r\nexport * from \"./ParseTree\";\r\nexport * from \"./ParseTreeListener\";\r\nexport * from \"./ParseTreeProperty\";\r\nexport * from \"./ParseTreeVisitor\";\r\nexport * from \"./ParseTreeWalker\";\r\nexport * from \"./RuleNode\";\r\nexport * from \"./SyntaxTree\";\r\nexport * from \"./TerminalNode\";\r\nexport * from \"./Tree\";\r\nexport * from \"./Trees\";\r\n"],
  "mappings": "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",
  "names": ["ParseTreeWalker"]
}
