{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PredicateTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/FailedPredicateException.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.2826960-07:00\r\n\r\nimport { AbstractPredicateTransition } from \"./AbstractPredicateTransition\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/** TODO: this is old comment:\r\n *  A tree of semantic predicates from the grammar AST if label==SEMPRED.\r\n *  In the ATN, labels will always be exactly one predicate, but the DFA\r\n *  may have to combine a bunch of them as it collects predicates from\r\n *  multiple ATN configurations into a single DFA state.\r\n */\r\nexport class PredicateTransition extends AbstractPredicateTransition {\r\n\tpublic ruleIndex: number;\r\n\tpublic predIndex: number;\r\n\tpublic isCtxDependent: boolean;   // e.g., $i ref in pred\r\n\r\n\tconstructor(@NotNull target: ATNState, ruleIndex: number, predIndex: number, isCtxDependent: boolean) {\r\n\t\tsuper(target);\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t\tthis.predIndex = predIndex;\r\n\t\tthis.isCtxDependent = isCtxDependent;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.PREDICATE;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEpsilon(): boolean { return true; }\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget predicate(): SemanticContext.Predicate {\r\n\t\treturn new SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn \"pred_\" + this.ruleIndex + \":\" + this.predIndex;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.4099946-07:00\r\n\r\nimport { AbstractPredicateTransition } from \"./atn/AbstractPredicateTransition\";\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNState } from \"./atn/ATNState\";\r\nimport { Parser } from \"./Parser\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { NotNull } from \"./Decorators\";\r\nimport { PredicateTransition } from \"./atn/PredicateTransition\";\r\n\r\n/** A semantic predicate failed during validation.  Validation of predicates\r\n *  occurs when normally parsing the alternative just like matching a token.\r\n *  Disambiguating predicate evaluation occurs when we test a predicate during\r\n *  prediction.\r\n */\r\nexport class FailedPredicateException extends RecognitionException {\r\n\t//private static serialVersionUID: number =  5379330841495778709L;\r\n\r\n\tprivate _ruleIndex: number;\r\n\tprivate _predicateIndex: number;\r\n\tprivate _predicate?: string;\r\n\r\n\tconstructor(@NotNull recognizer: Parser, predicate?: string, message?: string) {\r\n\t\tsuper(\r\n\t\t\trecognizer,\r\n\t\t\trecognizer.inputStream,\r\n\t\t\trecognizer.context,\r\n\t\t\tFailedPredicateException.formatMessage(predicate, message));\r\n\t\tlet s: ATNState = recognizer.interpreter.atn.states[recognizer.state];\r\n\r\n\t\tlet trans = s.transition(0) as AbstractPredicateTransition;\r\n\t\tif (trans instanceof PredicateTransition) {\r\n\t\t\tthis._ruleIndex = trans.ruleIndex;\r\n\t\t\tthis._predicateIndex = trans.predIndex;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._ruleIndex = 0;\r\n\t\t\tthis._predicateIndex = 0;\r\n\t\t}\r\n\r\n\t\tthis._predicate = predicate;\r\n\t\tsuper.setOffendingToken(recognizer, recognizer.currentToken);\r\n\t}\r\n\r\n\tget ruleIndex(): number {\r\n\t\treturn this._ruleIndex;\r\n\t}\r\n\r\n\tget predicateIndex(): number {\r\n\t\treturn this._predicateIndex;\r\n\t}\r\n\r\n\tget predicate(): string | undefined {\r\n\t\treturn this._predicate;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprivate static formatMessage(predicate: string | undefined, message: string | undefined): string {\r\n\t\tif (message) {\r\n\t\t\treturn message;\r\n\t\t}\r\n\r\n\t\treturn `failed predicate: {${predicate}}?`;\r\n\t}\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,QAAA,gCAAA;AAEA,QAAA,eAAA;AACA,QAAA,oBAAA;AASA,QAAa,sBAAb,MAAa,4BAA4B,8BAAA,4BAA2B;MAKnE,YAAqB,QAAkB,WAAmB,WAAmB,gBAAuB;AACnG,cAAM,MAAM;AACZ,aAAK,YAAY;AACjB,aAAK,YAAY;AACjB,aAAK,iBAAiB;MACvB;MAGA,IAAI,oBAAiB;AACpB,eAAA;MACD;MAGA,IAAI,YAAS;AAAc,eAAO;MAAM;MAGjC,QAAQ,QAAgB,gBAAwB,gBAAsB;AAC5E,eAAO;MACR;MAEA,IAAI,YAAS;AACZ,eAAO,IAAI,kBAAA,gBAAgB,UAAU,KAAK,WAAW,KAAK,WAAW,KAAK,cAAc;MACzF;MAIO,WAAQ;AACd,eAAO,UAAU,KAAK,YAAY,MAAM,KAAK;MAC9C;;AApBA,eAAA;MADC,aAAA;;AAMD,eAAA;MADC,aAAA;;AAID,eAAA;MADC,aAAA;;AAWD,eAAA;MAFC,aAAA;MACA,aAAA;;AA9BW,0BAAmB,WAAA;MAKlB,QAAA,GAAA,aAAA,OAAO;OALR,mBAAmB;AAAnB,YAAA,sBAAA;;;;;;;;;;;;;;;;;;;;ACRb,QAAA,yBAAA;AAEA,QAAA,eAAA;AACA,QAAA,wBAAA;AAOA,QAAa,2BAAb,MAAaA,kCAAiC,uBAAA,qBAAoB;MAOjE,YAAqB,YAAoB,WAAoB,SAAgB;AAC5E,cACC,YACA,WAAW,aACX,WAAW,SACXA,0BAAyB,cAAc,WAAW,OAAO,CAAC;AAC3D,YAAI,IAAc,WAAW,YAAY,IAAI,OAAO,WAAW,KAAK;AAEpE,YAAI,QAAQ,EAAE,WAAW,CAAC;AAC1B,YAAI,iBAAiB,sBAAA,qBAAqB;AACzC,eAAK,aAAa,MAAM;AACxB,eAAK,kBAAkB,MAAM;eAEzB;AACJ,eAAK,aAAa;AAClB,eAAK,kBAAkB;;AAGxB,aAAK,aAAa;AAClB,cAAM,kBAAkB,YAAY,WAAW,YAAY;MAC5D;MAEA,IAAI,YAAS;AACZ,eAAO,KAAK;MACb;MAEA,IAAI,iBAAc;AACjB,eAAO,KAAK;MACb;MAEA,IAAI,YAAS;AACZ,eAAO,KAAK;MACb;MAGQ,OAAO,cAAc,WAA+B,SAA2B;AACtF,YAAI,SAAS;AACZ,iBAAO;;AAGR,eAAO,sBAAsB,SAAS;MACvC;;AANA,eAAA;MADC,aAAA;;AAzCW,+BAAwB,WAAA;MAOvB,QAAA,GAAA,aAAA,OAAO;OAPR,wBAAwB;AAAxB,YAAA,2BAAA;;;",
  "names": ["FailedPredicateException"]
}
