import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/RecognitionException.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecognitionException = void 0;
    var RecognitionException = class extends Error {
      constructor(recognizer, input, ctx, message) {
        super(message);
        this._offendingState = -1;
        this._recognizer = recognizer;
        this.input = input;
        this.ctx = ctx;
        if (recognizer) {
          this._offendingState = recognizer.state;
        }
      }
      /**
       * Get the ATN state number the parser was in at the time the error
       * occurred. For {@link NoViableAltException} and
       * {@link LexerNoViableAltException} exceptions, this is the
       * {@link DecisionState} number. For others, it is the state whose outgoing
       * edge we couldn't match.
       *
       * If the state number is not known, this method returns -1.
       */
      get offendingState() {
        return this._offendingState;
      }
      setOffendingState(offendingState) {
        this._offendingState = offendingState;
      }
      /**
       * Gets the set of input symbols which could potentially follow the
       * previously matched symbol at the time this exception was thrown.
       *
       * If the set of expected tokens is not known and could not be computed,
       * this method returns `undefined`.
       *
       * @returns The set of token types that could potentially follow the current
       * state in the ATN, or `undefined` if the information is not available.
       */
      get expectedTokens() {
        if (this._recognizer) {
          return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
        }
        return void 0;
      }
      /**
       * Gets the {@link RuleContext} at the time this exception was thrown.
       *
       * If the context is not available, this method returns `undefined`.
       *
       * @returns The {@link RuleContext} at the time this exception was thrown.
       * If the context is not available, this method returns `undefined`.
       */
      get context() {
        return this.ctx;
      }
      /**
       * Gets the input stream which is the symbol source for the recognizer where
       * this exception was thrown.
       *
       * If the input stream is not available, this method returns `undefined`.
       *
       * @returns The input stream which is the symbol source for the recognizer
       * where this exception was thrown, or `undefined` if the stream is not
       * available.
       */
      get inputStream() {
        return this.input;
      }
      getOffendingToken(recognizer) {
        if (recognizer && recognizer !== this._recognizer) {
          return void 0;
        }
        return this.offendingToken;
      }
      setOffendingToken(recognizer, offendingToken) {
        if (recognizer === this._recognizer) {
          this.offendingToken = offendingToken;
        }
      }
      /**
       * Gets the {@link Recognizer} where this exception occurred.
       *
       * If the recognizer is not available, this method returns `undefined`.
       *
       * @returns The recognizer where this exception occurred, or `undefined` if
       * the recognizer is not available.
       */
      get recognizer() {
        return this._recognizer;
      }
    };
    exports.RecognitionException = RecognitionException;
  }
});

export {
  require_RecognitionException
};
/*! Bundled license information:

antlr4ts/RecognitionException.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
//# sourceMappingURL=chunk-AVXGVIZ3.js.map
