{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/RecognitionException.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.0697674-07:00\r\nimport { CharStream } from \"./CharStream\";\r\nimport { IntervalSet } from \"./misc/IntervalSet\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { Lexer } from \"./Lexer\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { Token } from \"./Token\";\r\n\r\n\r\n/** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\r\n *  3 kinds of errors: prediction errors, failed predicate errors, and\r\n *  mismatched input errors. In each case, the parser knows where it is\r\n *  in the input, where it is in the ATN, the rule invocation stack,\r\n *  and what kind of problem occurred.\r\n */\r\nexport class RecognitionException extends Error {\r\n\t// private static serialVersionUID: number =  -3861826954750022374L;\r\n\r\n\t/** The {@link Recognizer} where this exception originated. */\r\n\tprivate _recognizer?: Recognizer<any, any>;\r\n\r\n\tprivate ctx?: RuleContext;\r\n\r\n\tprivate input?: IntStream;\r\n\r\n\t/**\r\n\t * The current {@link Token} when an error occurred. Since not all streams\r\n\t * support accessing symbols by index, we have to track the {@link Token}\r\n\t * instance itself.\r\n\t */\r\n\tprivate offendingToken?: Token;\r\n\r\n\tprivate _offendingState: number = -1;\r\n\r\n\tconstructor(\r\n\t\tlexer: Lexer | undefined,\r\n\t\tinput: CharStream);\r\n\r\n\tconstructor(\r\n\t\trecognizer: Recognizer<Token, any> | undefined,\r\n\t\tinput: IntStream | undefined,\r\n\t\tctx: ParserRuleContext | undefined);\r\n\r\n\tconstructor(\r\n\t\trecognizer: Recognizer<Token, any> | undefined,\r\n\t\tinput: IntStream | undefined,\r\n\t\tctx: ParserRuleContext | undefined,\r\n\t\tmessage: string);\r\n\r\n\tconstructor(\r\n\t\trecognizer: Lexer | Recognizer<Token, any> | undefined,\r\n\t\tinput: CharStream | IntStream | undefined,\r\n\t\tctx?: ParserRuleContext,\r\n\t\tmessage?: string) {\r\n\t\tsuper(message);\r\n\r\n\t\tthis._recognizer = recognizer;\r\n\t\tthis.input = input;\r\n\t\tthis.ctx = ctx;\r\n\t\tif (recognizer) {\r\n\t\t\tthis._offendingState = recognizer.state;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the ATN state number the parser was in at the time the error\r\n\t * occurred. For {@link NoViableAltException} and\r\n\t * {@link LexerNoViableAltException} exceptions, this is the\r\n\t * {@link DecisionState} number. For others, it is the state whose outgoing\r\n\t * edge we couldn't match.\r\n\t *\r\n\t * If the state number is not known, this method returns -1.\r\n\t */\r\n\tget offendingState(): number {\r\n\t\treturn this._offendingState;\r\n\t}\r\n\r\n\tprotected setOffendingState(offendingState: number): void {\r\n\t\tthis._offendingState = offendingState;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the set of input symbols which could potentially follow the\r\n\t * previously matched symbol at the time this exception was thrown.\r\n\t *\r\n\t * If the set of expected tokens is not known and could not be computed,\r\n\t * this method returns `undefined`.\r\n\t *\r\n\t * @returns The set of token types that could potentially follow the current\r\n\t * state in the ATN, or `undefined` if the information is not available.\r\n\t */\r\n\tget expectedTokens(): IntervalSet | undefined {\r\n\t\tif (this._recognizer) {\r\n\t\t\treturn this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the {@link RuleContext} at the time this exception was thrown.\r\n\t *\r\n\t * If the context is not available, this method returns `undefined`.\r\n\t *\r\n\t * @returns The {@link RuleContext} at the time this exception was thrown.\r\n\t * If the context is not available, this method returns `undefined`.\r\n\t */\r\n\tget context(): RuleContext | undefined {\r\n\t\treturn this.ctx;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the input stream which is the symbol source for the recognizer where\r\n\t * this exception was thrown.\r\n\t *\r\n\t * If the input stream is not available, this method returns `undefined`.\r\n\t *\r\n\t * @returns The input stream which is the symbol source for the recognizer\r\n\t * where this exception was thrown, or `undefined` if the stream is not\r\n\t * available.\r\n\t */\r\n\r\n\tget inputStream(): IntStream | undefined {\r\n\t\treturn this.input;\r\n\t}\r\n\r\n\tpublic getOffendingToken(recognizer?: Recognizer<Token, any>): Token | undefined {\r\n\t\tif (recognizer && recognizer !== this._recognizer) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\treturn this.offendingToken;\r\n\t}\r\n\r\n\tprotected setOffendingToken<TSymbol extends Token>(\r\n\t\trecognizer: Recognizer<TSymbol, any>,\r\n\t\toffendingToken?: TSymbol): void {\r\n\t\tif (recognizer === this._recognizer) {\r\n\t\t\tthis.offendingToken = offendingToken;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the {@link Recognizer} where this exception occurred.\r\n\t *\r\n\t * If the recognizer is not available, this method returns `undefined`.\r\n\t *\r\n\t * @returns The recognizer where this exception occurred, or `undefined` if\r\n\t * the recognizer is not available.\r\n\t */\r\n\tget recognizer(): Recognizer<any, any> | undefined {\r\n\t\treturn this._recognizer;\r\n\t}\r\n}\r\n"],
  "mappings": ";;;;;;;;;AAuBA,QAAa,uBAAb,cAA0C,MAAK;MAkC9C,YACC,YACA,OACA,KACA,SAAgB;AAChB,cAAM,OAAO;AAtBN,aAAA,kBAA0B;AAwBjC,aAAK,cAAc;AACnB,aAAK,QAAQ;AACb,aAAK,MAAM;AACX,YAAI,YAAY;AACf,eAAK,kBAAkB,WAAW;;MAEpC;;;;;;;;;;MAWA,IAAI,iBAAc;AACjB,eAAO,KAAK;MACb;MAEU,kBAAkB,gBAAsB;AACjD,aAAK,kBAAkB;MACxB;;;;;;;;;;;MAYA,IAAI,iBAAc;AACjB,YAAI,KAAK,aAAa;AACrB,iBAAO,KAAK,YAAY,IAAI,kBAAkB,KAAK,iBAAiB,KAAK,GAAG;;AAE7E,eAAO;MACR;;;;;;;;;MAUA,IAAI,UAAO;AACV,eAAO,KAAK;MACb;;;;;;;;;;;MAaA,IAAI,cAAW;AACd,eAAO,KAAK;MACb;MAEO,kBAAkB,YAAmC;AAC3D,YAAI,cAAc,eAAe,KAAK,aAAa;AAClD,iBAAO;;AAER,eAAO,KAAK;MACb;MAEU,kBACT,YACA,gBAAwB;AACxB,YAAI,eAAe,KAAK,aAAa;AACpC,eAAK,iBAAiB;;MAExB;;;;;;;;;MAUA,IAAI,aAAU;AACb,eAAO,KAAK;MACb;;AAvID,YAAA,uBAAA;;;",
  "names": []
}
