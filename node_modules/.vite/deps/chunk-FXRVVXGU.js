import {
  require_FailedPredicateException,
  require_PredicateTransition
} from "./chunk-22QXU36G.js";
import {
  require_ATN,
  require_ATNConfig,
  require_ATNConfigSet,
  require_ATNSimulator,
  require_ATNState,
  require_ATNStateType,
  require_AcceptStateInfo,
  require_Array2DHashMap,
  require_Arrays,
  require_BasicState,
  require_BitSet,
  require_CommonToken,
  require_CommonTokenFactory,
  require_DFA,
  require_DFAState,
  require_DecisionState,
  require_IntegerList,
  require_IntegerStack,
  require_Interval,
  require_IntervalSet,
  require_InvalidState,
  require_Lexer,
  require_LexerATNSimulator,
  require_LexerNoViableAltException,
  require_NotSetTransition,
  require_PredictionContext,
  require_PredictionContextCache,
  require_ProxyErrorListener,
  require_Recognizer,
  require_RuleStopState,
  require_RuleTransition,
  require_SetTransition,
  require_StarLoopEntryState,
  require_WildcardTransition
} from "./chunk-LBKHYZ7U.js";
import {
  require_VocabularyImpl
} from "./chunk-XPQAULV4.js";
import {
  require_AbstractPredicateTransition,
  require_Array2DHashSet,
  require_MurmurHash,
  require_ObjectEqualityComparator,
  require_SemanticContext,
  require_Transition,
  require_assert
} from "./chunk-ROIGMS2W.js";
import {
  require_RecognitionException
} from "./chunk-AVXGVIZ3.js";
import {
  require_Decorators
} from "./chunk-U6TX4QV4.js";
import {
  require_Utils
} from "./chunk-TJPYJIIH.js";
import {
  require_IntStream,
  require_Token
} from "./chunk-AEX2UWXW.js";
import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/TerminalNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TerminalNode = void 0;
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var TerminalNode = class {
      constructor(symbol) {
        this._symbol = symbol;
      }
      getChild(i) {
        throw new RangeError("Terminal Node has no children.");
      }
      get symbol() {
        return this._symbol;
      }
      get parent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this._symbol;
      }
      get sourceInterval() {
        let tokenIndex = this._symbol.tokenIndex;
        return new Interval_1.Interval(tokenIndex, tokenIndex);
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitTerminal(this);
      }
      get text() {
        return this._symbol.text || "";
      }
      toStringTree(parser) {
        return this.toString();
      }
      toString() {
        if (this._symbol.type === Token_1.Token.EOF) {
          return "<EOF>";
        }
        return this._symbol.text || "";
      }
    };
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toStringTree", null);
    __decorate([
      Decorators_1.Override
    ], TerminalNode.prototype, "toString", null);
    exports.TerminalNode = TerminalNode;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/ErrorNode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorNode = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var ErrorNode = class extends TerminalNode_1.TerminalNode {
      constructor(token) {
        super(token);
      }
      accept(visitor) {
        return visitor.visitErrorNode(this);
      }
    };
    __decorate([
      Decorators_1.Override
    ], ErrorNode.prototype, "accept", null);
    exports.ErrorNode = ErrorNode;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/RuleNode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleNode = void 0;
    var RuleNode = class {
    };
    exports.RuleNode = RuleNode;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ATNDeserializationOptions.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializationOptions = void 0;
    var Decorators_1 = require_Decorators();
    var ATNDeserializationOptions = class _ATNDeserializationOptions {
      constructor(options) {
        this.readOnly = false;
        if (options) {
          this.verifyATN = options.verifyATN;
          this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
          this.optimize = options.optimize;
        } else {
          this.verifyATN = true;
          this.generateRuleBypassTransitions = false;
          this.optimize = true;
        }
      }
      static get defaultOptions() {
        if (_ATNDeserializationOptions._defaultOptions == null) {
          _ATNDeserializationOptions._defaultOptions = new _ATNDeserializationOptions();
          _ATNDeserializationOptions._defaultOptions.makeReadOnly();
        }
        return _ATNDeserializationOptions._defaultOptions;
      }
      get isReadOnly() {
        return this.readOnly;
      }
      makeReadOnly() {
        this.readOnly = true;
      }
      get isVerifyATN() {
        return this.verifyATN;
      }
      set isVerifyATN(verifyATN) {
        this.throwIfReadOnly();
        this.verifyATN = verifyATN;
      }
      get isGenerateRuleBypassTransitions() {
        return this.generateRuleBypassTransitions;
      }
      set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
        this.throwIfReadOnly();
        this.generateRuleBypassTransitions = generateRuleBypassTransitions;
      }
      get isOptimize() {
        return this.optimize;
      }
      set isOptimize(optimize) {
        this.throwIfReadOnly();
        this.optimize = optimize;
      }
      throwIfReadOnly() {
        if (this.isReadOnly) {
          throw new Error("The object is read only.");
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializationOptions, "defaultOptions", null);
    exports.ATNDeserializationOptions = ATNDeserializationOptions;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ActionTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var ActionTransition = class ActionTransition extends Transition_1.Transition {
      constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
        super(target);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isCtxDependent = isCtxDependent;
      }
      get serializationType() {
        return 6;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], ActionTransition.prototype, "toString", null);
    ActionTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ActionTransition);
    exports.ActionTransition = ActionTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AtomTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AtomTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var AtomTransition = class AtomTransition extends Transition_1.Transition {
      constructor(target, label) {
        super(target);
        this._label = label;
      }
      get serializationType() {
        return 5;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this._label);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this._label === symbol;
      }
      toString() {
        return String(this.label);
      }
    };
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], AtomTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], AtomTransition.prototype, "toString", null);
    AtomTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], AtomTransition);
    exports.AtomTransition = AtomTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BlockStartState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockStartState = void 0;
    var DecisionState_1 = require_DecisionState();
    var BlockStartState = class extends DecisionState_1.DecisionState {
    };
    exports.BlockStartState = BlockStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BasicBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BasicBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BasicBlockStartState.prototype, "stateType", null);
    exports.BasicBlockStartState = BasicBlockStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/BlockEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var BlockEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.BLOCK_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], BlockEndState.prototype, "stateType", null);
    exports.BlockEndState = BlockEndState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/EpsilonTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EpsilonTransition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
      constructor(target, outermostPrecedenceReturn = -1) {
        super(target);
        this._outermostPrecedenceReturn = outermostPrecedenceReturn;
      }
      /**
       * @returns the rule index of a precedence rule for which this transition is
       * returning from, where the precedence value is 0; otherwise, -1.
       *
       * @see ATNConfig.isPrecedenceFilterSuppressed
       * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)
       * @since 4.4.1
       */
      get outermostPrecedenceReturn() {
        return this._outermostPrecedenceReturn;
      }
      get serializationType() {
        return 1;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    };
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], EpsilonTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], EpsilonTransition.prototype, "toString", null);
    EpsilonTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], EpsilonTransition);
    exports.EpsilonTransition = EpsilonTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerChannelAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerChannelAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerChannelAction = class _LexerChannelAction {
      /**
       * Constructs a new `channel` action with the specified channel value.
       * @param channel The channel value to pass to {@link Lexer#setChannel}.
       */
      constructor(channel) {
        this._channel = channel;
      }
      /**
       * Gets the channel to use for the {@link Token} created by the lexer.
       *
       * @returns The channel to use for the {@link Token} created by the lexer.
       */
      get channel() {
        return this._channel;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#CHANNEL}.
       */
      get actionType() {
        return 0;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#setChannel} with the
       * value provided by {@link #getChannel}.
       */
      execute(lexer) {
        lexer.channel = this._channel;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerChannelAction)) {
          return false;
        }
        return this._channel === obj._channel;
      }
      toString() {
        return `channel(${this._channel})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerChannelAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerChannelAction.prototype, "toString", null);
    exports.LexerChannelAction = LexerChannelAction;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerCustomAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerCustomAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerCustomAction = class _LexerCustomAction {
      /**
       * Constructs a custom lexer action with the specified rule and action
       * indexes.
       *
       * @param ruleIndex The rule index to use for calls to
       * {@link Recognizer#action}.
       * @param actionIndex The action index to use for calls to
       * {@link Recognizer#action}.
       */
      constructor(ruleIndex, actionIndex) {
        this._ruleIndex = ruleIndex;
        this._actionIndex = actionIndex;
      }
      /**
       * Gets the rule index to use for calls to {@link Recognizer#action}.
       *
       * @returns The rule index for the custom action.
       */
      get ruleIndex() {
        return this._ruleIndex;
      }
      /**
       * Gets the action index to use for calls to {@link Recognizer#action}.
       *
       * @returns The action index for the custom action.
       */
      get actionIndex() {
        return this._actionIndex;
      }
      /**
       * {@inheritDoc}
       *
       * @returns This method returns {@link LexerActionType#CUSTOM}.
       */
      get actionType() {
        return 1;
      }
      /**
       * Gets whether the lexer action is position-dependent. Position-dependent
       * actions may have different semantics depending on the {@link CharStream}
       * index at the time the action is executed.
       *
       * Custom actions are position-dependent since they may represent a
       * user-defined embedded action which makes calls to methods like
       * {@link Lexer#getText}.
       *
       * @returns This method returns `true`.
       */
      get isPositionDependent() {
        return true;
      }
      /**
       * {@inheritDoc}
       *
       * Custom actions are implemented by calling {@link Lexer#action} with the
       * appropriate rule and action indexes.
       */
      execute(lexer) {
        lexer.action(void 0, this._ruleIndex, this._actionIndex);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
        hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
        return MurmurHash_1.MurmurHash.finish(hash, 3);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerCustomAction)) {
          return false;
        }
        return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerCustomAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerCustomAction.prototype, "equals", null);
    exports.LexerCustomAction = LexerCustomAction;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerModeAction = class _LexerModeAction {
      /**
       * Constructs a new `mode` action with the specified mode value.
       * @param mode The mode value to pass to {@link Lexer#mode}.
       */
      constructor(mode) {
        this._mode = mode;
      }
      /**
       * Get the lexer mode this action should transition the lexer to.
       *
       * @returns The lexer mode for this `mode` command.
       */
      get mode() {
        return this._mode;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#MODE}.
       */
      get actionType() {
        return 2;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#mode} with the
       * value provided by {@link #getMode}.
       */
      execute(lexer) {
        lexer.mode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `mode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerModeAction.prototype, "toString", null);
    exports.LexerModeAction = LexerModeAction;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerMoreAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerMoreAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerMoreAction = class {
      /**
       * Constructs the singleton instance of the lexer `more` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#MORE}.
       */
      get actionType() {
        return 3;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#more}.
       */
      execute(lexer) {
        lexer.more();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "more";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerMoreAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerMoreAction.prototype, "toString", null);
    exports.LexerMoreAction = LexerMoreAction;
    (function(LexerMoreAction2) {
      LexerMoreAction2.INSTANCE = new LexerMoreAction2();
    })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerPopModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPopModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPopModeAction = class {
      /**
       * Constructs the singleton instance of the lexer `popMode` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#POP_MODE}.
       */
      get actionType() {
        return 4;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#popMode}.
       */
      execute(lexer) {
        lexer.popMode();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "popMode";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPopModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPopModeAction.prototype, "toString", null);
    exports.LexerPopModeAction = LexerPopModeAction;
    (function(LexerPopModeAction2) {
      LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
    })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerPushModeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerPushModeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerPushModeAction = class _LexerPushModeAction {
      /**
       * Constructs a new `pushMode` action with the specified mode value.
       * @param mode The mode value to pass to {@link Lexer#pushMode}.
       */
      constructor(mode) {
        this._mode = mode;
      }
      /**
       * Get the lexer mode this action should transition the lexer to.
       *
       * @returns The lexer mode for this `pushMode` command.
       */
      get mode() {
        return this._mode;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#PUSH_MODE}.
       */
      get actionType() {
        return 5;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#pushMode} with the
       * value provided by {@link #getMode}.
       */
      execute(lexer) {
        lexer.pushMode(this._mode);
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerPushModeAction)) {
          return false;
        }
        return this._mode === obj._mode;
      }
      toString() {
        return `pushMode(${this._mode})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerPushModeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerPushModeAction.prototype, "toString", null);
    exports.LexerPushModeAction = LexerPushModeAction;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerSkipAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerSkipAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerSkipAction = class {
      /**
       * Constructs the singleton instance of the lexer `skip` command.
       */
      constructor() {
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#SKIP}.
       */
      get actionType() {
        return 6;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by calling {@link Lexer#skip}.
       */
      execute(lexer) {
        lexer.skip();
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        return MurmurHash_1.MurmurHash.finish(hash, 1);
      }
      equals(obj) {
        return obj === this;
      }
      toString() {
        return "skip";
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerSkipAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerSkipAction.prototype, "toString", null);
    exports.LexerSkipAction = LexerSkipAction;
    (function(LexerSkipAction2) {
      LexerSkipAction2.INSTANCE = new LexerSkipAction2();
    })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LexerTypeAction.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LexerTypeAction = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var LexerTypeAction = class _LexerTypeAction {
      /**
       * Constructs a new `type` action with the specified token type value.
       * @param type The type to assign to the token using `Lexer.type`.
       */
      constructor(type) {
        this._type = type;
      }
      /**
       * Gets the type to assign to a token created by the lexer.
       * @returns The type to assign to a token created by the lexer.
       */
      get type() {
        return this._type;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns {@link LexerActionType#TYPE}.
       */
      get actionType() {
        return 7;
      }
      /**
       * {@inheritDoc}
       * @returns This method returns `false`.
       */
      get isPositionDependent() {
        return false;
      }
      /**
       * {@inheritDoc}
       *
       * This action is implemented by setting `Lexer.type` with the
       * value provided by `type`.
       */
      execute(lexer) {
        lexer.type = this._type;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
        hash = MurmurHash_1.MurmurHash.update(hash, this._type);
        return MurmurHash_1.MurmurHash.finish(hash, 2);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _LexerTypeAction)) {
          return false;
        }
        return this._type === obj._type;
      }
      toString() {
        return `type(${this._type})`;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "actionType", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "isPositionDependent", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], LexerTypeAction.prototype, "execute", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], LexerTypeAction.prototype, "toString", null);
    exports.LexerTypeAction = LexerTypeAction;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LoopEndState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoopEndState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var LoopEndState = class extends ATNState_1.ATNState {
      get stateType() {
        return ATNStateType_1.ATNStateType.LOOP_END;
      }
    };
    __decorate([
      Decorators_1.Override
    ], LoopEndState.prototype, "stateType", null);
    exports.LoopEndState = LoopEndState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ConflictInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConflictInfo = void 0;
    var Decorators_1 = require_Decorators();
    var Utils = require_Utils();
    var ConflictInfo = class _ConflictInfo {
      constructor(conflictedAlts, exact) {
        this._conflictedAlts = conflictedAlts;
        this.exact = exact;
      }
      /**
       * Gets the set of conflicting alternatives for the configuration set.
       */
      get conflictedAlts() {
        return this._conflictedAlts;
      }
      /**
       * Gets whether or not the configuration conflict is an exact conflict.
       * An exact conflict occurs when the prediction algorithm determines that
       * the represented alternatives for a particular configuration set cannot be
       * further reduced by consuming additional input. After reaching an exact
       * conflict during an SLL prediction, only switch to full-context prediction
       * could reduce the set of viable alternatives. In LL prediction, an exact
       * conflict indicates a true ambiguity in the input.
       *
       * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,
       * accept states are conflicting but not exact are treated as non-accept
       * states.
       */
      get isExact() {
        return this.exact;
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _ConflictInfo)) {
          return false;
        }
        return this.isExact === obj.isExact && Utils.equals(this.conflictedAlts, obj.conflictedAlts);
      }
      hashCode() {
        return this.conflictedAlts.hashCode();
      }
    };
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], ConflictInfo.prototype, "hashCode", null);
    exports.ConflictInfo = ConflictInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/NoViableAltException.js"(exports) {
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoViableAltException = void 0;
    var Parser_1 = require_Parser();
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var NoViableAltException = class extends RecognitionException_1.RecognitionException {
      constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        if (recognizer instanceof Parser_1.Parser) {
          if (input === void 0) {
            input = recognizer.inputStream;
          }
          if (startToken === void 0) {
            startToken = recognizer.currentToken;
          }
          if (offendingToken === void 0) {
            offendingToken = recognizer.currentToken;
          }
          if (ctx === void 0) {
            ctx = recognizer.context;
          }
        }
        super(recognizer, input, ctx);
        this._deadEndConfigs = deadEndConfigs;
        this._startToken = startToken;
        this.setOffendingToken(recognizer, offendingToken);
      }
      get startToken() {
        return this._startToken;
      }
      get deadEndConfigs() {
        return this._deadEndConfigs;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], NoViableAltException.prototype, "_startToken", void 0);
    exports.NoViableAltException = NoViableAltException;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PredictionMode.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredictionMode = void 0;
    var Array2DHashMap_1 = require_Array2DHashMap();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var RuleStopState_1 = require_RuleStopState();
    var PredictionMode;
    (function(PredictionMode2) {
      PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
      PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
      PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
    (function(PredictionMode2) {
      class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
        constructor() {
          super(AltAndContextConfigEqualityComparator.INSTANCE);
        }
      }
      class AltAndContextConfigEqualityComparator {
        AltAndContextConfigEqualityComparator() {
        }
        /**
         * The hash code is only a function of the {@link ATNState#stateNumber}
         * and {@link ATNConfig#context}.
         */
        hashCode(o) {
          let hashCode = MurmurHash_1.MurmurHash.initialize(7);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
          return hashCode;
        }
        equals(a, b) {
          if (a === b) {
            return true;
          }
          if (a == null || b == null) {
            return false;
          }
          return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
        }
      }
      AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
      function hasConfigInRuleStopState(configs) {
        for (let c of configs) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
        return false;
      }
      PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
      function allConfigsInRuleStopStates(configs) {
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            return false;
          }
        }
        return true;
      }
      PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
    })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/SimulatorState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimulatorState = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var SimulatorState = class SimulatorState {
      constructor(outerContext, s0, useContext, remainingOuterContext) {
        this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
        this.s0 = s0;
        this.useContext = useContext;
        this.remainingOuterContext = remainingOuterContext;
      }
    };
    SimulatorState = __decorate([
      __param(1, Decorators_1.NotNull)
    ], SimulatorState);
    exports.SimulatorState = SimulatorState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ParserATNSimulator.js"(exports) {
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserATNSimulator = void 0;
    var AcceptStateInfo_1 = require_AcceptStateInfo();
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var Arrays_1 = require_Arrays();
    var ATN_1 = require_ATN();
    var ATNConfig_1 = require_ATNConfig();
    var ATNConfigSet_1 = require_ATNConfigSet();
    var ATNSimulator_1 = require_ATNSimulator();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BitSet_1 = require_BitSet();
    var ConflictInfo_1 = require_ConflictInfo();
    var DecisionState_1 = require_DecisionState();
    var DFAState_1 = require_DFAState();
    var IntegerList_1 = require_IntegerList();
    var Interval_1 = require_Interval();
    var IntStream_1 = require_IntStream();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var NoViableAltException_1 = require_NoViableAltException();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var PredictionContext_1 = require_PredictionContext();
    var PredictionContextCache_1 = require_PredictionContextCache();
    var PredictionMode_1 = require_PredictionMode();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SemanticContext_1 = require_SemanticContext();
    var SetTransition_1 = require_SetTransition();
    var SimulatorState_1 = require_SimulatorState();
    var Token_1 = require_Token();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var assert = require_assert();
    var MAX_SHORT_VALUE = 65535;
    var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
    var ParserATNSimulator = class ParserATNSimulator2 extends ATNSimulator_1.ATNSimulator {
      constructor(atn, parser) {
        super(atn);
        this.predictionMode = PredictionMode_1.PredictionMode.LL;
        this.force_global_context = false;
        this.always_try_local_context = true;
        this.enable_global_context_dfa = false;
        this.optimize_unique_closure = true;
        this.optimize_ll1 = true;
        this.optimize_tail_calls = true;
        this.tail_call_preserves_sll = true;
        this.treat_sllk1_conflict_as_ambiguity = false;
        this.reportAmbiguities = false;
        this.userWantsCtxSensitive = true;
        this._parser = parser;
      }
      getPredictionMode() {
        return this.predictionMode;
      }
      setPredictionMode(predictionMode) {
        this.predictionMode = predictionMode;
      }
      reset() {
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext === void 0) {
          useContext = false;
        }
        let dfa = this.atn.decisionToDFA[decision];
        assert(dfa != null);
        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
          let ll_1 = input.LA(1);
          if (ll_1 >= 0 && ll_1 <= 65535) {
            let key = (decision << 16 >>> 0) + ll_1;
            let alt = this.atn.LL1Table.get(key);
            if (alt != null) {
              return alt;
            }
          }
        }
        this.dfa = dfa;
        if (this.force_global_context) {
          useContext = true;
        } else if (!this.always_try_local_context) {
          useContext = useContext || dfa.isContextSensitive;
        }
        this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        let state;
        if (!dfa.isEmpty) {
          state = this.getStartState(dfa, input, outerContext, useContext);
        }
        if (state == null) {
          if (outerContext == null) {
            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
          }
          if (ParserATNSimulator2.debug) {
            console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
          }
          state = this.computeStartState(dfa, outerContext, useContext);
        }
        let m = input.mark();
        let index = input.index;
        try {
          let alt = this.execDFA(dfa, input, index, state);
          if (ParserATNSimulator2.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          return alt;
        } finally {
          this.dfa = void 0;
          input.seek(index);
          input.release(m);
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        if (!useContext) {
          if (dfa.isPrecedenceDfa) {
            let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
            if (state == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
          } else {
            if (dfa.s0 == null) {
              return void 0;
            }
            return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
          }
        }
        if (!this.enable_global_context_dfa) {
          return void 0;
        }
        let remainingContext = outerContext;
        assert(outerContext != null);
        let s0;
        if (dfa.isPrecedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
        } else {
          s0 = dfa.s0full;
        }
        while (remainingContext != null && s0 != null && s0.isContextSensitive) {
          remainingContext = this.skipTailCalls(remainingContext);
          s0 = s0.getContextTarget(this.getReturnState(remainingContext));
          if (remainingContext.isEmpty) {
            assert(s0 == null || !s0.isContextSensitive);
          } else {
            remainingContext = remainingContext.parent;
          }
        }
        if (s0 == null) {
          return void 0;
        }
        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
      }
      execDFA(dfa, input, startIndex, state) {
        let outerContext = state.outerContext;
        if (ParserATNSimulator2.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        if (ParserATNSimulator2.dfa_debug) {
          console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        let s = state.s0;
        let t = input.LA(1);
        let remainingOuterContext = state.remainingOuterContext;
        while (true) {
          if (ParserATNSimulator2.dfa_debug) {
            console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
          }
          if (state.useContext) {
            while (s.isContextSymbol(t)) {
              let next;
              if (remainingOuterContext != null) {
                remainingOuterContext = this.skipTailCalls(remainingOuterContext);
                next = s.getContextTarget(this.getReturnState(remainingOuterContext));
              }
              if (next == null) {
                let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
                return this.execATN(dfa, input, startIndex, initialState);
              }
              assert(remainingOuterContext != null);
              remainingOuterContext = remainingOuterContext.parent;
              s = next;
            }
          }
          if (this.isAcceptState(s, state.useContext)) {
            if (s.predicates != null) {
              if (ParserATNSimulator2.dfa_debug) {
                console.log("accept " + s);
              }
            } else {
              if (ParserATNSimulator2.dfa_debug) {
                console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
              }
            }
            break;
          }
          assert(!this.isAcceptState(s, state.useContext));
          let target = this.getExistingTargetState(s, t);
          if (target == null) {
            if (ParserATNSimulator2.dfa_debug && t >= 0) {
              console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
            }
            let alt;
            if (ParserATNSimulator2.dfa_debug) {
              let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
              console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
            }
            let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            alt = this.execATN(dfa, input, startIndex, initialState);
            if (ParserATNSimulator2.dfa_debug) {
              console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
            }
            if (ParserATNSimulator2.dfa_debug) {
              console.log("DFA decision " + dfa.decision + " predicts " + alt);
            }
            return alt;
          } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
            let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
            return this.handleNoViableAlt(input, startIndex, errorState);
          }
          s = target;
          if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
        if (!state.useContext && s.configs.conflictInfo != null) {
          if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
            if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
            } else {
              assert(!state.useContext);
              let conflictingAlts;
              let predicates2 = s.predicates;
              if (predicates2 != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
                if (conflictingAlts.cardinality() === 1) {
                  return conflictingAlts.nextSetBit(0);
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
              if (this.reportAmbiguities) {
                let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
                this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.adaptivePredict(input, dfa.decision, outerContext, true);
            }
          }
        }
        let predicates = s.predicates;
        if (predicates != null) {
          let stopIndex = input.index;
          if (startIndex !== stopIndex) {
            input.seek(startIndex);
          }
          let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
          switch (alts.cardinality()) {
            case 0:
              throw this.noViableAlt(input, outerContext, s.configs, startIndex);
            case 1:
              return alts.nextSetBit(0);
            default:
              if (startIndex !== stopIndex) {
                input.seek(stopIndex);
              }
              this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
              return alts.nextSetBit(0);
          }
        }
        if (ParserATNSimulator2.dfa_debug) {
          console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
        }
        return s.prediction;
      }
      /**
       * Determines if a particular DFA state should be treated as an accept state
       * for the current prediction mode. In addition to the `useContext`
       * parameter, the {@link #getPredictionMode()} method provides the
       * prediction mode controlling the prediction algorithm as a whole.
       *
       * The default implementation simply returns the value of
       * `DFAState.isAcceptState` except for conflict states when
       * `useContext` is `true` and {@link #getPredictionMode()} is
       * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only
       * conflict states where {@link ATNConfigSet#isExactConflict} is
       * `true` are considered accept states.
       *
       * @param state The DFA state to check.
       * @param useContext `true` if the prediction algorithm is currently
       * considering the full parser context; otherwise, `false` if the
       * algorithm is currently performing a local context prediction.
       *
       * @returns `true` if the specified `state` is an accept state;
       * otherwise, `false`.
       */
      isAcceptState(state, useContext) {
        if (!state.isAcceptState) {
          return false;
        }
        if (state.configs.conflictingAlts == null) {
          return true;
        }
        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          return state.configs.isExactConflict;
        }
        return true;
      }
      /** Performs ATN simulation to compute a predicted alternative based
       *  upon the remaining input, but also updates the DFA cache to avoid
       *  having to traverse the ATN again for the same input sequence.
       *
       * There are some key conditions we're looking for after computing a new
       * set of ATN configs (proposed DFA state):
       *
       * * if the set is empty, there is no viable alternative for current symbol
       * * does the state uniquely predict an alternative?
       * * does the state have a conflict that would prevent us from
       *   putting it on the work list?
       * * if in non-greedy decision is there a config at a rule stop state?
       *
       * We also have some key operations to do:
       *
       * * add an edge from previous DFA state to potentially new DFA state, D,
       *   upon current symbol but only if adding to work list, which means in all
       *   cases except no viable alternative (and possibly non-greedy decisions?)
       * * collecting predicates and adding semantic context to DFA accept states
       * * adding rule context to context-sensitive DFA accept states
       * * consuming an input symbol
       * * reporting a conflict
       * * reporting an ambiguity
       * * reporting a context sensitivity
       * * reporting insufficient predicates
       *
       * We should isolate those operations, which are side-effecting, to the
       * main work loop. We can isolate lots of code into other functions, but
       * they should be side effect free. They can return package that
       * indicates whether we should report something, whether we need to add a
       * DFA edge, whether we need to augment accept state with semantic
       * context or rule invocation context. Actually, it seems like we always
       * add predicates if they exist, so that can simply be done in the main
       * loop for any accept state creation or modification request.
       *
       * cover these cases:
       *   dead end
       *   single alt
       *   single alt + preds
       *   conflict
       *   conflict + preds
       *
       * TODO: greedy + those
       */
      execATN(dfa, input, startIndex, initialState) {
        if (ParserATNSimulator2.debug) {
          console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
        }
        let outerContext = initialState.outerContext;
        let useContext = initialState.useContext;
        let t = input.LA(1);
        let previous = initialState;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        while (true) {
          let nextState = this.computeReachSet(dfa, previous, t, contextCache);
          if (nextState == null) {
            this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
            return this.handleNoViableAlt(input, startIndex, previous);
          }
          let D = nextState.s0;
          assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
          assert(D.isAcceptState || D.configs.conflictInfo == null);
          if (this.isAcceptState(D, useContext)) {
            let conflictingAlts = D.configs.conflictingAlts;
            let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
            if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
              if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
                if (t >= 0 && t <= MAX_SHORT_VALUE) {
                  let key = (dfa.decision << 16 >>> 0) + t;
                  this.atn.LL1Table.set(key, predictedAlt);
                }
              }
              if (useContext && this.always_try_local_context) {
                this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
              }
            }
            predictedAlt = D.prediction;
            let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
            if (attemptFullContext) {
              attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
            }
            if (D.configs.hasSemanticContext) {
              let predPredictions = D.predicates;
              if (predPredictions != null) {
                let conflictIndex = input.index;
                if (conflictIndex !== startIndex) {
                  input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
                switch (conflictingAlts.cardinality()) {
                  case 0:
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                  case 1:
                    return conflictingAlts.nextSetBit(0);
                  default:
                    break;
                }
                if (conflictIndex !== startIndex) {
                  input.seek(conflictIndex);
                }
              }
            }
            if (!attemptFullContext) {
              if (conflictingAlts != null) {
                if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                  this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
                }
                predictedAlt = conflictingAlts.nextSetBit(0);
              }
              return predictedAlt;
            } else {
              assert(!useContext);
              assert(this.isAcceptState(D, false));
              if (ParserATNSimulator2.debug) {
                console.log("RETRY with outerContext=" + outerContext);
              }
              let fullContextState = this.computeStartState(dfa, outerContext, true);
              if (this.reportAmbiguities) {
                this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
              }
              input.seek(startIndex);
              return this.execATN(dfa, input, startIndex, fullContextState);
            }
          }
          previous = nextState;
          if (t !== IntStream_1.IntStream.EOF) {
            input.consume();
            t = input.LA(1);
          }
        }
      }
      /**
       * This method is used to improve the localization of error messages by
       * choosing an alternative rather than throwing a
       * {@link NoViableAltException} in particular prediction scenarios where the
       * {@link #ERROR} state was reached during ATN simulation.
       *
       * The default implementation of this method uses the following
       * algorithm to identify an ATN configuration which successfully parsed the
       * decision entry rule. Choosing such an alternative ensures that the
       * {@link ParserRuleContext} returned by the calling rule will be complete
       * and valid, and the syntax error will be reported later at a more
       * localized location.
       *
       * * If no configuration in `configs` reached the end of the
       *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.
       * * If all configurations in `configs` which reached the end of the
       *   decision rule predict the same alternative, return that alternative.
       * * If the configurations in `configs` which reached the end of the
       *   decision rule predict multiple alternatives (call this *S*),
       *   choose an alternative in the following order.
       *
       *     1. Filter the configurations in `configs` to only those
       *        configurations which remain viable after evaluating semantic predicates.
       *        If the set of these filtered configurations which also reached the end of
       *        the decision rule is not empty, return the minimum alternative
       *        represented in this set.
       *     1. Otherwise, choose the minimum alternative in *S*.
       *
       * In some scenarios, the algorithm described above could predict an
       * alternative which will result in a {@link FailedPredicateException} in
       * parser. Specifically, this could occur if the *only* configuration
       * capable of successfully parsing to the end of the decision rule is
       * blocked by a semantic predicate. By choosing this alternative within
       * {@link #adaptivePredict} instead of throwing a
       * {@link NoViableAltException}, the resulting
       * {@link FailedPredicateException} in the parser will identify the specific
       * predicate which is preventing the parser from successfully parsing the
       * decision rule, which helps developers identify and correct logic errors
       * in semantic predicates.
       *
       * @param input The input {@link TokenStream}
       * @param startIndex The start index for the current prediction, which is
       * the input index where any semantic context in `configs` should be
       * evaluated
       * @param previous The ATN simulation state immediately before the
       * {@link #ERROR} state was reached
       *
       * @returns The value to return from {@link #adaptivePredict}, or
       * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
       * identified and {@link #adaptivePredict} should report an error instead.
       */
      handleNoViableAlt(input, startIndex, previous) {
        if (previous.s0 != null) {
          let alts = new BitSet_1.BitSet();
          let maxAlt = 0;
          for (let config of previous.s0.configs) {
            if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
              alts.set(config.alt);
              maxAlt = Math.max(maxAlt, config.alt);
            }
          }
          switch (alts.cardinality()) {
            case 0:
              break;
            case 1:
              return alts.nextSetBit(0);
            default:
              if (!previous.s0.configs.hasSemanticContext) {
                return alts.nextSetBit(0);
              }
              let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
              for (let config of previous.s0.configs) {
                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                  filteredConfigs.add(config);
                }
              }
              let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
              if (altToPred != null) {
                let predicates = this.getPredicatePredictions(alts, altToPred);
                if (predicates != null) {
                  let stopIndex = input.index;
                  try {
                    input.seek(startIndex);
                    let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                    if (!filteredAlts.isEmpty) {
                      return filteredAlts.nextSetBit(0);
                    }
                  } finally {
                    input.seek(stopIndex);
                  }
                }
              }
              return alts.nextSetBit(0);
          }
        }
        throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
      }
      computeReachSet(dfa, previous, t, contextCache) {
        let useContext = previous.useContext;
        let remainingGlobalContext = previous.remainingOuterContext;
        let s = previous.s0;
        if (useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingGlobalContext != null) {
              remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
              next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
            }
            if (next == null) {
              break;
            }
            assert(remainingGlobalContext != null);
            remainingGlobalContext = remainingGlobalContext.parent;
            s = next;
          }
        }
        assert(!this.isAcceptState(s, useContext));
        if (this.isAcceptState(s, useContext)) {
          return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
        }
        let s0 = s;
        let target = this.getExistingTargetState(s0, t);
        if (target == null) {
          let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
          target = result[0];
          remainingGlobalContext = result[1];
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          return void 0;
        }
        assert(!useContext || !target.configs.dipsIntoOuterContext);
        return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
      }
      /**
       * Get an existing target state for an edge in the DFA. If the target state
       * for the edge has not yet been computed or is otherwise not available,
       * this method returns `undefined`.
       *
       * @param s The current DFA state
       * @param t The next input symbol
       * @returns The existing target DFA state for the given input symbol
       * `t`, or `undefined` if the target state for this edge is not
       * already cached
       */
      getExistingTargetState(s, t) {
        return s.getTarget(t);
      }
      /**
       * Compute a target state for an edge in the DFA, and attempt to add the
       * computed state and corresponding edge to the DFA.
       *
       * @param dfa
       * @param s The current DFA state
       * @param remainingGlobalContext
       * @param t The next input symbol
       * @param useContext
       * @param contextCache
       *
       * @returns The computed target DFA state for the given input symbol
       * `t`. If `t` does not lead to a valid DFA state, this method
       * returns {@link #ERROR}.
       */
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let closureConfigs = s.configs.toArray();
        let contextElements;
        let reach = new ATNConfigSet_1.ATNConfigSet();
        let stepIntoGlobal;
        do {
          let hasMoreContext = !useContext || remainingGlobalContext != null;
          if (!hasMoreContext) {
            reach.isOutermostConfigSet = true;
          }
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let skippedStopStates;
          for (let c of closureConfigs) {
            if (ParserATNSimulator2.debug) {
              console.log("testing " + this.getTokenName(t) + " at " + c.toString());
            }
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              assert(c.context.isEmpty);
              if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
                if (skippedStopStates == null) {
                  skippedStopStates = [];
                }
                skippedStopStates.push(c);
              }
              continue;
            }
            let n = c.state.numberOfOptimizedTransitions;
            for (let ti = 0; ti < n; ti++) {
              let trans = c.state.getOptimizedTransition(ti);
              let target = this.getReachableTarget(c, trans, t);
              if (target != null) {
                reachIntermediate.add(c.transform(target, false), contextCache);
              }
            }
          }
          if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
            reach = reachIntermediate;
            break;
          }
          let collectPredicates = false;
          let treatEofAsEpsilon = t === Token_1.Token.EOF;
          this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
          stepIntoGlobal = reach.dipsIntoOuterContext;
          if (t === IntStream_1.IntStream.EOF) {
            reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
          }
          if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
            assert(skippedStopStates.length > 0);
            for (let c of skippedStopStates) {
              reach.add(c, contextCache);
            }
          }
          if (useContext && stepIntoGlobal) {
            reach.clear();
            remainingGlobalContext = remainingGlobalContext;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            let nextContextElement = this.getReturnState(remainingGlobalContext);
            if (contextElements == null) {
              contextElements = new IntegerList_1.IntegerList();
            }
            if (remainingGlobalContext.isEmpty) {
              remainingGlobalContext = void 0;
            } else {
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            contextElements.add(nextContextElement);
            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              for (let i = 0; i < closureConfigs.length; i++) {
                closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
              }
            }
          }
        } while (useContext && stepIntoGlobal);
        if (reach.isEmpty) {
          this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
          return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
        }
        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
        return [result, remainingGlobalContext];
      }
      /**
       * Return a configuration set containing only the configurations from
       * `configs` which are in a {@link RuleStopState}. If all
       * configurations in `configs` are already in a rule stop state, this
       * method simply returns `configs`.
       *
       * @param configs the configuration set to update
       * @param contextCache the {@link PredictionContext} cache
       *
       * @returns `configs` if all configurations in `configs` are in a
       * rule stop state, otherwise return a new configuration set containing only
       * the configurations from `configs` which are in a rule stop state
       */
      removeAllConfigsNotInRuleStopState(configs, contextCache) {
        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
          return configs;
        }
        let result = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          result.add(config, contextCache);
        }
        return result;
      }
      computeStartState(dfa, globalContext, useContext) {
        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
        if (s0 != null) {
          if (!useContext) {
            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
          }
          s0.setContextSensitive(this.atn);
        }
        let decision = dfa.decision;
        let p = dfa.atnStartState;
        let previousContext = 0;
        let remainingGlobalContext = globalContext;
        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
        let contextCache = new PredictionContextCache_1.PredictionContextCache();
        if (useContext) {
          if (!this.enable_global_context_dfa) {
            while (remainingGlobalContext != null) {
              if (remainingGlobalContext.isEmpty) {
                previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
                remainingGlobalContext = void 0;
              } else {
                previousContext = this.getReturnState(remainingGlobalContext);
                initialContext = initialContext.appendSingleContext(previousContext, contextCache);
                remainingGlobalContext = remainingGlobalContext.parent;
              }
            }
          }
          while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
            let next;
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            if (remainingGlobalContext.isEmpty) {
              next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              next = s0.getContextTarget(previousContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
            if (next == null) {
              break;
            }
            s0 = next;
          }
        }
        if (s0 != null && !s0.isContextSensitive) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
        }
        let configs = new ATNConfigSet_1.ATNConfigSet();
        while (true) {
          let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
          let n = p.numberOfTransitions;
          for (let ti = 0; ti < n; ti++) {
            let target = p.transition(ti).target;
            reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
          }
          let hasMoreContext = remainingGlobalContext != null;
          if (!hasMoreContext) {
            configs.isOutermostConfigSet = true;
          }
          let collectPredicates = true;
          this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
          let stepIntoGlobal = configs.dipsIntoOuterContext;
          let next;
          if (useContext && !this.enable_global_context_dfa) {
            s0 = this.addDFAState(dfa, configs, contextCache);
            break;
          } else if (s0 == null) {
            if (!dfa.isPrecedenceDfa) {
              next = this.addDFAState(dfa, configs, contextCache);
              if (useContext) {
                if (!dfa.s0full) {
                  dfa.s0full = next;
                } else {
                  next = dfa.s0full;
                }
              } else {
                if (!dfa.s0) {
                  dfa.s0 = next;
                } else {
                  next = dfa.s0;
                }
              }
            } else {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
              next = this.addDFAState(dfa, configs, contextCache);
              dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
            }
          } else {
            if (dfa.isPrecedenceDfa) {
              configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            }
            next = this.addDFAState(dfa, configs, contextCache);
            s0.setContextTarget(previousContext, next);
          }
          s0 = next;
          if (!useContext || !stepIntoGlobal) {
            break;
          }
          next.setContextSensitive(this.atn);
          remainingGlobalContext = remainingGlobalContext;
          configs.clear();
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
          }
          previousContext = nextContextElement;
        }
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      /**
       * This method transforms the start state computed by
       * {@link #computeStartState} to the special start state used by a
       * precedence DFA for a particular precedence value. The transformation
       * process applies the following changes to the start state's configuration
       * set.
       *
       * 1. Evaluate the precedence predicates for each configuration using
       *    {@link SemanticContext#evalPrecedence}.
       * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,
       *    remove all configurations which predict an alternative greater than 1,
       *    for which another configuration that predicts alternative 1 is in the
       *    same ATN state with the same prediction context. This transformation is
       *    valid for the following reasons:
       *
       *     * The closure block cannot contain any epsilon transitions which bypass
       *       the body of the closure, so all states reachable via alternative 1 are
       *       part of the precedence alternatives of the transformed left-recursive
       *       rule.
       *     * The "primary" portion of a left recursive rule cannot contain an
       *       epsilon transition, so the only way an alternative other than 1 can exist
       *       in a state that is also reachable via alternative 1 is by nesting calls
       *       to the left-recursive rule, with the outer calls not being at the
       *       preferred precedence level. The
       *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
       *       configurations which do not meet this condition, and therefore are not
       *       eligible for elimination during the filtering process.
       *
       * The prediction context must be considered by this filter to address
       * situations like the following.
       *
       * ```antlr
       * grammar TA;
       * prog: statement* EOF;
       * statement: letterA | statement letterA 'b' ;
       * letterA: 'a';
       * ```
       *
       * If the above grammar, the ATN state immediately before the token
       * reference `'a'` in `letterA` is reachable from the left edge
       * of both the primary and closure blocks of the left-recursive rule
       * `statement`. The prediction context associated with each of these
       * configurations distinguishes between them, and prevents the alternative
       * which stepped out to `prog` (and then back in to `statement`
       * from being eliminated by the filter.
       *
       * @param configs The configuration set computed by
       * {@link #computeStartState} as the start state for the DFA.
       * @returns The transformed configuration set representing the start state
       * for a precedence DFA at a particular precedence level (determined by
       * calling {@link Parser#getPrecedence}).
       */
      applyPrecedenceFilter(configs, globalContext, contextCache) {
        let statesFromAlt1 = /* @__PURE__ */ new Map();
        let configSet = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          if (config.alt !== 1) {
            continue;
          }
          let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
          if (updatedContext == null) {
            continue;
          }
          statesFromAlt1.set(config.state.stateNumber, config.context);
          if (updatedContext !== config.semanticContext) {
            configSet.add(config.transform(config.state, false, updatedContext), contextCache);
          } else {
            configSet.add(config, contextCache);
          }
        }
        for (let config of configs) {
          if (config.alt === 1) {
            continue;
          }
          if (!config.isPrecedenceFilterSuppressed) {
            let context = statesFromAlt1.get(config.state.stateNumber);
            if (context != null && context.equals(config.context)) {
              continue;
            }
          }
          configSet.add(config, contextCache);
        }
        return configSet;
      }
      getReachableTarget(source, trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
          return trans.target;
        }
        return void 0;
      }
      /** collect and set D's semantic context */
      predicateDFAState(D, configs, nalts) {
        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
        if (!conflictingAlts) {
          throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
        }
        if (ParserATNSimulator2.debug) {
          console.log("predicateDFAState " + D);
        }
        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
        let predPredictions;
        if (altToPred != null) {
          predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
          D.predicates = predPredictions;
        }
        return predPredictions;
      }
      getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        let altToPred = new Array(nalts + 1);
        let n = altToPred.length;
        for (let c of configs) {
          if (ambigAlts.get(c.alt)) {
            altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
          }
        }
        let nPredAlts = 0;
        for (let i = 0; i < n; i++) {
          if (altToPred[i] == null) {
            altToPred[i] = SemanticContext_1.SemanticContext.NONE;
          } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
            nPredAlts++;
          }
        }
        let result = altToPred;
        if (nPredAlts === 0) {
          result = void 0;
        }
        if (ParserATNSimulator2.debug) {
          console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
        }
        return result;
      }
      getPredicatePredictions(ambigAlts, altToPred) {
        let pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
          let pred = altToPred[i];
          assert(pred != null);
          if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
            containsPredicate = true;
            pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
          }
        }
        if (!containsPredicate) {
          return void 0;
        }
        return pairs;
      }
      /** Look through a list of predicate/alt pairs, returning alts for the
       *  pairs that win. An `undefined` predicate indicates an alt containing an
       *  unpredicated config which behaves as "always true."
       */
      evalSemanticContext(predPredictions, outerContext, complete) {
        let predictions = new BitSet_1.BitSet();
        for (let pair of predPredictions) {
          if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
            continue;
          }
          let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
          if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
            console.log("eval pred " + pair + "=" + evaluatedResult);
          }
          if (evaluatedResult) {
            if (ParserATNSimulator2.debug || ParserATNSimulator2.dfa_debug) {
              console.log("PREDICT " + pair.alt);
            }
            predictions.set(pair.alt);
            if (!complete) {
              break;
            }
          }
        }
        return predictions;
      }
      /**
       * Evaluate a semantic context within a specific parser context.
       *
       * This method might not be called for every semantic context evaluated
       * during the prediction process. In particular, we currently do not
       * evaluate the following but it may change in the future:
       *
       * * Precedence predicates (represented by
       *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
       *   through this method.
       * * Operator predicates (represented by {@link SemanticContext.AND} and
       *   {@link SemanticContext.OR}) are evaluated as a single semantic
       *   context, rather than evaluating the operands individually.
       *   Implementations which require evaluation results from individual
       *   predicates should override this method to explicitly handle evaluation of
       *   the operands within operator predicates.
       *
       * @param pred The semantic context to evaluate
       * @param parserCallStack The parser context in which to evaluate the
       * semantic context
       * @param alt The alternative which is guarded by `pred`
       *
       * @since 4.3
       */
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        return pred.eval(this._parser, parserCallStack);
      }
      /* TODO: If we are doing predicates, there is no point in pursuing
           closure operations if we reach a DFA state that uniquely predicts
           alternative. We will not be caching that DFA state and it is a
           waste to pursue the closure. Might have to advance when we do
           ambig detection thought :(
            */
      closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
        if (contextCache == null) {
          contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
        }
        let currentConfigs = sourceConfigs;
        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        while (currentConfigs.size > 0) {
          let intermediate = new ATNConfigSet_1.ATNConfigSet();
          for (let config of currentConfigs) {
            this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
          }
          currentConfigs = intermediate;
        }
      }
      closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
        if (ParserATNSimulator2.debug) {
          console.log("closure(" + config.toString(this._parser, true) + ")");
        }
        if (config.state instanceof RuleStopState_1.RuleStopState) {
          if (!config.context.isEmpty) {
            let hasEmpty = config.context.hasEmpty;
            let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
            for (let i = 0; i < nonEmptySize; i++) {
              let newContext = config.context.getParent(i);
              let returnState = this.atn.states[config.context.getReturnState(i)];
              let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
              c.outerContextDepth = config.outerContextDepth;
              c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
              assert(depth > MIN_INTEGER_VALUE);
              this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
            }
            if (!hasEmpty || !hasMoreContexts) {
              return;
            }
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!hasMoreContexts) {
            configs.add(config, contextCache);
            return;
          } else {
            if (ParserATNSimulator2.debug) {
              console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
            if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
              config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
            } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
              configs.add(config, contextCache);
            }
          }
        }
        let p = config.state;
        if (!p.onlyHasEpsilonTransitions) {
          configs.add(config, contextCache);
          if (ParserATNSimulator2.debug) {
            console.log("added config " + configs);
          }
        }
        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
          if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
            let precedenceDecision = p;
            let suppress = true;
            for (let j = 0; j < config.context.size; j++) {
              if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
                suppress = false;
                break;
              }
            }
            if (suppress) {
              continue;
            }
          }
          let t = p.getOptimizedTransition(i);
          let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
          let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
          if (c != null) {
            if (t instanceof RuleTransition_1.RuleTransition) {
              if (intermediate != null && !collectPredicates) {
                intermediate.add(c, contextCache);
                continue;
              }
            }
            let newDepth = depth;
            if (config.state instanceof RuleStopState_1.RuleStopState) {
              if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
                if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                  c.isPrecedenceFilterSuppressed = true;
                }
              }
              c.outerContextDepth = c.outerContextDepth + 1;
              if (!closureBusy.add(c)) {
                continue;
              }
              assert(newDepth > MIN_INTEGER_VALUE);
              newDepth--;
              if (ParserATNSimulator2.debug) {
                console.log("dips into outer ctx: " + c);
              }
            } else if (t instanceof RuleTransition_1.RuleTransition) {
              if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
                assert(c.context === config.context);
                if (newDepth === 0) {
                  newDepth--;
                  if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                    c.outerContextDepth = c.outerContextDepth + 1;
                  }
                }
              } else {
                if (newDepth >= 0) {
                  newDepth++;
                }
              }
            } else {
              if (!t.isEpsilon && !closureBusy.add(c)) {
                continue;
              }
            }
            this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
          }
        }
      }
      getRuleName(index) {
        if (this._parser != null && index >= 0) {
          return this._parser.ruleNames[index];
        }
        return "<rule " + index + ">";
      }
      getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
        switch (t.serializationType) {
          case 3:
            return this.ruleTransition(config, t, contextCache);
          case 10:
            return this.precedenceTransition(config, t, collectPredicates, inContext);
          case 4:
            return this.predTransition(config, t, collectPredicates, inContext);
          case 6:
            return this.actionTransition(config, t);
          case 1:
            return config.transform(t.target, false);
          case 5:
          case 2:
          case 7:
            if (treatEofAsEpsilon) {
              if (t.matches(Token_1.Token.EOF, 0, 1)) {
                return config.transform(t.target, false);
              }
            }
            return void 0;
          default:
            return void 0;
        }
      }
      actionTransition(config, t) {
        if (ParserATNSimulator2.debug) {
          console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
        }
        return config.transform(t.target, false);
      }
      precedenceTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator2.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && inContext) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator2.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      predTransition(config, pt, collectPredicates, inContext) {
        if (ParserATNSimulator2.debug) {
          console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
          if (this._parser != null) {
            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
          }
        }
        let c;
        if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
          let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
          c = config.transform(pt.target, false, newSemCtx);
        } else {
          c = config.transform(pt.target, false);
        }
        if (ParserATNSimulator2.debug) {
          console.log("config from pred transition=" + c);
        }
        return c;
      }
      ruleTransition(config, t, contextCache) {
        if (ParserATNSimulator2.debug) {
          console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        let returnState = t.followState;
        let newContext;
        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
          newContext = config.context;
        } else if (contextCache != null) {
          newContext = contextCache.getChild(config.context, returnState.stateNumber);
        } else {
          newContext = config.context.getChild(returnState.stateNumber);
        }
        return config.transform(t.target, false, newContext);
      }
      isConflicted(configset, contextCache) {
        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
          return void 0;
        }
        let configs = configset.toArray();
        configs.sort(ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR);
        let exact = !configset.dipsIntoOuterContext;
        let alts = new BitSet_1.BitSet();
        let minAlt = configs[0].alt;
        alts.set(minAlt);
        let currentState = configs[0].state.nonStopStateNumber;
        for (let config of configs) {
          let stateNumber = config.state.nonStopStateNumber;
          if (stateNumber !== currentState) {
            if (config.alt !== minAlt) {
              return void 0;
            }
            currentState = stateNumber;
          }
        }
        let representedAlts;
        if (exact) {
          currentState = configs[0].state.nonStopStateNumber;
          representedAlts = new BitSet_1.BitSet();
          let maxAlt = minAlt;
          for (let config of configs) {
            if (config.state.nonStopStateNumber !== currentState) {
              break;
            }
            let alt = config.alt;
            representedAlts.set(alt);
            maxAlt = alt;
          }
          currentState = configs[0].state.nonStopStateNumber;
          let currentAlt = minAlt;
          for (let config of configs) {
            let stateNumber = config.state.nonStopStateNumber;
            let alt = config.alt;
            if (stateNumber !== currentState) {
              if (currentAlt !== maxAlt) {
                exact = false;
                break;
              }
              currentState = stateNumber;
              currentAlt = minAlt;
            } else if (alt !== currentAlt) {
              if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
                exact = false;
                break;
              }
              currentAlt = alt;
            }
          }
        }
        currentState = configs[0].state.nonStopStateNumber;
        let firstIndexCurrentState = 0;
        let lastIndexCurrentStateMinAlt = 0;
        let joinedCheckContext = configs[0].context;
        for (let i = 1; i < configs.length; i++) {
          let config = configs[i];
          if (config.alt !== minAlt) {
            break;
          }
          if (config.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateMinAlt = i;
          joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
        }
        for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
          let config = configs[i];
          let state = config.state;
          alts.set(config.alt);
          if (state.nonStopStateNumber !== currentState) {
            currentState = state.nonStopStateNumber;
            firstIndexCurrentState = i;
            lastIndexCurrentStateMinAlt = i;
            joinedCheckContext = config.context;
            for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
              let config2 = configs[j];
              if (config2.alt !== minAlt) {
                break;
              }
              if (config2.state.nonStopStateNumber !== currentState) {
                break;
              }
              lastIndexCurrentStateMinAlt = j;
              joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
            }
            i = lastIndexCurrentStateMinAlt;
            continue;
          }
          let joinedCheckContext2 = config.context;
          let currentAlt = config.alt;
          let lastIndexCurrentStateCurrentAlt = i;
          for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
            let config2 = configs[j];
            if (config2.alt !== currentAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateCurrentAlt = j;
            joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
          }
          i = lastIndexCurrentStateCurrentAlt;
          let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
          if (!joinedCheckContext.equals(check)) {
            return void 0;
          }
          exact = exact && joinedCheckContext.equals(joinedCheckContext2);
        }
        return new ConflictInfo_1.ConflictInfo(alts, exact);
      }
      getConflictingAltsFromConfigSet(configs) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          conflictingAlts = new BitSet_1.BitSet();
          conflictingAlts.set(configs.uniqueAlt);
        }
        return conflictingAlts;
      }
      getTokenName(t) {
        if (t === Token_1.Token.EOF) {
          return "EOF";
        }
        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
        let displayName = vocabulary.getDisplayName(t);
        if (displayName === String(t)) {
          return displayName;
        }
        return displayName + "<" + t + ">";
      }
      getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
      }
      dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        let deadEndConfigs = nvae.deadEndConfigs;
        if (!deadEndConfigs) {
          return;
        }
        for (let c of deadEndConfigs) {
          let trans = "no edges";
          if (c.state.numberOfOptimizedTransitions > 0) {
            let t = c.state.getOptimizedTransition(0);
            if (t instanceof AtomTransition_1.AtomTransition) {
              trans = "Atom " + this.getTokenName(t._label);
            } else if (t instanceof SetTransition_1.SetTransition) {
              let not = t instanceof NotSetTransition_1.NotSetTransition;
              trans = (not ? "~" : "") + "Set " + t.set.toString();
            }
          }
          console.log(c.toString(this._parser, true) + ":" + trans);
        }
      }
      noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
      }
      getUniqueAlt(configs) {
        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
        for (let c of configs) {
          if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
            alt = c.alt;
          } else if (c.alt !== alt) {
            return ATN_1.ATN.INVALID_ALT_NUMBER;
          }
        }
        return alt;
      }
      configWithAltAtStopState(configs, alt) {
        for (let c of configs) {
          if (c.alt === alt) {
            if (c.state instanceof RuleStopState_1.RuleStopState) {
              return true;
            }
          }
        }
        return false;
      }
      addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
        let from = fromState;
        let to = this.addDFAState(dfa, toConfigs, contextCache);
        if (contextTransitions != null) {
          for (let context of contextTransitions.toArray()) {
            if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (from.configs.isOutermostConfigSet) {
                continue;
              }
            }
            from.setContextSensitive(this.atn);
            from.setContextSymbol(t);
            let next = from.getContextTarget(context);
            if (next != null) {
              from = next;
              continue;
            }
            next = this.addDFAContextState(dfa, from.configs, context, contextCache);
            assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
            from.setContextTarget(context, next);
            from = next;
          }
        }
        if (ParserATNSimulator2.debug) {
          console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
        }
        this.setDFAEdge(from, t, to);
        if (ParserATNSimulator2.debug) {
          console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
        }
        return to;
      }
      setDFAEdge(p, t, q) {
        if (p != null) {
          p.setTarget(t, q);
        }
      }
      /** See comment on LexerInterpreter.addDFAState. */
      addDFAContextState(dfa, configs, returnContext, contextCache) {
        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
          for (let config of configs) {
            contextConfigs.add(config.appendContext(returnContext, contextCache));
          }
          return this.addDFAState(dfa, contextConfigs, contextCache);
        } else {
          assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
          configs = configs.clone(true);
          configs.isOutermostConfigSet = true;
          return this.addDFAState(dfa, configs, contextCache);
        }
      }
      /** See comment on LexerInterpreter.addDFAState. */
      addDFAState(dfa, configs, contextCache) {
        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
        if (enableDfa) {
          if (!configs.isReadOnly) {
            configs.optimizeConfigs(this);
          }
          let proposed = this.createDFAState(dfa, configs);
          let existing = dfa.states.get(proposed);
          if (existing != null) {
            return existing;
          }
        }
        if (!configs.isReadOnly) {
          if (configs.conflictInfo == null) {
            configs.conflictInfo = this.isConflicted(configs, contextCache);
          }
        }
        let newState = this.createDFAState(dfa, configs.clone(true));
        let decisionState = this.atn.getDecisionState(dfa.decision);
        let predictedAlt = this.getUniqueAlt(configs);
        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
        } else if (configs.conflictingAlts != null) {
          let conflictingAlts = configs.conflictingAlts;
          if (conflictingAlts) {
            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
          }
        }
        if (newState.isAcceptState && configs.hasSemanticContext) {
          this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
        }
        if (!enableDfa) {
          return newState;
        }
        let added = dfa.addState(newState);
        if (ParserATNSimulator2.debug && added === newState) {
          console.log("adding new DFA state: " + newState);
        }
        return added;
      }
      createDFAState(dfa, configs) {
        return new DFAState_1.DFAState(configs);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        }
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        }
      }
      /** If context sensitive parsing, we know it's ambiguity not conflict */
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (ParserATNSimulator2.debug || ParserATNSimulator2.retry_debug) {
          let interval = Interval_1.Interval.of(startIndex, stopIndex);
          console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
        }
        if (this._parser != null) {
          let listener = this._parser.getErrorListenerDispatch();
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        }
      }
      getReturnState(context) {
        if (context.isEmpty) {
          return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
        }
        let state = this.atn.states[context.invokingState];
        let transition = state.transition(0);
        return transition.followState.stateNumber;
      }
      skipTailCalls(context) {
        if (!this.optimize_tail_calls) {
          return context;
        }
        while (!context.isEmpty) {
          let state = this.atn.states[context.invokingState];
          assert(
            state.numberOfTransitions === 1 && state.transition(0).serializationType === 3
            /* RULE */
          );
          let transition = state.transition(0);
          if (!transition.tailCall) {
            break;
          }
          context = context.parent;
        }
        return context;
      }
      /**
       * @since 4.3
       */
      get parser() {
        return this._parser;
      }
    };
    ParserATNSimulator.debug = false;
    ParserATNSimulator.dfa_debug = false;
    ParserATNSimulator.retry_debug = false;
    ParserATNSimulator.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
      let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
      if (diff !== 0) {
        return diff;
      }
      diff = o1.alt - o2.alt;
      if (diff !== 0) {
        return diff;
      }
      return 0;
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "predictionMode", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getPredictionMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "setPredictionMode", null);
    __decorate([
      Decorators_1.Override
    ], ParserATNSimulator.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getStartState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "execDFA", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "execATN", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "handleNoViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "removeAllConfigsNotInRuleStopState", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "applyPrecedenceFilter", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getReachableTarget", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getPredsForAmbigAlts", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "evalSemanticContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "closure", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable),
      __param(3, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "closureImpl", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getRuleName", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getEpsilonTarget", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "actionTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "precedenceTransition", null);
    __decorate([
      Decorators_1.Nullable,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "predTransition", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "ruleTransition", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "isConflicted", null);
    __decorate([
      Decorators_1.NotNull
    ], ParserATNSimulator.prototype, "getTokenName", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "dumpDeadEndConfigs", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "noViableAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "getUniqueAlt", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "configWithAltAtStopState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(4, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAEdge", null);
    __decorate([
      __param(0, Decorators_1.Nullable),
      __param(2, Decorators_1.Nullable)
    ], ParserATNSimulator.prototype, "setDFAEdge", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAContextState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "addDFAState", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "createDFAState", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ParserATNSimulator.prototype, "reportAmbiguity", null);
    ParserATNSimulator = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParserATNSimulator);
    exports.ParserATNSimulator = ParserATNSimulator;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PlusBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusBlockStartState.prototype, "stateType", null);
    exports.PlusBlockStartState = PlusBlockStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PlusLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PlusLoopbackState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var PlusLoopbackState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], PlusLoopbackState.prototype, "stateType", null);
    exports.PlusLoopbackState = PlusLoopbackState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PrecedencePredicateTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrecedencePredicateTransition = void 0;
    var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
    var Decorators_1 = require_Decorators();
    var SemanticContext_1 = require_SemanticContext();
    var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
      constructor(target, precedence) {
        super(target);
        this.precedence = precedence;
      }
      get serializationType() {
        return 10;
      }
      get isEpsilon() {
        return true;
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
      }
      get predicate() {
        return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    };
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicateTransition.prototype, "toString", null);
    PrecedencePredicateTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PrecedencePredicateTransition);
    exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/RangeTransition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeTransition = void 0;
    var IntervalSet_1 = require_IntervalSet();
    var Decorators_1 = require_Decorators();
    var Transition_1 = require_Transition();
    var RangeTransition = class RangeTransition extends Transition_1.Transition {
      constructor(target, from, to) {
        super(target);
        this.from = from;
        this.to = to;
      }
      get serializationType() {
        return 2;
      }
      get label() {
        return IntervalSet_1.IntervalSet.of(this.from, this.to);
      }
      matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.from && symbol <= this.to;
      }
      toString() {
        return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
      }
    };
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "serializationType", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "label", null);
    __decorate([
      Decorators_1.Override
    ], RangeTransition.prototype, "matches", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull
    ], RangeTransition.prototype, "toString", null);
    RangeTransition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RangeTransition);
    exports.RangeTransition = RangeTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/RuleStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleStartState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var RuleStartState = class extends ATNState_1.ATNState {
      constructor() {
        super(...arguments);
        this.isPrecedenceRule = false;
        this.leftFactored = false;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.RULE_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleStartState.prototype, "stateType", null);
    exports.RuleStartState = RuleStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/StarBlockStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarBlockStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var BlockStartState_1 = require_BlockStartState();
    var Decorators_1 = require_Decorators();
    var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarBlockStartState.prototype, "stateType", null);
    exports.StarBlockStartState = StarBlockStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/StarLoopbackState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StarLoopbackState = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var Decorators_1 = require_Decorators();
    var StarLoopbackState = class extends ATNState_1.ATNState {
      get loopEntryState() {
        return this.transition(0).target;
      }
      get stateType() {
        return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
      }
    };
    __decorate([
      Decorators_1.Override
    ], StarLoopbackState.prototype, "stateType", null);
    exports.StarLoopbackState = StarLoopbackState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/TokensStartState.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokensStartState = void 0;
    var ATNStateType_1 = require_ATNStateType();
    var DecisionState_1 = require_DecisionState();
    var Decorators_1 = require_Decorators();
    var TokensStartState = class extends DecisionState_1.DecisionState {
      get stateType() {
        return ATNStateType_1.ATNStateType.TOKEN_START;
      }
    };
    __decorate([
      Decorators_1.Override
    ], TokensStartState.prototype, "stateType", null);
    exports.TokensStartState = TokensStartState;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UUID = void 0;
    var MurmurHash_1 = require_MurmurHash();
    var UUID = class _UUID {
      constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
        this.data = new Uint32Array(4);
        this.data[0] = mostSigBits;
        this.data[1] = moreSigBits;
        this.data[2] = lessSigBits;
        this.data[3] = leastSigBits;
      }
      static fromString(data) {
        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
          throw new Error("Incorrectly formatted UUID");
        }
        let segments = data.split("-");
        let mostSigBits = parseInt(segments[0], 16);
        let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
        let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
        let leastSigBits = parseInt(segments[4].substr(-8), 16);
        return new _UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
      }
      equals(obj) {
        if (obj === this) {
          return true;
        } else if (!(obj instanceof _UUID)) {
          return false;
        }
        return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
      }
      toString() {
        return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
      }
    };
    exports.UUID = UUID;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ATNDeserializer.js"(exports) {
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATNDeserializer = void 0;
    var ActionTransition_1 = require_ActionTransition();
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ATN_1 = require_ATN();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNStateType_1 = require_ATNStateType();
    var AtomTransition_1 = require_AtomTransition();
    var BasicBlockStartState_1 = require_BasicBlockStartState();
    var BasicState_1 = require_BasicState();
    var BitSet_1 = require_BitSet();
    var BlockEndState_1 = require_BlockEndState();
    var BlockStartState_1 = require_BlockStartState();
    var DecisionState_1 = require_DecisionState();
    var DFA_1 = require_DFA();
    var EpsilonTransition_1 = require_EpsilonTransition();
    var IntervalSet_1 = require_IntervalSet();
    var InvalidState_1 = require_InvalidState();
    var LexerChannelAction_1 = require_LexerChannelAction();
    var LexerCustomAction_1 = require_LexerCustomAction();
    var LexerModeAction_1 = require_LexerModeAction();
    var LexerMoreAction_1 = require_LexerMoreAction();
    var LexerPopModeAction_1 = require_LexerPopModeAction();
    var LexerPushModeAction_1 = require_LexerPushModeAction();
    var LexerSkipAction_1 = require_LexerSkipAction();
    var LexerTypeAction_1 = require_LexerTypeAction();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var NotSetTransition_1 = require_NotSetTransition();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PlusBlockStartState_1 = require_PlusBlockStartState();
    var PlusLoopbackState_1 = require_PlusLoopbackState();
    var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
    var PredicateTransition_1 = require_PredicateTransition();
    var RangeTransition_1 = require_RangeTransition();
    var RuleStartState_1 = require_RuleStartState();
    var RuleStopState_1 = require_RuleStopState();
    var RuleTransition_1 = require_RuleTransition();
    var SetTransition_1 = require_SetTransition();
    var StarBlockStartState_1 = require_StarBlockStartState();
    var StarLoopbackState_1 = require_StarLoopbackState();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var TokensStartState_1 = require_TokensStartState();
    var UUID_1 = require_UUID();
    var WildcardTransition_1 = require_WildcardTransition();
    var UnicodeDeserializingMode;
    (function(UnicodeDeserializingMode2) {
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
      UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
    })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
    var ATNDeserializer = class _ATNDeserializer {
      constructor(deserializationOptions) {
        if (deserializationOptions === void 0) {
          deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
        }
        this.deserializationOptions = deserializationOptions;
      }
      static get SERIALIZED_VERSION() {
        return 3;
      }
      /**
       * Determines if a particular serialized representation of an ATN supports
       * a particular feature, identified by the {@link UUID} used for serializing
       * the ATN at the time the feature was first introduced.
       *
       * @param feature The {@link UUID} marking the first time the feature was
       * supported in the serialized ATN.
       * @param actualUuid The {@link UUID} of the actual serialized ATN which is
       * currently being deserialized.
       * @returns `true` if the `actualUuid` value represents a
       * serialized ATN at or after the feature identified by `feature` was
       * introduced; otherwise, `false`.
       */
      static isFeatureSupported(feature, actualUuid) {
        let featureIndex = _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
        if (featureIndex < 0) {
          return false;
        }
        return _ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
      }
      static getUnicodeDeserializer(mode) {
        if (mode === 0) {
          return {
            readUnicode: (data, p) => {
              return _ATNDeserializer.toInt(data[p]);
            },
            size: 1
          };
        } else {
          return {
            readUnicode: (data, p) => {
              return _ATNDeserializer.toInt32(data, p);
            },
            size: 2
          };
        }
      }
      deserialize(data) {
        data = data.slice(0);
        for (let i = 1; i < data.length; i++) {
          data[i] = data[i] - 2 & 65535;
        }
        let p = 0;
        let version = _ATNDeserializer.toInt(data[p++]);
        if (version !== _ATNDeserializer.SERIALIZED_VERSION) {
          let reason = `Could not deserialize ATN with version ${version} (expected ${_ATNDeserializer.SERIALIZED_VERSION}).`;
          throw new Error(reason);
        }
        let uuid = _ATNDeserializer.toUUID(data, p);
        p += 8;
        if (_ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
          let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${_ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
          throw new Error(reason);
        }
        let supportsLexerActions = _ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);
        let grammarType = _ATNDeserializer.toInt(data[p++]);
        let maxTokenType = _ATNDeserializer.toInt(data[p++]);
        let atn = new ATN_1.ATN(grammarType, maxTokenType);
        let loopBackStateNumbers = [];
        let endStateNumbers = [];
        let nstates = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < nstates; i++) {
          let stype = _ATNDeserializer.toInt(data[p++]);
          if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            atn.addState(new InvalidState_1.InvalidState());
            continue;
          }
          let ruleIndex = _ATNDeserializer.toInt(data[p++]);
          if (ruleIndex === 65535) {
            ruleIndex = -1;
          }
          let s = this.stateFactory(stype, ruleIndex);
          if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
            let loopBackStateNumber = _ATNDeserializer.toInt(data[p++]);
            loopBackStateNumbers.push([s, loopBackStateNumber]);
          } else if (s instanceof BlockStartState_1.BlockStartState) {
            let endStateNumber = _ATNDeserializer.toInt(data[p++]);
            endStateNumbers.push([s, endStateNumber]);
          }
          atn.addState(s);
        }
        for (let pair of loopBackStateNumbers) {
          pair[0].loopBackState = atn.states[pair[1]];
        }
        for (let pair of endStateNumbers) {
          pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < numNonGreedyStates; i++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].nonGreedy = true;
        }
        let numSllDecisions = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < numSllDecisions; i++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].sll = true;
        }
        let numPrecedenceStates = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < numPrecedenceStates; i++) {
          let stateNumber = _ATNDeserializer.toInt(data[p++]);
          atn.states[stateNumber].isPrecedenceRule = true;
        }
        let nrules = _ATNDeserializer.toInt(data[p++]);
        if (atn.grammarType === 0) {
          atn.ruleToTokenType = new Int32Array(nrules);
        }
        atn.ruleToStartState = new Array(nrules);
        for (let i = 0; i < nrules; i++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          let startState = atn.states[s];
          startState.leftFactored = _ATNDeserializer.toInt(data[p++]) !== 0;
          atn.ruleToStartState[i] = startState;
          if (atn.grammarType === 0) {
            let tokenType = _ATNDeserializer.toInt(data[p++]);
            if (tokenType === 65535) {
              tokenType = Token_1.Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
            if (!_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {
              let actionIndexIgnored = _ATNDeserializer.toInt(data[p++]);
              if (actionIndexIgnored === 65535) {
                actionIndexIgnored = -1;
              }
            }
          }
        }
        atn.ruleToStopState = new Array(nrules);
        for (let state of atn.states) {
          if (!(state instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          atn.ruleToStopState[state.ruleIndex] = state;
          atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
        let nmodes = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < nmodes; i++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          atn.modeToStartState.push(atn.states[s]);
        }
        atn.modeToDFA = new Array(nmodes);
        for (let i = 0; i < nmodes; i++) {
          atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
        }
        let sets = [];
        p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
          0
          /* UNICODE_BMP */
        ));
        if (_ATNDeserializer.isFeatureSupported(_ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {
          p = this.deserializeSets(data, p, sets, _ATNDeserializer.getUnicodeDeserializer(
            1
            /* UNICODE_SMP */
          ));
        }
        let nedges = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < nedges; i++) {
          let src = _ATNDeserializer.toInt(data[p]);
          let trg = _ATNDeserializer.toInt(data[p + 1]);
          let ttype = _ATNDeserializer.toInt(data[p + 2]);
          let arg1 = _ATNDeserializer.toInt(data[p + 3]);
          let arg2 = _ATNDeserializer.toInt(data[p + 4]);
          let arg3 = _ATNDeserializer.toInt(data[p + 5]);
          let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
          let srcState = atn.states[src];
          srcState.addTransition(trans);
          p += 6;
        }
        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
          hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
          equals: (a, b) => {
            return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
          }
        });
        let returnTransitions = [];
        for (let state of atn.states) {
          let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let t = state.transition(i);
            if (!(t instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            let ruleTransition = t;
            let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
            if (!returningFromLeftFactored && returningToLeftFactored) {
              continue;
            }
            let outermostPrecedenceReturn = -1;
            if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
              if (ruleTransition.precedence === 0) {
                outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
              }
            }
            let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };
            if (returnTransitionsSet.add(current)) {
              returnTransitions.push(current);
            }
          }
        }
        for (let returnTransition of returnTransitions) {
          let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
          atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
        }
        for (let state of atn.states) {
          if (state instanceof BlockStartState_1.BlockStartState) {
            if (state.endState === void 0) {
              throw new Error("IllegalStateException");
            }
            if (state.endState.startState !== void 0) {
              throw new Error("IllegalStateException");
            }
            state.endState.startState = state;
          }
          if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
                target.loopBackState = loopbackState;
              }
            }
          } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            let loopbackState = state;
            for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
              let target = loopbackState.transition(i).target;
              if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
                target.loopBackState = loopbackState;
              }
            }
          }
        }
        let ndecisions = _ATNDeserializer.toInt(data[p++]);
        for (let i = 1; i <= ndecisions; i++) {
          let s = _ATNDeserializer.toInt(data[p++]);
          let decState = atn.states[s];
          atn.decisionToState.push(decState);
          decState.decision = i - 1;
        }
        if (atn.grammarType === 0) {
          if (supportsLexerActions) {
            atn.lexerActions = new Array(_ATNDeserializer.toInt(data[p++]));
            for (let i = 0; i < atn.lexerActions.length; i++) {
              let actionType = _ATNDeserializer.toInt(data[p++]);
              let data1 = _ATNDeserializer.toInt(data[p++]);
              if (data1 === 65535) {
                data1 = -1;
              }
              let data2 = _ATNDeserializer.toInt(data[p++]);
              if (data2 === 65535) {
                data2 = -1;
              }
              let lexerAction = this.lexerActionFactory(actionType, data1, data2);
              atn.lexerActions[i] = lexerAction;
            }
          } else {
            let legacyLexerActions = [];
            for (let state of atn.states) {
              for (let i = 0; i < state.numberOfTransitions; i++) {
                let transition = state.transition(i);
                if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                  continue;
                }
                let ruleIndex = transition.ruleIndex;
                let actionIndex = transition.actionIndex;
                let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
                state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
                legacyLexerActions.push(lexerAction);
              }
            }
            atn.lexerActions = legacyLexerActions;
          }
        }
        this.markPrecedenceDecisions(atn);
        atn.decisionToDFA = new Array(ndecisions);
        for (let i = 0; i < ndecisions; i++) {
          atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
          atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
          }
          for (let i = 0; i < atn.ruleToStartState.length; i++) {
            let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
            bypassStart.ruleIndex = i;
            atn.addState(bypassStart);
            let bypassStop = new BlockEndState_1.BlockEndState();
            bypassStop.ruleIndex = i;
            atn.addState(bypassStop);
            bypassStart.endState = bypassStop;
            atn.defineDecisionState(bypassStart);
            bypassStop.startState = bypassStart;
            let endState;
            let excludeTransition;
            if (atn.ruleToStartState[i].isPrecedenceRule) {
              endState = void 0;
              for (let state of atn.states) {
                if (state.ruleIndex !== i) {
                  continue;
                }
                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                  continue;
                }
                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
                if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                  continue;
                }
                if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                  endState = state;
                  break;
                }
              }
              if (!endState) {
                throw new Error("Couldn't identify final state of the precedence rule prefix section.");
              }
              excludeTransition = endState.loopBackState.transition(0);
            } else {
              endState = atn.ruleToStopState[i];
            }
            for (let state of atn.states) {
              for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
                let transition = state.transition(i2);
                if (transition === excludeTransition) {
                  continue;
                }
                if (transition.target === endState) {
                  transition.target = bypassStop;
                }
              }
            }
            while (atn.ruleToStartState[i].numberOfTransitions > 0) {
              let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
              bypassStart.addTransition(transition);
            }
            atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
            bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
            let matchState = new BasicState_1.BasicState();
            atn.addState(matchState);
            matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
            bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        if (this.deserializationOptions.isOptimize) {
          while (true) {
            let optimizationCount = 0;
            optimizationCount += _ATNDeserializer.inlineSetRules(atn);
            optimizationCount += _ATNDeserializer.combineChainedEpsilons(atn);
            let preserveOrder = atn.grammarType === 0;
            optimizationCount += _ATNDeserializer.optimizeSets(atn, preserveOrder);
            if (optimizationCount === 0) {
              break;
            }
          }
          if (this.deserializationOptions.isVerifyATN) {
            this.verifyATN(atn);
          }
        }
        _ATNDeserializer.identifyTailCalls(atn);
        return atn;
      }
      deserializeSets(data, p, sets, unicodeDeserializer) {
        let nsets = _ATNDeserializer.toInt(data[p++]);
        for (let i = 0; i < nsets; i++) {
          let nintervals = _ATNDeserializer.toInt(data[p]);
          p++;
          let set = new IntervalSet_1.IntervalSet();
          sets.push(set);
          let containsEof = _ATNDeserializer.toInt(data[p++]) !== 0;
          if (containsEof) {
            set.add(-1);
          }
          for (let j = 0; j < nintervals; j++) {
            let a = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            let b = unicodeDeserializer.readUnicode(data, p);
            p += unicodeDeserializer.size;
            set.add(a, b);
          }
        }
        return p;
      }
      /**
       * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
       * the {@link StarLoopEntryState#precedenceRuleDecision} field to the
       * correct value.
       *
       * @param atn The ATN.
       */
      markPrecedenceDecisions(atn) {
        let rulePrecedenceDecisions = /* @__PURE__ */ new Map();
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
            if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                rulePrecedenceDecisions.set(state.ruleIndex, state);
                state.precedenceRuleDecision = true;
                state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
              }
            }
          }
        }
        for (let precedenceDecision of rulePrecedenceDecisions) {
          for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
            if (transition.serializationType !== 1) {
              continue;
            }
            let epsilonTransition = transition;
            if (epsilonTransition.outermostPrecedenceReturn !== -1) {
              continue;
            }
            precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
          }
        }
      }
      verifyATN(atn) {
        for (let state of atn.states) {
          this.checkCondition(state !== void 0, "ATN states should not be undefined.");
          if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
            continue;
          }
          this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
          if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
            let starLoopEntryState = state;
            this.checkCondition(starLoopEntryState.loopBackState !== void 0);
            this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
            if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
              this.checkCondition(!starLoopEntryState.nonGreedy);
            } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
              this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
              this.checkCondition(starLoopEntryState.nonGreedy);
            } else {
              throw new Error("IllegalStateException");
            }
          }
          if (state instanceof StarLoopbackState_1.StarLoopbackState) {
            this.checkCondition(state.numberOfTransitions === 1);
            this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
          }
          if (state instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(state.loopBackState !== void 0);
          }
          if (state instanceof RuleStartState_1.RuleStartState) {
            this.checkCondition(state.stopState !== void 0);
          }
          if (state instanceof BlockStartState_1.BlockStartState) {
            this.checkCondition(state.endState !== void 0);
          }
          if (state instanceof BlockEndState_1.BlockEndState) {
            this.checkCondition(state.startState !== void 0);
          }
          if (state instanceof DecisionState_1.DecisionState) {
            let decisionState = state;
            this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
          } else {
            this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
          }
        }
      }
      checkCondition(condition, message) {
        if (!condition) {
          throw new Error("IllegalStateException: " + message);
        }
      }
      static inlineSetRules(atn) {
        let inlinedCalls = 0;
        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          let startState = atn.ruleToStartState[i];
          let middleState = startState;
          while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
            middleState = middleState.getOptimizedTransition(0).target;
          }
          if (middleState.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let matchTransition = middleState.getOptimizedTransition(0);
          let matchTarget = matchTransition.target;
          if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
            continue;
          }
          switch (matchTransition.serializationType) {
            case 5:
            case 2:
            case 7:
              ruleToInlineTransition[i] = matchTransition;
              break;
            case 8:
            case 9:
              continue;
            default:
              continue;
          }
        }
        for (let state of atn.states) {
          if (state.ruleIndex < 0) {
            continue;
          }
          let optimizedTransitions;
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            let ruleTransition = transition;
            let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
            if (effective === void 0) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue;
            }
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(i));
              }
            }
            inlinedCalls++;
            let target = ruleTransition.followState;
            let intermediateState = new BasicState_1.BasicState();
            intermediateState.setRuleIndex(target.ruleIndex);
            atn.addState(intermediateState);
            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
            switch (effective.serializationType) {
              case 5:
                intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
                break;
              case 2:
                intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
                break;
              case 7:
                intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
                break;
              default:
                throw new Error("UnsupportedOperationException");
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
        }
        return inlinedCalls;
      }
      static combineChainedEpsilons(atn) {
        let removedEdges = 0;
        for (let state of atn.states) {
          if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          let optimizedTransitions;
          nextTransition: for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            let intermediate = transition.target;
            if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue nextTransition;
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
            }
            removedEdges++;
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(j));
              }
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              let target = intermediate.getOptimizedTransition(j).target;
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
            }
          }
          if (optimizedTransitions !== void 0) {
            if (state.isOptimized) {
              while (state.numberOfOptimizedTransitions > 0) {
                state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
              }
            }
            for (let transition of optimizedTransitions) {
              state.addOptimizedTransition(transition);
            }
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
        }
        return removedEdges;
      }
      static optimizeSets(atn, preserveOrder) {
        if (preserveOrder) {
          return 0;
        }
        let removedPaths = 0;
        let decisions = atn.decisionToState;
        for (let decision of decisions) {
          let setTransitions = new IntervalSet_1.IntervalSet();
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            let epsTransition = decision.getOptimizedTransition(i);
            if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
              continue;
            }
            if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
              continue;
            }
            let transition = epsTransition.target.getOptimizedTransition(0);
            if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
              continue;
            }
            if (transition instanceof NotSetTransition_1.NotSetTransition) {
              continue;
            }
            if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
              setTransitions.add(i);
            }
          }
          if (setTransitions.size <= 1) {
            continue;
          }
          let optimizedTransitions = [];
          for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
            if (!setTransitions.contains(i)) {
              optimizedTransitions.push(decision.getOptimizedTransition(i));
            }
          }
          let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
          let matchSet = new IntervalSet_1.IntervalSet();
          for (let interval of setTransitions.intervals) {
            for (let j = interval.a; j <= interval.b; j++) {
              let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
              if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
                throw new Error("Not yet implemented.");
              } else {
                matchSet.addAll(matchTransition.label);
              }
            }
          }
          let newTransition;
          if (matchSet.intervals.length === 1) {
            if (matchSet.size === 1) {
              newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
            } else {
              let matchInterval = matchSet.intervals[0];
              newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
            }
          } else {
            newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
          }
          let setOptimizedState = new BasicState_1.BasicState();
          setOptimizedState.setRuleIndex(decision.ruleIndex);
          atn.addState(setOptimizedState);
          setOptimizedState.addTransition(newTransition);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
          removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
          if (decision.isOptimized) {
            while (decision.numberOfOptimizedTransitions > 0) {
              decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            decision.addOptimizedTransition(transition);
          }
        }
        if (ParserATNSimulator_1.ParserATNSimulator.debug) {
          console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
        }
        return removedPaths;
      }
      static identifyTailCalls(atn) {
        for (let state of atn.states) {
          for (let i = 0; i < state.numberOfTransitions; i++) {
            let transition = state.transition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
          if (!state.isOptimized) {
            continue;
          }
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            if (!(transition instanceof RuleTransition_1.RuleTransition)) {
              continue;
            }
            transition.tailCall = this.testTailCall(atn, transition, false);
            transition.optimizedTailCall = this.testTailCall(atn, transition, true);
          }
        }
      }
      static testTailCall(atn, transition, optimizedPath) {
        if (!optimizedPath && transition.tailCall) {
          return true;
        }
        if (optimizedPath && transition.optimizedTailCall) {
          return true;
        }
        let reachable = new BitSet_1.BitSet(atn.states.length);
        let worklist = [];
        worklist.push(transition.followState);
        while (true) {
          let state = worklist.pop();
          if (!state) {
            break;
          }
          if (reachable.get(state.stateNumber)) {
            continue;
          }
          if (state instanceof RuleStopState_1.RuleStopState) {
            continue;
          }
          if (!state.onlyHasEpsilonTransitions) {
            return false;
          }
          let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
          for (let i = 0; i < transitionCount; i++) {
            let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
            if (t.serializationType !== 1) {
              return false;
            }
            worklist.push(t.target);
          }
        }
        return true;
      }
      static toInt(c) {
        return c;
      }
      static toInt32(data, offset) {
        return (data[offset] | data[offset + 1] << 16) >>> 0;
      }
      static toUUID(data, offset) {
        let leastSigBits = _ATNDeserializer.toInt32(data, offset);
        let lessSigBits = _ATNDeserializer.toInt32(data, offset + 2);
        let moreSigBits = _ATNDeserializer.toInt32(data, offset + 4);
        let mostSigBits = _ATNDeserializer.toInt32(data, offset + 6);
        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
      }
      edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        let target = atn.states[trg];
        switch (type) {
          case 1:
            return new EpsilonTransition_1.EpsilonTransition(target);
          case 2:
            if (arg3 !== 0) {
              return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
            } else {
              return new RangeTransition_1.RangeTransition(target, arg1, arg2);
            }
          case 3:
            let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
            return rt;
          case 4:
            let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
            return pt;
          case 10:
            return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
          case 5:
            if (arg3 !== 0) {
              return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
            } else {
              return new AtomTransition_1.AtomTransition(target, arg1);
            }
          case 6:
            let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
            return a;
          case 7:
            return new SetTransition_1.SetTransition(target, sets[arg1]);
          case 8:
            return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
          case 9:
            return new WildcardTransition_1.WildcardTransition(target);
        }
        throw new Error("The specified transition type is not valid.");
      }
      stateFactory(type, ruleIndex) {
        let s;
        switch (type) {
          case ATNStateType_1.ATNStateType.INVALID_TYPE:
            return new InvalidState_1.InvalidState();
          case ATNStateType_1.ATNStateType.BASIC:
            s = new BasicState_1.BasicState();
            break;
          case ATNStateType_1.ATNStateType.RULE_START:
            s = new RuleStartState_1.RuleStartState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_START:
            s = new BasicBlockStartState_1.BasicBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
            s = new PlusBlockStartState_1.PlusBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
            s = new StarBlockStartState_1.StarBlockStartState();
            break;
          case ATNStateType_1.ATNStateType.TOKEN_START:
            s = new TokensStartState_1.TokensStartState();
            break;
          case ATNStateType_1.ATNStateType.RULE_STOP:
            s = new RuleStopState_1.RuleStopState();
            break;
          case ATNStateType_1.ATNStateType.BLOCK_END:
            s = new BlockEndState_1.BlockEndState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            s = new StarLoopbackState_1.StarLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            s = new StarLoopEntryState_1.StarLoopEntryState();
            break;
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
            s = new PlusLoopbackState_1.PlusLoopbackState();
            break;
          case ATNStateType_1.ATNStateType.LOOP_END:
            s = new LoopEndState_1.LoopEndState();
            break;
          default:
            let message = `The specified state type ${type} is not valid.`;
            throw new Error(message);
        }
        s.ruleIndex = ruleIndex;
        return s;
      }
      lexerActionFactory(type, data1, data2) {
        switch (type) {
          case 0:
            return new LexerChannelAction_1.LexerChannelAction(data1);
          case 1:
            return new LexerCustomAction_1.LexerCustomAction(data1, data2);
          case 2:
            return new LexerModeAction_1.LexerModeAction(data1);
          case 3:
            return LexerMoreAction_1.LexerMoreAction.INSTANCE;
          case 4:
            return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
          case 5:
            return new LexerPushModeAction_1.LexerPushModeAction(data1);
          case 6:
            return LexerSkipAction_1.LexerSkipAction.INSTANCE;
          case 7:
            return new LexerTypeAction_1.LexerTypeAction(data1);
          default:
            let message = `The specified lexer action type ${type} is not valid.`;
            throw new Error(message);
        }
      }
    };
    ATNDeserializer.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
    ATNDeserializer.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
    ATNDeserializer.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
    ATNDeserializer.SUPPORTED_UUIDS = [
      ATNDeserializer.BASE_SERIALIZED_UUID,
      ATNDeserializer.ADDED_LEXER_ACTIONS,
      ATNDeserializer.ADDED_UNICODE_SMP
    ];
    ATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;
    __decorate([
      Decorators_1.NotNull
    ], ATNDeserializer.prototype, "deserializationOptions", void 0);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "deserialize", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "markPrecedenceDecisions", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ATNDeserializer.prototype, "edgeFactory", null);
    exports.ATNDeserializer = ATNDeserializer;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/InputMismatchException.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMismatchException = void 0;
    var RecognitionException_1 = require_RecognitionException();
    var Decorators_1 = require_Decorators();
    var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
      constructor(recognizer, state, context) {
        if (context === void 0) {
          context = recognizer.context;
        }
        super(recognizer, recognizer.inputStream, context);
        if (state !== void 0) {
          this.setOffendingState(state);
        }
        this.setOffendingToken(recognizer, recognizer.currentToken);
      }
    };
    InputMismatchException = __decorate([
      __param(0, Decorators_1.NotNull)
    ], InputMismatchException);
    exports.InputMismatchException = InputMismatchException;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/DefaultErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorStrategy = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var IntervalSet_1 = require_IntervalSet();
    var NoViableAltException_1 = require_NoViableAltException();
    var PredictionContext_1 = require_PredictionContext();
    var Token_1 = require_Token();
    var Decorators_1 = require_Decorators();
    var DefaultErrorStrategy = class {
      constructor() {
        this.errorRecoveryMode = false;
        this.lastErrorIndex = -1;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation simply calls {@link #endErrorCondition} to
       * ensure that the handler is not in error recovery mode.
       */
      reset(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * This method is called to enter error recovery mode when a recognition
       * exception is reported.
       *
       * @param recognizer the parser instance
       */
      beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
      }
      /**
       * {@inheritDoc}
       */
      inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
      }
      /**
       * This method is called to leave error recovery mode after recovering from
       * a recognition exception.
       *
       * @param recognizer
       */
      endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = void 0;
        this.lastErrorIndex = -1;
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation simply calls {@link #endErrorCondition}.
       */
      reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation returns immediately if the handler is already
       * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}
       * and dispatches the reporting task based on the runtime type of `e`
       * according to the following table.
       *
       * * {@link NoViableAltException}: Dispatches the call to
       *   {@link #reportNoViableAlternative}
       * * {@link InputMismatchException}: Dispatches the call to
       *   {@link #reportInputMismatch}
       * * {@link FailedPredicateException}: Dispatches the call to
       *   {@link #reportFailedPredicate}
       * * All other types: calls {@link Parser#notifyErrorListeners} to report
       *   the exception
       */
      reportError(recognizer, e) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_1.NoViableAltException) {
          this.reportNoViableAlternative(recognizer, e);
        } else if (e instanceof InputMismatchException_1.InputMismatchException) {
          this.reportInputMismatch(recognizer, e);
        } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
          this.reportFailedPredicate(recognizer, e);
        } else {
          console.error(`unknown recognition error type: ${e}`);
          this.notifyErrorListeners(recognizer, e.toString(), e);
        }
      }
      notifyErrorListeners(recognizer, message, e) {
        let offendingToken = e.getOffendingToken(recognizer);
        if (offendingToken === void 0) {
          offendingToken = null;
        }
        recognizer.notifyErrorListeners(message, offendingToken, e);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation resynchronizes the parser by consuming tokens
       * until we find one in the resynchronization set--loosely the set of tokens
       * that can follow the current rule.
       */
      recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
          recognizer.consume();
        }
        this.lastErrorIndex = recognizer.inputStream.index;
        if (!this.lastErrorStates) {
          this.lastErrorStates = new IntervalSet_1.IntervalSet();
        }
        this.lastErrorStates.add(recognizer.state);
        let followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
      }
      /**
       * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure
       * that the current lookahead symbol is consistent with what were expecting
       * at this point in the ATN. You can call this anytime but ANTLR only
       * generates code to check before subrules/loops and each iteration.
       *
       * Implements Jim Idle's magic sync mechanism in closures and optional
       * subrules. E.g.,
       *
       * ```antlr
       * a : sync ( stuff sync )* ;
       * sync : {consume to what can follow sync} ;
       * ```
       *
       * At the start of a sub rule upon error, {@link #sync} performs single
       * token deletion, if possible. If it can't do that, it bails on the current
       * rule and uses the default error recovery, which consumes until the
       * resynchronization set of the current rule.
       *
       * If the sub rule is optional (`(...)?`, `(...)*`, or block
       * with an empty alternative), then the expected set includes what follows
       * the subrule.
       *
       * During loop iteration, it consumes until it sees a token that can start a
       * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
       * stay in the loop as long as possible.
       *
       * **ORIGINS**
       *
       * Previous versions of ANTLR did a poor job of their recovery within loops.
       * A single mismatch token or missing token would force the parser to bail
       * out of the entire rules surrounding the loop. So, for rule
       *
       * ```antlr
       * classDef : 'class' ID '{' member* '}'
       * ```
       *
       * input with an extra token between members would force the parser to
       * consume until it found the next class definition rather than the next
       * member definition of the current class.
       *
       * This functionality cost a little bit of effort because the parser has to
       * compare token set at the start of the loop and at each iteration. If for
       * some reason speed is suffering for you, you can turn off this
       * functionality by simply overriding this method as a blank { }.
       */
      sync(recognizer) {
        let s = recognizer.interpreter.atn.states[recognizer.state];
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        let tokens = recognizer.inputStream;
        let la = tokens.LA(1);
        let nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
          this.nextTokensContext = void 0;
          this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
          return;
        }
        if (nextTokens.contains(Token_1.Token.EPSILON)) {
          if (this.nextTokensContext === void 0) {
            this.nextTokensContext = recognizer.context;
            this.nextTokensState = recognizer.state;
          }
          return;
        }
        switch (s.stateType) {
          case ATNStateType_1.ATNStateType.BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
            if (this.singleTokenDeletion(recognizer)) {
              return;
            }
            throw new InputMismatchException_1.InputMismatchException(recognizer);
          case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
            this.reportUnwantedToken(recognizer);
            let expecting = recognizer.getExpectedTokens();
            let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
            this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
            break;
          default:
            break;
        }
      }
      /**
       * This is called by {@link #reportError} when the exception is a
       * {@link NoViableAltException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportNoViableAlternative(recognizer, e) {
        let tokens = recognizer.inputStream;
        let input;
        if (tokens) {
          if (e.startToken.type === Token_1.Token.EOF) {
            input = "<EOF>";
          } else {
            input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());
          }
        } else {
          input = "<unknown input>";
        }
        let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This is called by {@link #reportError} when the exception is an
       * {@link InputMismatchException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportInputMismatch(recognizer, e) {
        let expected = e.expectedTokens;
        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
        let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This is called by {@link #reportError} when the exception is a
       * {@link FailedPredicateException}.
       *
       * @see #reportError
       *
       * @param recognizer the parser instance
       * @param e the recognition exception
       */
      reportFailedPredicate(recognizer, e) {
        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
        let msg = "rule " + ruleName + " " + e.message;
        this.notifyErrorListeners(recognizer, msg, e);
      }
      /**
       * This method is called to report a syntax error which requires the removal
       * of a token from the input stream. At the time this method is called, the
       * erroneous symbol is current `LT(1)` symbol and has not yet been
       * removed from the input stream. When this method returns,
       * `recognizer` is in error recovery mode.
       *
       * This method is called when {@link #singleTokenDeletion} identifies
       * single-token deletion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser#notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let tokenName = this.getTokenErrorDisplay(t);
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      /**
       * This method is called to report a syntax error which requires the
       * insertion of a missing token into the input stream. At the time this
       * method is called, the missing token has not yet been inserted. When this
       * method returns, `recognizer` is in error recovery mode.
       *
       * This method is called when {@link #singleTokenInsertion} identifies
       * single-token insertion as a viable recovery strategy for a mismatched
       * input error.
       *
       * The default implementation simply returns if the handler is already in
       * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to
       * enter error recovery mode, followed by calling
       * {@link Parser#notifyErrorListeners}.
       *
       * @param recognizer the parser instance
       */
      reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
          return;
        }
        this.beginErrorCondition(recognizer);
        let t = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, void 0);
      }
      /**
       * {@inheritDoc}
       *
       * The default implementation attempts to recover from the mismatched input
       * by using single token insertion and deletion as described below. If the
       * recovery attempt fails, this method
       * {@link InputMismatchException}.
       *
       * **EXTRA TOKEN** (single token deletion)
       *
       * `LA(1)` is not what we are looking for. If `LA(2)` has the
       * right token, however, then assume `LA(1)` is some extra spurious
       * token and delete it. Then consume and return the next token (which was
       * the `LA(2)` token) as the successful result of the match operation.
       *
       * This recovery strategy is implemented by {@link #singleTokenDeletion}.
       *
       * **MISSING TOKEN** (single token insertion)
       *
       * If current token (at `LA(1)`) is consistent with what could come
       * after the expected `LA(1)` token, then assume the token is missing
       * and use the parser's {@link TokenFactory} to create it on the fly. The
       * "insertion" is performed by returning the created token as the successful
       * result of the match operation.
       *
       * This recovery strategy is implemented by {@link #singleTokenInsertion}.
       *
       * **EXAMPLE**
       *
       * For example, Input `i=(3;` is clearly missing the `')'`. When
       * the parser returns from the nested call to `expr`, it will have
       * call chain:
       *
       * ```
       * stat  expr  atom
       * ```
       *
       * and it will be trying to match the `')'` at this point in the
       * derivation:
       *
       * ```
       * => ID '=' '(' INT ')' ('+' atom)* ';'
       *                    ^
       * ```
       *
       * The attempt to match `')'` will fail when it sees `';'` and
       * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`
       * is in the set of tokens that can follow the `')'` token reference
       * in rule `atom`. It can assume that you forgot the `')'`.
       */
      recoverInline(recognizer) {
        let matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol) {
          recognizer.consume();
          return matchedSymbol;
        }
        if (this.singleTokenInsertion(recognizer)) {
          return this.getMissingSymbol(recognizer);
        }
        if (this.nextTokensContext === void 0) {
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        } else {
          throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
        }
      }
      /**
       * This method implements the single-token insertion inline error recovery
       * strategy. It is called by {@link #recoverInline} if the single-token
       * deletion strategy fails to recover from the mismatched input. If this
       * method returns `true`, `recognizer` will be in error recovery
       * mode.
       *
       * This method determines whether or not single-token insertion is viable by
       * checking if the `LA(1)` input symbol could be successfully matched
       * if it were instead the `LA(2)` symbol. If this method returns
       * `true`, the caller is responsible for creating and inserting a
       * token with the correct type to produce this behavior.
       *
       * @param recognizer the parser instance
       * @returns `true` if single-token insertion is a viable recovery
       * strategy for the current mismatched input, otherwise `false`
       */
      singleTokenInsertion(recognizer) {
        let currentSymbolType = recognizer.inputStream.LA(1);
        let currentState = recognizer.interpreter.atn.states[recognizer.state];
        let next = currentState.transition(0).target;
        let atn = recognizer.interpreter.atn;
        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
        if (expectingAtLL2.contains(currentSymbolType)) {
          this.reportMissingToken(recognizer);
          return true;
        }
        return false;
      }
      /**
       * This method implements the single-token deletion inline error recovery
       * strategy. It is called by {@link #recoverInline} to attempt to recover
       * from mismatched input. If this method returns `undefined`, the parser and error
       * handler state will not have changed. If this method returns non-`undefined`,
       * `recognizer` will *not* be in error recovery mode since the
       * returned token was a successful match.
       *
       * If the single-token deletion is successful, this method calls
       * {@link #reportUnwantedToken} to report the error, followed by
       * {@link Parser#consume} to actually "delete" the extraneous token. Then,
       * before returning {@link #reportMatch} is called to signal a successful
       * match.
       *
       * @param recognizer the parser instance
       * @returns the successfully matched {@link Token} instance if single-token
       * deletion successfully recovers from the mismatched input, otherwise
       * `undefined`
       */
      singleTokenDeletion(recognizer) {
        let nextTokenType = recognizer.inputStream.LA(2);
        let expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
          this.reportUnwantedToken(recognizer);
          recognizer.consume();
          let matchedSymbol = recognizer.currentToken;
          this.reportMatch(recognizer);
          return matchedSymbol;
        }
        return void 0;
      }
      /** Conjure up a missing token during error recovery.
       *
       *  The recognizer attempts to recover from single missing
       *  symbols. But, actions might refer to that missing symbol.
       *  For example, x=ID {f($x);}. The action clearly assumes
       *  that there has been an identifier matched previously and that
       *  $x points at that token. If that token is missing, but
       *  the next token in the stream is what we want we assume that
       *  this token is missing and we keep going. Because we
       *  have to return some token to replace the missing token,
       *  we have to conjure one up. This method gives the user control
       *  over the tokens returned for missing tokens. Mostly,
       *  you will want to create something special for identifier
       *  tokens. For literals such as '{' and ',', the default
       *  action in the parser or tree parser works. It simply creates
       *  a CommonToken of the appropriate type. The text will be the token.
       *  If you change what tokens must be created by the lexer,
       *  override this method to create the appropriate tokens.
       */
      getMissingSymbol(recognizer) {
        let currentSymbol = recognizer.currentToken;
        let expecting = this.getExpectedTokens(recognizer);
        let expectedTokenType = Token_1.Token.INVALID_TYPE;
        if (!expecting.isNil) {
          expectedTokenType = expecting.minElement;
        }
        let tokenText;
        if (expectedTokenType === Token_1.Token.EOF) {
          tokenText = "<missing EOF>";
        } else {
          tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
        }
        let current = currentSymbol;
        let lookback = recognizer.inputStream.tryLT(-1);
        if (current.type === Token_1.Token.EOF && lookback != null) {
          current = lookback;
        }
        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
      }
      constructToken(tokenSource, expectedTokenType, tokenText, current) {
        let factory = tokenSource.tokenFactory;
        let x = current.tokenSource;
        let stream = x ? x.inputStream : void 0;
        return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
      }
      getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
      }
      /** How should a token be displayed in an error message? The default
       *  is to display just the text, but during development you might
       *  want to have a lot of information spit out.  Override in that case
       *  to use t.toString() (which, for CommonToken, dumps everything about
       *  the token). This is better than forcing you to override a method in
       *  your token objects because you don't have to go modify your lexer
       *  so that it creates a new Java type.
       */
      getTokenErrorDisplay(t) {
        if (!t) {
          return "<no token>";
        }
        let s = this.getSymbolText(t);
        if (!s) {
          if (this.getSymbolType(t) === Token_1.Token.EOF) {
            s = "<EOF>";
          } else {
            s = `<${this.getSymbolType(t)}>`;
          }
        }
        return this.escapeWSAndQuote(s);
      }
      getSymbolText(symbol) {
        return symbol.text;
      }
      getSymbolType(symbol) {
        return symbol.type;
      }
      escapeWSAndQuote(s) {
        s = s.replace("\n", "\\n");
        s = s.replace("\r", "\\r");
        s = s.replace("	", "\\t");
        return "'" + s + "'";
      }
      /*  Compute the error recovery set for the current rule.  During
       *  rule invocation, the parser pushes the set of tokens that can
       *  follow that rule reference on the stack; this amounts to
       *  computing FIRST of what follows the rule reference in the
       *  enclosing rule. See LinearApproximator.FIRST().
       *  This local follow set only includes tokens
       *  from within the rule; i.e., the FIRST computation done by
       *  ANTLR stops at the end of a rule.
       *
       *  EXAMPLE
       *
       *  When you find a "no viable alt exception", the input is not
       *  consistent with any of the alternatives for rule r.  The best
       *  thing to do is to consume tokens until you see something that
       *  can legally follow a call to r *or* any rule that called r.
       *  You don't want the exact set of viable next tokens because the
       *  input might just be missing a token--you might consume the
       *  rest of the input looking for one of the missing tokens.
       *
       *  Consider grammar:
       *
       *  a : '[' b ']'
       *    | '(' b ')'
       *    ;
       *  b : c '^' INT ;
       *  c : ID
       *    | INT
       *    ;
       *
       *  At each rule invocation, the set of tokens that could follow
       *  that rule is pushed on a stack.  Here are the various
       *  context-sensitive follow sets:
       *
       *  FOLLOW(b1_in_a) = FIRST(']') = ']'
       *  FOLLOW(b2_in_a) = FIRST(')') = ')'
       *  FOLLOW(c_in_b) = FIRST('^') = '^'
       *
       *  Upon erroneous input "[]", the call chain is
       *
       *  a -> b -> c
       *
       *  and, hence, the follow context stack is:
       *
       *  depth     follow set       start of rule execution
       *    0         <EOF>                    a (from main())
       *    1          ']'                     b
       *    2          '^'                     c
       *
       *  Notice that ')' is not included, because b would have to have
       *  been called from a different context in rule a for ')' to be
       *  included.
       *
       *  For error recovery, we cannot consider FOLLOW(c)
       *  (context-sensitive or otherwise).  We need the combined set of
       *  all context-sensitive FOLLOW sets--the set of all tokens that
       *  could follow any reference in the call chain.  We need to
       *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
       *  we resync'd to that token, we'd consume until EOF.  We need to
       *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
       *  In this case, for input "[]", LA(1) is ']' and in the set, so we would
       *  not consume anything. After printing an error, rule c would
       *  return normally.  Rule b would not find the required '^' though.
       *  At this point, it gets a mismatched token error and
       *  exception (since LA(1) is not in the viable following token
       *  set).  The rule exception handler tries to recover, but finds
       *  the same recovery set and doesn't consume anything.  Rule b
       *  exits normally returning to rule a.  Now it finds the ']' (and
       *  with the successful match exits errorRecovery mode).
       *
       *  So, you can see that the parser walks up the call chain looking
       *  for the token that was a member of the recovery set.
       *
       *  Errors are not generated in errorRecovery mode.
       *
       *  ANTLR's error recovery mechanism is based upon original ideas:
       *
       *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
       *
       *  and
       *
       *  "A note on error recovery in recursive descent parsers":
       *  http://portal.acm.org/citation.cfm?id=947902.947905
       *
       *  Later, Josef Grosch had some good ideas:
       *
       *  "Efficient and Comfortable Error Recovery in Recursive Descent
       *  Parsers":
       *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
       *
       *  Like Grosch I implement context-sensitive FOLLOW sets that are combined
       *  at run-time upon error to avoid overhead during parsing.
       */
      getErrorRecoverySet(recognizer) {
        let atn = recognizer.interpreter.atn;
        let ctx = recognizer.context;
        let recoverSet = new IntervalSet_1.IntervalSet();
        while (ctx && ctx.invokingState >= 0) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          let follow = atn.nextTokens(rt.followState);
          recoverSet.addAll(follow);
          ctx = ctx._parent;
        }
        recoverSet.remove(Token_1.Token.EPSILON);
        return recoverSet;
      }
      /** Consume tokens until one matches the given token set. */
      consumeUntil(recognizer, set) {
        let ttype = recognizer.inputStream.LA(1);
        while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
          recognizer.consume();
          ttype = recognizer.inputStream.LA(1);
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reset", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportMatch", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "reportError", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "sync", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
    __decorate([
      Decorators_1.Override
    ], DefaultErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolText", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getSymbolType", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], DefaultErrorStrategy.prototype, "consumeUntil", null);
    exports.DefaultErrorStrategy = DefaultErrorStrategy;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ParseInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseInfo = void 0;
    var Decorators_1 = require_Decorators();
    var ParseInfo = class ParseInfo {
      constructor(atnSimulator) {
        this.atnSimulator = atnSimulator;
      }
      /**
       * Gets an array of {@link DecisionInfo} instances containing the profiling
       * information gathered for each decision in the ATN.
       *
       * @returns An array of {@link DecisionInfo} instances, indexed by decision
       * number.
       */
      getDecisionInfo() {
        return this.atnSimulator.getDecisionInfo();
      }
      /**
       * Gets the decision numbers for decisions that required one or more
       * full-context predictions during parsing. These are decisions for which
       * {@link DecisionInfo#LL_Fallback} is non-zero.
       *
       * @returns A list of decision numbers which required one or more
       * full-context predictions during parsing.
       */
      getLLDecisions() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let LL = [];
        for (let i = 0; i < decisions.length; i++) {
          let fallBack = decisions[i].LL_Fallback;
          if (fallBack > 0) {
            LL.push(i);
          }
        }
        return LL;
      }
      /**
       * Gets the total time spent during prediction across all decisions made
       * during parsing. This value is the sum of
       * {@link DecisionInfo#timeInPrediction} for all decisions.
       */
      getTotalTimeInPrediction() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let t = 0;
        for (let decision of decisions) {
          t += decision.timeInPrediction;
        }
        return t;
      }
      /**
       * Gets the total number of SLL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#SLL_TotalLook} for all decisions.
       */
      getTotalSLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_TotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of LL lookahead operations across all decisions
       * made during parsing. This value is the sum of
       * {@link DecisionInfo#LL_TotalLook} for all decisions.
       */
      getTotalLLLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_TotalLook;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL prediction
       * across all decisions made during parsing.
       */
      getTotalSLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for LL prediction
       * across all decisions made during parsing.
       */
      getTotalLLATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      /**
       * Gets the total number of ATN lookahead operations for SLL and LL
       * prediction across all decisions made during parsing.
       *
       * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
       * {@link #getTotalLLATNLookaheadOps}.
       */
      getTotalATNLookaheadOps() {
        let decisions = this.atnSimulator.getDecisionInfo();
        let k = 0;
        for (let decision of decisions) {
          k += decision.SLL_ATNTransitions;
          k += decision.LL_ATNTransitions;
        }
        return k;
      }
      getDFASize(decision) {
        if (decision) {
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
          return decisionToDFA.states.size;
        } else {
          let n = 0;
          let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
          for (let i = 0; i < decisionToDFA.length; i++) {
            n += this.getDFASize(i);
          }
          return n;
        }
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getDecisionInfo", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseInfo.prototype, "getLLDecisions", null);
    ParseInfo = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseInfo);
    exports.ParseInfo = ParseInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ProxyParserErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyParserErrorListener = void 0;
    var ProxyErrorListener_1 = require_ProxyErrorListener();
    var Decorators_1 = require_Decorators();
    var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
      constructor(delegates) {
        super(delegates);
      }
      reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAmbiguity) {
            listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
          }
        });
      }
      reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportAttemptingFullContext) {
            listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
          }
        });
      }
      reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
        this.getDelegates().forEach((listener) => {
          if (listener.reportContextSensitivity) {
            listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
          }
        });
      }
    };
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override
    ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
    exports.ProxyParserErrorListener = ProxyParserErrorListener;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ParseCancellationException.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseCancellationException = void 0;
    var ParseCancellationException = class extends Error {
      constructor(cause) {
        super(cause.message);
        this.cause = cause;
        this.stack = cause.stack;
      }
      getCause() {
        return this.cause;
      }
    };
    exports.ParseCancellationException = ParseCancellationException;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/BailErrorStrategy.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BailErrorStrategy = void 0;
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var InputMismatchException_1 = require_InputMismatchException();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
      /** Instead of recovering from exception `e`, re-throw it wrapped
       *  in a {@link ParseCancellationException} so it is not caught by the
       *  rule function catches.  Use {@link Exception#getCause()} to get the
       *  original {@link RecognitionException}.
       */
      recover(recognizer, e) {
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      /** Make sure we don't attempt to recover inline; if the parser
       *  successfully recovers, it won't throw an exception.
       */
      recoverInline(recognizer) {
        let e = new InputMismatchException_1.InputMismatchException(recognizer);
        for (let context = recognizer.context; context; context = context.parent) {
          context.exception = e;
        }
        throw new ParseCancellationException_1.ParseCancellationException(e);
      }
      /** Make sure we don't attempt to recover from problems in subrules. */
      sync(recognizer) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recover", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "recoverInline", null);
    __decorate([
      Decorators_1.Override
    ], BailErrorStrategy.prototype, "sync", null);
    exports.BailErrorStrategy = BailErrorStrategy;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/Character.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
    function isHighSurrogate(ch) {
      return ch >= 55296 && ch <= 56319;
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(ch) {
      return ch >= 56320 && ch <= 57343;
    }
    exports.isLowSurrogate = isLowSurrogate;
    function isSupplementaryCodePoint(ch) {
      return ch >= 65536;
    }
    exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CodePointBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointBuffer = void 0;
    var assert = require_assert();
    var Character = require_Character();
    var CodePointBuffer = class _CodePointBuffer {
      constructor(buffer, size) {
        this.buffer = buffer;
        this._position = 0;
        this._size = size;
      }
      static withArray(buffer) {
        return new _CodePointBuffer(buffer, buffer.length);
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        if (newPosition < 0 || newPosition > this._size) {
          throw new RangeError();
        }
        this._position = newPosition;
      }
      get remaining() {
        return this._size - this.position;
      }
      get(offset) {
        return this.buffer[offset];
      }
      array() {
        return this.buffer.slice(0, this._size);
      }
      static builder(initialBufferSize) {
        return new _CodePointBuffer.Builder(initialBufferSize);
      }
    };
    exports.CodePointBuffer = CodePointBuffer;
    (function(CodePointBuffer2) {
      let Type;
      (function(Type2) {
        Type2[Type2["BYTE"] = 0] = "BYTE";
        Type2[Type2["CHAR"] = 1] = "CHAR";
        Type2[Type2["INT"] = 2] = "INT";
      })(Type || (Type = {}));
      class Builder {
        constructor(initialBufferSize) {
          this.type = 0;
          this.buffer = new Uint8Array(initialBufferSize);
          this.prevHighSurrogate = -1;
          this.position = 0;
        }
        build() {
          return new CodePointBuffer2(this.buffer, this.position);
        }
        static roundUpToNextPowerOfTwo(i) {
          let nextPowerOfTwo = 32 - Math.clz32(i - 1);
          return Math.pow(2, nextPowerOfTwo);
        }
        ensureRemaining(remainingNeeded) {
          switch (this.type) {
            case 0:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint8Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 1:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Uint16Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
            case 2:
              if (this.buffer.length - this.position < remainingNeeded) {
                let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
                let newBuffer = new Int32Array(newCapacity);
                newBuffer.set(this.buffer.subarray(0, this.position), 0);
                this.buffer = newBuffer;
              }
              break;
          }
        }
        append(utf16In) {
          this.ensureRemaining(utf16In.length);
          this.appendArray(utf16In);
        }
        appendArray(utf16In) {
          switch (this.type) {
            case 0:
              this.appendArrayByte(utf16In);
              break;
            case 1:
              this.appendArrayChar(utf16In);
              break;
            case 2:
              this.appendArrayInt(utf16In);
              break;
          }
        }
        appendArrayByte(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outByte = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (c <= 255) {
              outByte[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              if (!Character.isHighSurrogate(c)) {
                this.byteToCharBuffer(utf16In.length);
                this.appendArrayChar(utf16In);
                return;
              } else {
                this.byteToIntBuffer(utf16In.length);
                this.appendArrayInt(utf16In);
                return;
              }
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayChar(utf16In) {
          assert(this.prevHighSurrogate === -1);
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outChar = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            if (!Character.isHighSurrogate(c)) {
              outChar[outOffset] = c;
            } else {
              utf16In = utf16In.subarray(inOffset, inLimit);
              this.position = outOffset;
              this.charToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
            inOffset++;
            outOffset++;
          }
          this.position = outOffset;
        }
        appendArrayInt(utf16In) {
          let input = utf16In;
          let inOffset = 0;
          let inLimit = utf16In.length;
          let outInt = this.buffer;
          let outOffset = this.position;
          while (inOffset < inLimit) {
            let c = input[inOffset];
            inOffset++;
            if (this.prevHighSurrogate !== -1) {
              if (Character.isLowSurrogate(c)) {
                outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
                outOffset++;
                this.prevHighSurrogate = -1;
              } else {
                outInt[outOffset] = this.prevHighSurrogate;
                outOffset++;
                if (Character.isHighSurrogate(c)) {
                  this.prevHighSurrogate = c;
                } else {
                  outInt[outOffset] = c;
                  outOffset++;
                  this.prevHighSurrogate = -1;
                }
              }
            } else if (Character.isHighSurrogate(c)) {
              this.prevHighSurrogate = c;
            } else {
              outInt[outOffset] = c;
              outOffset++;
            }
          }
          if (this.prevHighSurrogate !== -1) {
            outInt[outOffset] = this.prevHighSurrogate;
            outOffset++;
          }
          this.position = outOffset;
        }
        byteToCharBuffer(toAppend) {
          let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 1;
          this.buffer = newBuffer;
        }
        byteToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
        charToIntBuffer(toAppend) {
          let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
          newBuffer.set(this.buffer.subarray(0, this.position), 0);
          this.type = 2;
          this.buffer = newBuffer;
        }
      }
      CodePointBuffer2.Builder = Builder;
    })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CodePointCharStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodePointCharStream = void 0;
    var assert = require_assert();
    var IntStream_1 = require_IntStream();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var CodePointCharStream = class _CodePointCharStream {
      // Use the factory method {@link #fromBuffer(CodePointBuffer)} to
      // construct instances of this type.
      constructor(array, position, remaining, name) {
        assert(position === 0);
        this._array = array;
        this._size = remaining;
        this._name = name;
        this._position = 0;
      }
      get internalStorage() {
        return this._array;
      }
      static fromBuffer(codePointBuffer, name) {
        if (name === void 0 || name.length === 0) {
          name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        return new _CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
      }
      consume() {
        if (this._size - this._position === 0) {
          assert(this.LA(1) === IntStream_1.IntStream.EOF);
          throw new RangeError("cannot consume EOF");
        }
        this._position++;
      }
      get index() {
        return this._position;
      }
      get size() {
        return this._size;
      }
      /** mark/release do nothing; we have entire buffer */
      mark() {
        return -1;
      }
      release(marker) {
      }
      seek(index) {
        this._position = index;
      }
      get sourceName() {
        return this._name;
      }
      toString() {
        return this.getText(Interval_1.Interval.of(0, this.size - 1));
      }
      LA(i) {
        let offset;
        switch (Math.sign(i)) {
          case -1:
            offset = this.index + i;
            if (offset < 0) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
          case 0:
            return 0;
          case 1:
            offset = this.index + i - 1;
            if (offset >= this.size) {
              return IntStream_1.IntStream.EOF;
            }
            return this._array[offset];
        }
        throw new RangeError("Not reached");
      }
      /** Return the UTF-16 encoded string for the given interval */
      getText(interval) {
        const startIdx = Math.min(interval.a, this.size);
        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
        if (this._array instanceof Int32Array) {
          return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        } else {
          return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
        }
      }
    };
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "toString", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "LA", null);
    __decorate([
      Decorators_1.Override
    ], CodePointCharStream.prototype, "getText", null);
    exports.CodePointCharStream = CodePointCharStream;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CharStreams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CharStreams = void 0;
    var CodePointBuffer_1 = require_CodePointBuffer();
    var CodePointCharStream_1 = require_CodePointCharStream();
    var IntStream_1 = require_IntStream();
    var CharStreams;
    (function(CharStreams2) {
      function fromString(s, sourceName) {
        if (sourceName === void 0 || sourceName.length === 0) {
          sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
        }
        let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
        let cb = new Uint16Array(s.length);
        for (let i = 0; i < s.length; i++) {
          cb[i] = s.charCodeAt(i);
        }
        codePointBufferBuilder.append(cb);
        return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
      }
      CharStreams2.fromString = fromString;
    })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/BufferedTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferedTokenStream = void 0;
    var assert = require_assert();
    var CommonToken_1 = require_CommonToken();
    var Interval_1 = require_Interval();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var BufferedTokenStream = class BufferedTokenStream {
      constructor(tokenSource) {
        this.tokens = [];
        this.p = -1;
        this.fetchedEOF = false;
        if (tokenSource == null) {
          throw new Error("tokenSource cannot be null");
        }
        this._tokenSource = tokenSource;
      }
      get tokenSource() {
        return this._tokenSource;
      }
      /** Reset this token stream by setting its token source. */
      set tokenSource(tokenSource) {
        this._tokenSource = tokenSource;
        this.tokens.length = 0;
        this.p = -1;
        this.fetchedEOF = false;
      }
      get index() {
        return this.p;
      }
      mark() {
        return 0;
      }
      release(marker) {
      }
      seek(index) {
        this.lazyInit();
        this.p = this.adjustSeekIndex(index);
      }
      get size() {
        return this.tokens.length;
      }
      consume() {
        let skipEofCheck;
        if (this.p >= 0) {
          if (this.fetchedEOF) {
            skipEofCheck = this.p < this.tokens.length - 1;
          } else {
            skipEofCheck = this.p < this.tokens.length;
          }
        } else {
          skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
          throw new Error("cannot consume EOF");
        }
        if (this.sync(this.p + 1)) {
          this.p = this.adjustSeekIndex(this.p + 1);
        }
      }
      /** Make sure index `i` in tokens has a token.
       *
       * @returns `true` if a token is located at index `i`, otherwise
       *    `false`.
       * @see #get(int i)
       */
      sync(i) {
        assert(i >= 0);
        let n = i - this.tokens.length + 1;
        if (n > 0) {
          let fetched = this.fetch(n);
          return fetched >= n;
        }
        return true;
      }
      /** Add `n` elements to buffer.
       *
       * @returns The actual number of elements added to the buffer.
       */
      fetch(n) {
        if (this.fetchedEOF) {
          return 0;
        }
        for (let i = 0; i < n; i++) {
          let t = this.tokenSource.nextToken();
          if (this.isWritableToken(t)) {
            t.tokenIndex = this.tokens.length;
          }
          this.tokens.push(t);
          if (t.type === Token_1.Token.EOF) {
            this.fetchedEOF = true;
            return i + 1;
          }
        }
        return n;
      }
      get(i) {
        if (i < 0 || i >= this.tokens.length) {
          throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
        }
        return this.tokens[i];
      }
      /** Get all tokens from start..stop inclusively. */
      getRange(start, stop) {
        if (start < 0 || stop < 0) {
          return [];
        }
        this.lazyInit();
        let subset = new Array();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          subset.push(t);
        }
        return subset;
      }
      LA(i) {
        let token = this.LT(i);
        if (!token) {
          return Token_1.Token.INVALID_TYPE;
        }
        return token.type;
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        return this.tokens[this.p - k];
      }
      LT(k) {
        let result = this.tryLT(k);
        if (result === void 0) {
          throw new RangeError("requested lookback index out of range");
        }
        return result;
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) {
          return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
      }
      /**
       * Allowed derived classes to modify the behavior of operations which change
       * the current stream position by adjusting the target token index of a seek
       * operation. The default implementation simply returns `i`. If an
       * exception is thrown in this method, the current stream index should not be
       * changed.
       *
       * For example, {@link CommonTokenStream} overrides this method to ensure that
       * the seek target is always an on-channel token.
       *
       * @param i The target token index.
       * @returns The adjusted target token index.
       */
      adjustSeekIndex(i) {
        return i;
      }
      lazyInit() {
        if (this.p === -1) {
          this.setup();
        }
      }
      setup() {
        this.sync(0);
        this.p = this.adjustSeekIndex(0);
      }
      /** Given a start and stop index, return a `List` of all tokens in
       *  the token type `BitSet`.  Return an empty array if no tokens were found.  This
       *  method looks at both on and off channel tokens.
       */
      getTokens(start, stop, types) {
        this.lazyInit();
        if (start === void 0) {
          assert(stop === void 0 && types === void 0);
          return this.tokens;
        } else if (stop === void 0) {
          stop = this.tokens.length - 1;
        }
        if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
          throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
        }
        if (start > stop) {
          return [];
        }
        if (types === void 0) {
          return this.tokens.slice(start, stop + 1);
        } else if (typeof types === "number") {
          types = (/* @__PURE__ */ new Set()).add(types);
        }
        let typesSet = types;
        let filteredTokens = this.tokens.slice(start, stop + 1);
        filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
        return filteredTokens;
      }
      /**
       * Given a starting index, return the index of the next token on channel.
       * Return `i` if `tokens[i]` is on channel. Return the index of
       * the EOF token if there are no tokens on channel between `i` and
       * EOF.
       */
      nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        let token = this.tokens[i];
        while (token.channel !== channel) {
          if (token.type === Token_1.Token.EOF) {
            return i;
          }
          i++;
          this.sync(i);
          token = this.tokens[i];
        }
        return i;
      }
      /**
       * Given a starting index, return the index of the previous token on
       * channel. Return `i` if `tokens[i]` is on channel. Return -1
       * if there are no tokens on channel between `i` and 0.
       *
       * If `i` specifies an index at or after the EOF token, the EOF token
       * index is returned. This is due to the fact that the EOF token is treated
       * as though it were on every channel.
       */
      previousTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.size) {
          return this.size - 1;
        }
        while (i >= 0) {
          let token = this.tokens[i];
          if (token.type === Token_1.Token.EOF || token.channel === channel) {
            return i;
          }
          i--;
        }
        return i;
      }
      /** Collect all tokens on specified channel to the right of
       *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or
       *  EOF. If `channel` is `-1`, find any non default channel token.
       */
      getHiddenTokensToRight(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        let to;
        let from = tokenIndex + 1;
        if (nextOnChannel === -1) {
          to = this.size - 1;
        } else {
          to = nextOnChannel;
        }
        return this.filterForChannel(from, to, channel);
      }
      /** Collect all tokens on specified channel to the left of
       *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.
       *  If `channel` is `-1`, find any non default channel token.
       */
      getHiddenTokensToLeft(tokenIndex, channel = -1) {
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
          throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
        }
        if (tokenIndex === 0) {
          return [];
        }
        let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
          return [];
        }
        let from = prevOnChannel + 1;
        let to = tokenIndex - 1;
        return this.filterForChannel(from, to, channel);
      }
      filterForChannel(from, to, channel) {
        let hidden = new Array();
        for (let i = from; i <= to; i++) {
          let t = this.tokens[i];
          if (channel === -1) {
            if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
              hidden.push(t);
            }
          } else {
            if (t.channel === channel) {
              hidden.push(t);
            }
          }
        }
        return hidden;
      }
      get sourceName() {
        return this.tokenSource.sourceName;
      }
      getText(interval) {
        if (interval === void 0) {
          interval = Interval_1.Interval.of(0, this.size - 1);
        } else if (!(interval instanceof Interval_1.Interval)) {
          interval = interval.sourceInterval;
        }
        let start = interval.a;
        let stop = interval.b;
        if (start < 0 || stop < 0) {
          return "";
        }
        this.fill();
        if (stop >= this.tokens.length) {
          stop = this.tokens.length - 1;
        }
        let buf = "";
        for (let i = start; i <= stop; i++) {
          let t = this.tokens[i];
          if (t.type === Token_1.Token.EOF) {
            break;
          }
          buf += t.text;
        }
        return buf.toString();
      }
      getTextFromRange(start, stop) {
        if (this.isToken(start) && this.isToken(stop)) {
          return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
        }
        return "";
      }
      /** Get all tokens from lexer until EOF. */
      fill() {
        this.lazyInit();
        const blockSize = 1e3;
        while (true) {
          let fetched = this.fetch(blockSize);
          if (fetched < blockSize) {
            return;
          }
        }
      }
      // TODO: Figure out a way to make this more flexible?
      isWritableToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
      // TODO: Figure out a way to make this more flexible?
      isToken(t) {
        return t instanceof CommonToken_1.CommonToken;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], BufferedTokenStream.prototype, "_tokenSource", void 0);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "index", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "mark", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "release", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "seek", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "consume", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "get", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LA", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "LT", null);
    __decorate([
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "sourceName", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getText", null);
    __decorate([
      Decorators_1.NotNull,
      Decorators_1.Override
    ], BufferedTokenStream.prototype, "getTextFromRange", null);
    BufferedTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], BufferedTokenStream);
    exports.BufferedTokenStream = BufferedTokenStream;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/CommonTokenStream.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommonTokenStream = void 0;
    var BufferedTokenStream_1 = require_BufferedTokenStream();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var CommonTokenStream = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
      /**
       * Constructs a new {@link CommonTokenStream} using the specified token
       * source and filtering tokens to the specified channel. Only tokens whose
       * {@link Token#getChannel} matches `channel` or have the
       * `Token.type` equal to {@link Token#EOF} will be returned by the
       * token stream lookahead methods.
       *
       * @param tokenSource The token source.
       * @param channel The channel to use for filtering tokens.
       */
      constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
        super(tokenSource);
        this.channel = channel;
      }
      adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
      }
      tryLB(k) {
        if (this.p - k < 0) {
          return void 0;
        }
        let i = this.p;
        let n = 1;
        while (n <= k && i > 0) {
          i = this.previousTokenOnChannel(i - 1, this.channel);
          n++;
        }
        if (i < 0) {
          return void 0;
        }
        return this.tokens[i];
      }
      tryLT(k) {
        this.lazyInit();
        if (k === 0) {
          throw new RangeError("0 is not a valid lookahead index");
        }
        if (k < 0) {
          return this.tryLB(-k);
        }
        let i = this.p;
        let n = 1;
        while (n < k) {
          if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
          }
          n++;
        }
        return this.tokens[i];
      }
      /** Count EOF just once. */
      getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let t of this.tokens) {
          if (t.channel === this.channel) {
            n++;
          }
          if (t.type === Token_1.Token.EOF) {
            break;
          }
        }
        return n;
      }
    };
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream.prototype, "adjustSeekIndex", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream.prototype, "tryLB", null);
    __decorate([
      Decorators_1.Override
    ], CommonTokenStream.prototype, "tryLT", null);
    CommonTokenStream = __decorate([
      __param(0, Decorators_1.NotNull)
    ], CommonTokenStream);
    exports.CommonTokenStream = CommonTokenStream;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ListTokenSource.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListTokenSource = void 0;
    var CommonTokenFactory_1 = require_CommonTokenFactory();
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var ListTokenSource = class ListTokenSource {
      /**
       * Constructs a new {@link ListTokenSource} instance from the specified
       * collection of {@link Token} objects and source name.
       *
       * @param tokens The collection of {@link Token} objects to provide as a
       * {@link TokenSource}.
       * @param sourceName The name of the {@link TokenSource}. If this value is
       * `undefined`, {@link #getSourceName} will attempt to infer the name from
       * the next {@link Token} (or the previous token if the end of the input has
       * been reached).
       *
       * @exception NullPointerException if `tokens` is `undefined`
       */
      constructor(tokens, sourceName) {
        this.i = 0;
        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
        if (tokens == null) {
          throw new Error("tokens cannot be null");
        }
        this.tokens = tokens;
        this._sourceName = sourceName;
      }
      /**
       * {@inheritDoc}
       */
      get charPositionInLine() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].charPositionInLine;
        } else if (this.eofToken != null) {
          return this.eofToken.charPositionInLine;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let tokenText = lastToken.text;
          if (tokenText != null) {
            let lastNewLine = tokenText.lastIndexOf("\n");
            if (lastNewLine >= 0) {
              return tokenText.length - lastNewLine - 1;
            }
          }
          return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
        }
        return 0;
      }
      /**
       * {@inheritDoc}
       */
      nextToken() {
        if (this.i >= this.tokens.length) {
          if (this.eofToken == null) {
            let start = -1;
            if (this.tokens.length > 0) {
              let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
              if (previousStop !== -1) {
                start = previousStop + 1;
              }
            }
            let stop = Math.max(-1, start - 1);
            this.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
          }
          return this.eofToken;
        }
        let t = this.tokens[this.i];
        if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
          this.eofToken = t;
        }
        this.i++;
        return t;
      }
      /**
       * {@inheritDoc}
       */
      get line() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].line;
        } else if (this.eofToken != null) {
          return this.eofToken.line;
        } else if (this.tokens.length > 0) {
          let lastToken = this.tokens[this.tokens.length - 1];
          let line = lastToken.line;
          let tokenText = lastToken.text;
          if (tokenText != null) {
            for (let i = 0; i < tokenText.length; i++) {
              if (tokenText.charAt(i) === "\n") {
                line++;
              }
            }
          }
          return line;
        }
        return 1;
      }
      /**
       * {@inheritDoc}
       */
      get inputStream() {
        if (this.i < this.tokens.length) {
          return this.tokens[this.i].inputStream;
        } else if (this.eofToken != null) {
          return this.eofToken.inputStream;
        } else if (this.tokens.length > 0) {
          return this.tokens[this.tokens.length - 1].inputStream;
        }
        return void 0;
      }
      /**
       * {@inheritDoc}
       */
      get sourceName() {
        if (this._sourceName) {
          return this._sourceName;
        }
        let inputStream = this.inputStream;
        if (inputStream != null) {
          return inputStream.sourceName;
        }
        return "List";
      }
      /**
       * {@inheritDoc}
       */
      // @Override
      set tokenFactory(factory) {
        this._factory = factory;
      }
      /**
       * {@inheritDoc}
       */
      get tokenFactory() {
        return this._factory;
      }
    };
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "nextToken", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], ListTokenSource.prototype, "sourceName", null);
    __decorate([
      Decorators_1.Override,
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource.prototype, "tokenFactory", null);
    ListTokenSource = __decorate([
      __param(0, Decorators_1.NotNull)
    ], ListTokenSource);
    exports.ListTokenSource = ListTokenSource;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/MultiMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MultiMap = void 0;
    var MultiMap = class extends Map {
      constructor() {
        super();
      }
      map(key, value) {
        let elementsForKey = super.get(key);
        if (!elementsForKey) {
          elementsForKey = [];
          super.set(key, elementsForKey);
        }
        elementsForKey.push(value);
      }
      getPairs() {
        let pairs = [];
        this.forEach((values, key) => {
          values.forEach((v) => {
            pairs.push([key, v]);
          });
        });
        return pairs;
      }
    };
    exports.MultiMap = MultiMap;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/InterpreterRuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InterpreterRuleContext = void 0;
    var Decorators_1 = require_Decorators();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
      constructor(ruleIndex, parent, invokingStateNumber) {
        if (invokingStateNumber !== void 0) {
          super(parent, invokingStateNumber);
        } else {
          super();
        }
        this._ruleIndex = ruleIndex;
      }
      get ruleIndex() {
        return this._ruleIndex;
      }
    };
    __decorate([
      Decorators_1.Override
    ], InterpreterRuleContext.prototype, "ruleIndex", null);
    exports.InterpreterRuleContext = InterpreterRuleContext;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ParserInterpreter.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserInterpreter = void 0;
    var ATNState_1 = require_ATNState();
    var ATNStateType_1 = require_ATNStateType();
    var BitSet_1 = require_BitSet();
    var FailedPredicateException_1 = require_FailedPredicateException();
    var InputMismatchException_1 = require_InputMismatchException();
    var InterpreterRuleContext_1 = require_InterpreterRuleContext();
    var LoopEndState_1 = require_LoopEndState();
    var Decorators_1 = require_Decorators();
    var Decorators_2 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var RecognitionException_1 = require_RecognitionException();
    var StarLoopEntryState_1 = require_StarLoopEntryState();
    var Token_1 = require_Token();
    var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
      constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
        super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
        this._parentContextStack = [];
        this.overrideDecision = -1;
        this.overrideDecisionInputIndex = -1;
        this.overrideDecisionAlt = -1;
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
        if (grammarFileName instanceof ParserInterpreter2) {
          let old = grammarFileName;
          this._grammarFileName = old._grammarFileName;
          this._atn = old._atn;
          this.pushRecursionContextStates = old.pushRecursionContextStates;
          this._ruleNames = old._ruleNames;
          this._vocabulary = old._vocabulary;
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
        } else {
          vocabulary = vocabulary;
          ruleNames = ruleNames;
          atn = atn;
          this._grammarFileName = grammarFileName;
          this._atn = atn;
          this._ruleNames = ruleNames.slice(0);
          this._vocabulary = vocabulary;
          this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
          for (let state of atn.states) {
            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
              continue;
            }
            if (state.precedenceRuleDecision) {
              this.pushRecursionContextStates.set(state.stateNumber);
            }
          }
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
        }
      }
      reset(resetInput) {
        if (resetInput === void 0) {
          super.reset();
        } else {
          super.reset(resetInput);
        }
        this.overrideDecisionReached = false;
        this._overrideDecisionRoot = void 0;
      }
      get atn() {
        return this._atn;
      }
      get vocabulary() {
        return this._vocabulary;
      }
      get ruleNames() {
        return this._ruleNames;
      }
      get grammarFileName() {
        return this._grammarFileName;
      }
      /** Begin parsing at startRuleIndex */
      parse(startRuleIndex) {
        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
        this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
        if (startRuleStartState.isPrecedenceRule) {
          this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
        } else {
          this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
        }
        while (true) {
          let p = this.atnState;
          switch (p.stateType) {
            case ATNStateType_1.ATNStateType.RULE_STOP:
              if (this._ctx.isEmpty) {
                if (startRuleStartState.isPrecedenceRule) {
                  let result = this._ctx;
                  let parentContext = this._parentContextStack.pop();
                  this.unrollRecursionContexts(parentContext[0]);
                  return result;
                } else {
                  this.exitRule();
                  return this._rootContext;
                }
              }
              this.visitRuleStopState(p);
              break;
            default:
              try {
                this.visitState(p);
              } catch (e) {
                if (e instanceof RecognitionException_1.RecognitionException) {
                  this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                  this.context.exception = e;
                  this.errorHandler.reportError(this, e);
                  this.recover(e);
                } else {
                  throw e;
                }
              }
              break;
          }
        }
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this._parentContextStack.push([this._ctx, localctx.invokingState]);
        super.enterRecursionRule(localctx, state, ruleIndex, precedence);
      }
      get atnState() {
        return this._atn.states[this.state];
      }
      visitState(p) {
        let predictedAlt = 1;
        if (p.numberOfTransitions > 1) {
          predictedAlt = this.visitDecisionState(p);
        }
        let transition = p.transition(predictedAlt - 1);
        switch (transition.serializationType) {
          case 1:
            if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
              let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
              let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
              this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
            }
            break;
          case 5:
            this.match(transition._label);
            break;
          case 2:
          case 7:
          case 8:
            if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
              this.recoverInline();
            }
            this.matchWildcard();
            break;
          case 9:
            this.matchWildcard();
            break;
          case 3:
            let ruleStartState = transition.target;
            let ruleIndex = ruleStartState.ruleIndex;
            let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
            if (ruleStartState.isPrecedenceRule) {
              this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
            } else {
              this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
            }
            break;
          case 4:
            let predicateTransition = transition;
            if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
              throw new FailedPredicateException_1.FailedPredicateException(this);
            }
            break;
          case 6:
            let actionTransition = transition;
            this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
            break;
          case 10:
            if (!this.precpred(this._ctx, transition.precedence)) {
              let precedence = transition.precedence;
              throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
            }
            break;
          default:
            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
        }
        this.state = transition.target.stateNumber;
      }
      /** Method visitDecisionState() is called when the interpreter reaches
       *  a decision state (instance of DecisionState). It gives an opportunity
       *  for subclasses to track interesting things.
       */
      visitDecisionState(p) {
        let predictedAlt;
        this.errorHandler.sync(this);
        let decision = p.decision;
        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
          predictedAlt = this.overrideDecisionAlt;
          this.overrideDecisionReached = true;
        } else {
          predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
        }
        return predictedAlt;
      }
      /** Provide simple "factory" for InterpreterRuleContext's.
       *  @since 4.5.1
       */
      createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
      }
      visitRuleStopState(p) {
        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
        if (ruleStartState.isPrecedenceRule) {
          let parentContext = this._parentContextStack.pop();
          this.unrollRecursionContexts(parentContext[0]);
          this.state = parentContext[1];
        } else {
          this.exitRule();
        }
        let ruleTransition = this._atn.states[this.state].transition(0);
        this.state = ruleTransition.followState.stateNumber;
      }
      /** Override this parser interpreters normal decision-making process
       *  at a particular decision and input token index. Instead of
       *  allowing the adaptive prediction mechanism to choose the
       *  first alternative within a block that leads to a successful parse,
       *  force it to take the alternative, 1..n for n alternatives.
       *
       *  As an implementation limitation right now, you can only specify one
       *  override. This is sufficient to allow construction of different
       *  parse trees for ambiguous input. It means re-parsing the entire input
       *  in general because you're never sure where an ambiguous sequence would
       *  live in the various parse trees. For example, in one interpretation,
       *  an ambiguous input sequence would be matched completely in expression
       *  but in another it could match all the way back to the root.
       *
       *  s : e '!'? ;
       *  e : ID
       *    | ID '!'
       *    ;
       *
       *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first
       *  case, the ambiguous sequence is fully contained only by the root.
       *  In the second case, the ambiguous sequences fully contained within just
       *  e, as in: (e ID !).
       *
       *  Rather than trying to optimize this and make
       *  some intelligent decisions for optimization purposes, I settled on
       *  just re-parsing the whole input and then using
       *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal
       *  subtree that contains the ambiguous sequence. I originally tried to
       *  record the call stack at the point the parser detected and ambiguity but
       *  left recursive rules create a parse tree stack that does not reflect
       *  the actual call stack. That impedance mismatch was enough to make
       *  it it challenging to restart the parser at a deeply nested rule
       *  invocation.
       *
       *  Only parser interpreters can override decisions so as to avoid inserting
       *  override checking code in the critical ALL(*) prediction execution path.
       *
       *  @since 4.5
       */
      addDecisionOverride(decision, tokenIndex, forcedAlt) {
        this.overrideDecision = decision;
        this.overrideDecisionInputIndex = tokenIndex;
        this.overrideDecisionAlt = forcedAlt;
      }
      get overrideDecisionRoot() {
        return this._overrideDecisionRoot;
      }
      /** Rely on the error handler for this parser but, if no tokens are consumed
       *  to recover, add an error node. Otherwise, nothing is seen in the parse
       *  tree.
       */
      recover(e) {
        let i = this._input.index;
        this.errorHandler.recover(this, e);
        if (this._input.index === i) {
          let tok = e.getOffendingToken();
          if (!tok) {
            throw new Error("Expected exception to have an offending token");
          }
          let source = tok.tokenSource;
          let stream = source !== void 0 ? source.inputStream : void 0;
          let sourcePair = { source, stream };
          if (e instanceof InputMismatchException_1.InputMismatchException) {
            let expectedTokens = e.expectedTokens;
            if (expectedTokens === void 0) {
              throw new Error("Expected the exception to provide expected tokens");
            }
            let expectedTokenType = Token_1.Token.INVALID_TYPE;
            if (!expectedTokens.isNil) {
              expectedTokenType = expectedTokens.minElement;
            }
            let errToken = this.tokenFactory.create(
              sourcePair,
              expectedTokenType,
              tok.text,
              Token_1.Token.DEFAULT_CHANNEL,
              -1,
              -1,
              // invalid start/stop
              tok.line,
              tok.charPositionInLine
            );
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          } else {
            let source2 = tok.tokenSource;
            let errToken = this.tokenFactory.create(
              sourcePair,
              Token_1.Token.INVALID_TYPE,
              tok.text,
              Token_1.Token.DEFAULT_CHANNEL,
              -1,
              -1,
              // invalid start/stop
              tok.line,
              tok.charPositionInLine
            );
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
          }
        }
      }
      recoverInline() {
        return this._errHandler.recoverInline(this);
      }
      /** Return the root of the parse, which can be useful if the parser
       *  bails out. You still can access the top node. Note that,
       *  because of the way left recursive rules add children, it's possible
       *  that the root will not have any children if the start rule immediately
       *  called and left recursive rule that fails.
       *
       * @since 4.5.1
       */
      get rootContext() {
        return this._rootContext;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParserInterpreter.prototype, "_vocabulary", void 0);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "reset", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "atn", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "vocabulary", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "ruleNames", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "grammarFileName", null);
    __decorate([
      Decorators_2.Override
    ], ParserInterpreter.prototype, "enterRecursionRule", null);
    ParserInterpreter = __decorate([
      __param(1, Decorators_1.NotNull)
    ], ParserInterpreter);
    exports.ParserInterpreter = ParserInterpreter;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreeMatch = void 0;
    var Decorators_1 = require_Decorators();
    var ParseTreeMatch = class ParseTreeMatch {
      /**
       * Constructs a new instance of {@link ParseTreeMatch} from the specified
       * parse tree and pattern.
       *
       * @param tree The parse tree to match against the pattern.
       * @param pattern The parse tree pattern.
       * @param labels A mapping from label names to collections of
       * {@link ParseTree} objects located by the tree pattern matching process.
       * @param mismatchedNode The first node which failed to match the tree
       * pattern during the matching process.
       *
       * @throws {@link Error} if `tree` is not defined
       * @throws {@link Error} if `pattern` is not defined
       * @throws {@link Error} if `labels` is not defined
       */
      constructor(tree, pattern, labels, mismatchedNode) {
        if (!tree) {
          throw new Error("tree cannot be null");
        }
        if (!pattern) {
          throw new Error("pattern cannot be null");
        }
        if (!labels) {
          throw new Error("labels cannot be null");
        }
        this._tree = tree;
        this._pattern = pattern;
        this._labels = labels;
        this._mismatchedNode = mismatchedNode;
      }
      /**
       * Get the last node associated with a specific `label`.
       *
       * For example, for pattern `<id:ID>`, `get("id")` returns the
       * node matched for that `ID`. If more than one node
       * matched the specified label, only the last is returned. If there is
       * no node associated with the label, this returns `undefined`.
       *
       * Pattern tags like `<ID>` and `<expr>` without labels are
       * considered to be labeled with `ID` and `expr`, respectively.
       *
       * @param label The label to check.
       *
       * @returns The last {@link ParseTree} to match a tag with the specified
       * label, or `undefined` if no parse tree matched a tag with the label.
       */
      get(label) {
        let parseTrees = this._labels.get(label);
        if (!parseTrees || parseTrees.length === 0) {
          return void 0;
        }
        return parseTrees[parseTrees.length - 1];
      }
      /**
       * Return all nodes matching a rule or token tag with the specified label.
       *
       * If the `label` is the name of a parser rule or token in the
       * grammar, the resulting list will contain both the parse trees matching
       * rule or tags explicitly labeled with the label and the complete set of
       * parse trees matching the labeled and unlabeled tags in the pattern for
       * the parser rule or token. For example, if `label` is `"foo"`,
       * the result will contain *all* of the following.
       *
       * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and
       *   `<foo:AnyTokenName>`.
       * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.
       * * Parse tree nodes matching tags of the form `<foo>`.
       *
       * @param label The label.
       *
       * @returns A collection of all {@link ParseTree} nodes matching tags with
       * the specified `label`. If no nodes matched the label, an empty list
       * is returned.
       */
      getAll(label) {
        const nodes = this._labels.get(label);
        if (!nodes) {
          return [];
        }
        return nodes;
      }
      /**
       * Return a mapping from label &rarr; [list of nodes].
       *
       * The map includes special entries corresponding to the names of rules and
       * tokens referenced in tags in the original pattern. For additional
       * information, see the description of {@link #getAll(String)}.
       *
       * @returns A mapping from labels to parse tree nodes. If the parse tree
       * pattern did not contain any rule or token tags, this map will be empty.
       */
      get labels() {
        return this._labels;
      }
      /**
       * Get the node at which we first detected a mismatch.
       *
       * @returns the node at which we first detected a mismatch, or `undefined`
       * if the match was successful.
       */
      get mismatchedNode() {
        return this._mismatchedNode;
      }
      /**
       * Gets a value indicating whether the match operation succeeded.
       *
       * @returns `true` if the match operation succeeded; otherwise,
       * `false`.
       */
      get succeeded() {
        return !this._mismatchedNode;
      }
      /**
       * Get the tree pattern we are matching against.
       *
       * @returns The tree pattern we are matching against.
       */
      get pattern() {
        return this._pattern;
      }
      /**
       * Get the parse tree we are trying to match to a pattern.
       *
       * @returns The {@link ParseTree} we are trying to match to a pattern.
       */
      get tree() {
        return this._tree;
      }
      /**
       * {@inheritDoc}
       */
      toString() {
        return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreeMatch.prototype, "getAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "labels", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreeMatch.prototype, "tree", null);
    __decorate([
      Decorators_1.Override
    ], ParseTreeMatch.prototype, "toString", null);
    ParseTreeMatch = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreeMatch);
    exports.ParseTreeMatch = ParseTreeMatch;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathLexer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexer = void 0;
    var ATNDeserializer_1 = require_ATNDeserializer();
    var Lexer_1 = require_Lexer();
    var LexerATNSimulator_1 = require_LexerATNSimulator();
    var VocabularyImpl_1 = require_VocabularyImpl();
    var Utils = require_Utils();
    var XPathLexer = class _XPathLexer extends Lexer_1.Lexer {
      // tslint:enable:no-trailing-whitespace
      constructor(input) {
        super(input);
        this._interp = new LexerATNSimulator_1.LexerATNSimulator(_XPathLexer._ATN, this);
      }
      // @Override
      // @NotNull
      get vocabulary() {
        return _XPathLexer.VOCABULARY;
      }
      // @Override
      get grammarFileName() {
        return "XPathLexer.g4";
      }
      // @Override
      get ruleNames() {
        return _XPathLexer.ruleNames;
      }
      // @Override
      get serializedATN() {
        return _XPathLexer._serializedATN;
      }
      // @Override
      get channelNames() {
        return _XPathLexer.channelNames;
      }
      // @Override
      get modeNames() {
        return _XPathLexer.modeNames;
      }
      // @Override
      action(_localctx, ruleIndex, actionIndex) {
        switch (ruleIndex) {
          case 4:
            this.ID_action(_localctx, actionIndex);
            break;
        }
      }
      ID_action(_localctx, actionIndex) {
        switch (actionIndex) {
          case 0:
            let text = this.text;
            if (text.charAt(0) === text.charAt(0).toUpperCase()) {
              this.type = _XPathLexer.TOKEN_REF;
            } else {
              this.type = _XPathLexer.RULE_REF;
            }
            break;
        }
      }
      static get _ATN() {
        if (!_XPathLexer.__ATN) {
          _XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils.toCharArray(_XPathLexer._serializedATN));
        }
        return _XPathLexer.__ATN;
      }
    };
    exports.XPathLexer = XPathLexer;
    XPathLexer.TOKEN_REF = 1;
    XPathLexer.RULE_REF = 2;
    XPathLexer.ANYWHERE = 3;
    XPathLexer.ROOT = 4;
    XPathLexer.WILDCARD = 5;
    XPathLexer.BANG = 6;
    XPathLexer.ID = 7;
    XPathLexer.STRING = 8;
    XPathLexer.channelNames = [
      "DEFAULT_TOKEN_CHANNEL",
      "HIDDEN"
    ];
    XPathLexer.modeNames = [
      "DEFAULT_MODE"
    ];
    XPathLexer.ruleNames = [
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "NameChar",
      "NameStartChar",
      "STRING"
    ];
    XPathLexer._LITERAL_NAMES = [
      void 0,
      void 0,
      void 0,
      "'//'",
      "'/'",
      "'*'",
      "'!'"
    ];
    XPathLexer._SYMBOLIC_NAMES = [
      void 0,
      "TOKEN_REF",
      "RULE_REF",
      "ANYWHERE",
      "ROOT",
      "WILDCARD",
      "BANG",
      "ID",
      "STRING"
    ];
    XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
    XPathLexer._serializedATNSegments = 2;
    XPathLexer._serializedATNSegment0 = '\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\n2;C\\aac|\r(*<>?AOR_\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1"C\\c|\r(*<>?AOR_';
    XPathLexer._serializedATNSegment1 = `1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x1B\x07#\x1B
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
    XPathLexer._serializedATN = Utils.join([
      XPathLexer._serializedATNSegment0,
      XPathLexer._serializedATNSegment1
    ], "");
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathLexerErrorListener = void 0;
    var Decorators_1 = require_Decorators();
    var XPathLexerErrorListener = class {
      syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathLexerErrorListener.prototype, "syntaxError", null);
    exports.XPathLexerErrorListener = XPathLexerErrorListener;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathElement = void 0;
    var Decorators_1 = require_Decorators();
    var XPathElement = class {
      /** Construct element like `/ID` or `ID` or `/*` etc...
       *  op is null if just node
       */
      constructor(nodeName) {
        this.nodeName = nodeName;
        this.invert = false;
      }
      toString() {
        let inv = this.invert ? "!" : "";
        let className = Object.constructor.name;
        return className + "[" + inv + this.nodeName + "]";
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathElement.prototype, "toString", null);
    exports.XPathElement = XPathElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleAnywhereElement.prototype, "evaluate", null);
    exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathRuleElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathRuleElement = void 0;
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathRuleElement = class extends XPathElement_1.XPathElement {
      constructor(ruleName, ruleIndex) {
        super(ruleName);
        this.ruleIndex = ruleIndex;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof ParserRuleContext_1.ParserRuleContext) {
            if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathRuleElement.prototype, "evaluate", null);
    exports.XPathRuleElement = XPathRuleElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenAnywhereElement.prototype, "evaluate", null);
    exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathTokenElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathTokenElement = void 0;
    var Decorators_1 = require_Decorators();
    var TerminalNode_1 = require_TerminalNode();
    var Trees_1 = require_Trees();
    var XPathElement_1 = require_XPathElement();
    var XPathTokenElement = class extends XPathElement_1.XPathElement {
      constructor(tokenName, tokenType) {
        super(tokenName);
        this.tokenType = tokenType;
      }
      evaluate(t) {
        let nodes = [];
        for (let c of Trees_1.Trees.getChildren(t)) {
          if (c instanceof TerminalNode_1.TerminalNode) {
            if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
              nodes.push(c);
            }
          }
        }
        return nodes;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathTokenElement.prototype, "evaluate", null);
    exports.XPathTokenElement = XPathTokenElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardAnywhereElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        if (this.invert) {
          return [];
        }
        return Trees_1.Trees.getDescendants(t);
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
    exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPathWildcardElement = void 0;
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var XPath_1 = require_XPath();
    var XPathElement_1 = require_XPathElement();
    var XPathWildcardElement = class extends XPathElement_1.XPathElement {
      constructor() {
        super(XPath_1.XPath.WILDCARD);
      }
      evaluate(t) {
        let kids = [];
        if (this.invert) {
          return kids;
        }
        for (let c of Trees_1.Trees.getChildren(t)) {
          kids.push(c);
        }
        return kids;
      }
    };
    __decorate([
      Decorators_1.Override
    ], XPathWildcardElement.prototype, "evaluate", null);
    exports.XPathWildcardElement = XPathWildcardElement;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/xpath/XPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XPath = void 0;
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var LexerNoViableAltException_1 = require_LexerNoViableAltException();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var Token_1 = require_Token();
    var XPathLexer_1 = require_XPathLexer();
    var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
    var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
    var XPathRuleElement_1 = require_XPathRuleElement();
    var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
    var XPathTokenElement_1 = require_XPathTokenElement();
    var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
    var XPathWildcardElement_1 = require_XPathWildcardElement();
    var XPath = class _XPath {
      constructor(parser, path) {
        this.parser = parser;
        this.path = path;
        this.elements = this.split(path);
      }
      // TODO: check for invalid token/rule names, bad syntax
      split(path) {
        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
        lexer.recover = (e) => {
          throw e;
        };
        lexer.removeErrorListeners();
        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
        try {
          tokenStream.fill();
        } catch (e) {
          if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
            let pos = lexer.charPositionInLine;
            let msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
            throw new RangeError(msg);
          }
          throw e;
        }
        let tokens = tokenStream.getTokens();
        let elements = [];
        let n = tokens.length;
        let i = 0;
        loop: while (i < n) {
          let el = tokens[i];
          let next;
          switch (el.type) {
            case XPathLexer_1.XPathLexer.ROOT:
            case XPathLexer_1.XPathLexer.ANYWHERE:
              let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
              i++;
              next = tokens[i];
              let invert = next.type === XPathLexer_1.XPathLexer.BANG;
              if (invert) {
                i++;
                next = tokens[i];
              }
              let pathElement = this.getXPathElement(next, anywhere);
              pathElement.invert = invert;
              elements.push(pathElement);
              i++;
              break;
            case XPathLexer_1.XPathLexer.TOKEN_REF:
            case XPathLexer_1.XPathLexer.RULE_REF:
            case XPathLexer_1.XPathLexer.WILDCARD:
              elements.push(this.getXPathElement(el, false));
              i++;
              break;
            case Token_1.Token.EOF:
              break loop;
            default:
              throw new Error("Unknowth path element " + el);
          }
        }
        return elements;
      }
      /**
       * Convert word like `*` or `ID` or `expr` to a path
       * element. `anywhere` is `true` if `//` precedes the
       * word.
       */
      getXPathElement(wordToken, anywhere) {
        if (wordToken.type === Token_1.Token.EOF) {
          throw new Error("Missing path element at end of path");
        }
        let word = wordToken.text;
        if (word == null) {
          throw new Error("Expected wordToken to have text content.");
        }
        let ttype = this.parser.getTokenType(word);
        let ruleIndex = this.parser.getRuleIndex(word);
        switch (wordToken.type) {
          case XPathLexer_1.XPathLexer.WILDCARD:
            return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
          case XPathLexer_1.XPathLexer.TOKEN_REF:
          case XPathLexer_1.XPathLexer.STRING:
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
            }
            return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
          default:
            if (ruleIndex === -1) {
              throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
            }
            return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
        }
      }
      static findAll(tree, xpath, parser) {
        let p = new _XPath(parser, xpath);
        return p.evaluate(tree);
      }
      /**
       * Return a list of all nodes starting at `t` as root that satisfy the
       * path. The root `/` is relative to the node passed to {@link evaluate}.
       */
      evaluate(t) {
        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
        dummyRoot.addChild(t);
        let work = /* @__PURE__ */ new Set([dummyRoot]);
        let i = 0;
        while (i < this.elements.length) {
          let next = /* @__PURE__ */ new Set();
          for (let node of work) {
            if (node.childCount > 0) {
              let matching = this.elements[i].evaluate(node);
              matching.forEach(next.add, next);
            }
          }
          i++;
          work = next;
        }
        return work;
      }
    };
    exports.XPath = XPath;
    XPath.WILDCARD = "*";
    XPath.NOT = "!";
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreePattern.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePattern = void 0;
    var Decorators_1 = require_Decorators();
    var XPath_1 = require_XPath();
    var ParseTreePattern = class ParseTreePattern {
      /**
       * Construct a new instance of the {@link ParseTreePattern} class.
       *
       * @param matcher The {@link ParseTreePatternMatcher} which created this
       * tree pattern.
       * @param pattern The tree pattern in concrete syntax form.
       * @param patternRuleIndex The parser rule which serves as the root of the
       * tree pattern.
       * @param patternTree The tree pattern in {@link ParseTree} form.
       */
      constructor(matcher, pattern, patternRuleIndex, patternTree) {
        this._matcher = matcher;
        this._patternRuleIndex = patternRuleIndex;
        this._pattern = pattern;
        this._patternTree = patternTree;
      }
      /**
       * Match a specific parse tree against this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns A {@link ParseTreeMatch} object describing the result of the
       * match operation. The `ParseTreeMatch.succeeded` method can be
       * used to determine whether or not the match was successful.
       */
      match(tree) {
        return this._matcher.match(tree, this);
      }
      /**
       * Determine whether or not a parse tree matches this tree pattern.
       *
       * @param tree The parse tree to match against this tree pattern.
       * @returns `true` if `tree` is a match for the current tree
       * pattern; otherwise, `false`.
       */
      matches(tree) {
        return this._matcher.match(tree, this).succeeded;
      }
      /**
       * Find all nodes using XPath and then try to match those subtrees against
       * this tree pattern.
       *
       * @param tree The {@link ParseTree} to match against this pattern.
       * @param xpath An expression matching the nodes
       *
       * @returns A collection of {@link ParseTreeMatch} objects describing the
       * successful matches. Unsuccessful matches are omitted from the result,
       * regardless of the reason for the failure.
       */
      findAll(tree, xpath) {
        let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
        let matches = [];
        for (let t of subtrees) {
          let match = this.match(t);
          if (match.succeeded) {
            matches.push(match);
          }
        }
        return matches;
      }
      /**
       * Get the {@link ParseTreePatternMatcher} which created this tree pattern.
       *
       * @returns The {@link ParseTreePatternMatcher} which created this tree
       * pattern.
       */
      get matcher() {
        return this._matcher;
      }
      /**
       * Get the tree pattern in concrete syntax form.
       *
       * @returns The tree pattern in concrete syntax form.
       */
      get pattern() {
        return this._pattern;
      }
      /**
       * Get the parser rule which serves as the outermost rule for the tree
       * pattern.
       *
       * @returns The parser rule which serves as the outermost rule for the tree
       * pattern.
       */
      get patternRuleIndex() {
        return this._patternRuleIndex;
      }
      /**
       * Get the tree pattern as a {@link ParseTree}. The rule and token tags from
       * the pattern are present in the parse tree as terminal nodes with a symbol
       * of type {@link RuleTagToken} or {@link TokenTagToken}.
       *
       * @returns The tree pattern as a {@link ParseTree}.
       */
      get patternTree() {
        return this._patternTree;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_pattern", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_patternTree", void 0);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "_matcher", void 0);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "match", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "matches", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], ParseTreePattern.prototype, "findAll", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "matcher", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "pattern", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePattern.prototype, "patternTree", null);
    ParseTreePattern = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], ParseTreePattern);
    exports.ParseTreePattern = ParseTreePattern;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/RuleTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTagToken = void 0;
    var Decorators_1 = require_Decorators();
    var Token_1 = require_Token();
    var RuleTagToken = class RuleTagToken {
      /**
       * Constructs a new instance of {@link RuleTagToken} with the specified rule
       * name, bypass token type, and label.
       *
       * @param ruleName The name of the parser rule this rule tag matches.
       * @param bypassTokenType The bypass token type assigned to the parser rule.
       * @param label The label associated with the rule tag, or `undefined` if
       * the rule tag is unlabeled.
       *
       * @exception IllegalArgumentException if `ruleName` is not defined
       * or empty.
       */
      constructor(ruleName, bypassTokenType, label) {
        if (ruleName == null || ruleName.length === 0) {
          throw new Error("ruleName cannot be null or empty.");
        }
        this._ruleName = ruleName;
        this.bypassTokenType = bypassTokenType;
        this._label = label;
      }
      /**
       * Gets the name of the rule associated with this rule tag.
       *
       * @returns The name of the parser rule associated with this rule tag.
       */
      get ruleName() {
        return this._ruleName;
      }
      /**
       * Gets the label associated with the rule tag.
       *
       * @returns The name of the label associated with the rule tag, or
       * `undefined` if this is an unlabeled rule tag.
       */
      get label() {
        return this._label;
      }
      /**
       * {@inheritDoc}
       *
       * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.
       */
      get channel() {
        return Token_1.Token.DEFAULT_CHANNEL;
      }
      /**
       * {@inheritDoc}
       *
       * This method returns the rule tag formatted with `<` and `>`
       * delimiters.
       */
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._ruleName + ">";
        }
        return "<" + this._ruleName + ">";
      }
      /**
       * {@inheritDoc}
       *
       * Rule tag tokens have types assigned according to the rule bypass
       * transitions created during ATN deserialization.
       */
      get type() {
        return this.bypassTokenType;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns 0.
       */
      get line() {
        return 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get charPositionInLine() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get tokenIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get startIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns -1.
       */
      get stopIndex() {
        return -1;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns `undefined`.
       */
      get tokenSource() {
        return void 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} always returns `undefined`.
       */
      get inputStream() {
        return void 0;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link RuleTagToken} returns a string of the form
       * `ruleName:bypassTokenType`.
       */
      toString() {
        return this._ruleName + ":" + this.bypassTokenType;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], RuleTagToken.prototype, "ruleName", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "channel", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "type", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "line", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "charPositionInLine", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "startIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "stopIndex", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "tokenSource", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "inputStream", null);
    __decorate([
      Decorators_1.Override
    ], RuleTagToken.prototype, "toString", null);
    RuleTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], RuleTagToken);
    exports.RuleTagToken = RuleTagToken;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/Chunk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chunk = void 0;
    var Chunk = class {
    };
    exports.Chunk = Chunk;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TagChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TagChunk = class extends Chunk_1.Chunk {
      /**
       * Construct a new instance of {@link TagChunk} using the specified label
       * and tag.
       *
       * @param label The label for the tag. If this is `undefined`, the
       * {@link TagChunk} represents an unlabeled tag.
       * @param tag The tag, which should be the name of a parser rule or token
       * type.
       *
       * @exception IllegalArgumentException if `tag` is not defined or
       * empty.
       */
      constructor(tag, label) {
        super();
        if (tag == null || tag.length === 0) {
          throw new Error("tag cannot be null or empty");
        }
        this._tag = tag;
        this._label = label;
      }
      /**
       * Get the tag for this chunk.
       *
       * @returns The tag for the chunk.
       */
      get tag() {
        return this._tag;
      }
      /**
       * Get the label, if any, assigned to this chunk.
       *
       * @returns The label assigned to this chunk, or `undefined` if no label is
       * assigned to the chunk.
       */
      get label() {
        return this._label;
      }
      /**
       * This method returns a text representation of the tag chunk. Labeled tags
       * are returned in the form `label:tag`, and unlabeled tags are
       * returned as just the tag name.
       */
      toString() {
        if (this._label != null) {
          return this._label + ":" + this._tag;
        }
        return this._tag;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TagChunk.prototype, "tag", null);
    __decorate([
      Decorators_1.Override
    ], TagChunk.prototype, "toString", null);
    exports.TagChunk = TagChunk;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TextChunk.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextChunk = void 0;
    var Chunk_1 = require_Chunk();
    var Decorators_1 = require_Decorators();
    var TextChunk = class TextChunk extends Chunk_1.Chunk {
      /**
       * Constructs a new instance of {@link TextChunk} with the specified text.
       *
       * @param text The text of this chunk.
       * @exception IllegalArgumentException if `text` is not defined.
       */
      constructor(text) {
        super();
        if (text == null) {
          throw new Error("text cannot be null");
        }
        this._text = text;
      }
      /**
       * Gets the raw text of this chunk.
       *
       * @returns The text of the chunk.
       */
      get text() {
        return this._text;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TextChunk} returns the result of
       * `text` in single quotes.
       */
      toString() {
        return "'" + this._text + "'";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "_text", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TextChunk.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TextChunk.prototype, "toString", null);
    TextChunk = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TextChunk);
    exports.TextChunk = TextChunk;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/TokenTagToken.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenTagToken = void 0;
    var CommonToken_1 = require_CommonToken();
    var Decorators_1 = require_Decorators();
    var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
      /**
       * Constructs a new instance of {@link TokenTagToken} with the specified
       * token name, type, and label.
       *
       * @param tokenName The token name.
       * @param type The token type.
       * @param label The label associated with the token tag, or `undefined` if
       * the token tag is unlabeled.
       */
      constructor(tokenName, type, label) {
        super(type);
        this._tokenName = tokenName;
        this._label = label;
      }
      /**
       * Gets the token name.
       * @returns The token name.
       */
      get tokenName() {
        return this._tokenName;
      }
      /**
       * Gets the label associated with the rule tag.
       *
       * @returns The name of the label associated with the rule tag, or
       * `undefined` if this is an unlabeled rule tag.
       */
      get label() {
        return this._label;
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TokenTagToken} returns the token tag
       * formatted with `<` and `>` delimiters.
       */
      get text() {
        if (this._label != null) {
          return "<" + this._label + ":" + this._tokenName + ">";
        }
        return "<" + this._tokenName + ">";
      }
      /**
       * {@inheritDoc}
       *
       * The implementation for {@link TokenTagToken} returns a string of the form
       * `tokenName:type`.
       */
      toString() {
        return this._tokenName + ":" + this.type;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "_tokenName", void 0);
    __decorate([
      Decorators_1.NotNull
    ], TokenTagToken.prototype, "tokenName", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], TokenTagToken.prototype, "toString", null);
    TokenTagToken = __decorate([
      __param(0, Decorators_1.NotNull)
    ], TokenTagToken);
    exports.TokenTagToken = TokenTagToken;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseTreePatternMatcher = void 0;
    var BailErrorStrategy_1 = require_BailErrorStrategy();
    var CharStreams_1 = require_CharStreams();
    var CommonTokenStream_1 = require_CommonTokenStream();
    var ListTokenSource_1 = require_ListTokenSource();
    var MultiMap_1 = require_MultiMap();
    var Decorators_1 = require_Decorators();
    var ParseCancellationException_1 = require_ParseCancellationException();
    var ParserInterpreter_1 = require_ParserInterpreter();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var ParseTreeMatch_1 = require_ParseTreeMatch();
    var ParseTreePattern_1 = require_ParseTreePattern();
    var RecognitionException_1 = require_RecognitionException();
    var RuleNode_1 = require_RuleNode();
    var RuleTagToken_1 = require_RuleTagToken();
    var TagChunk_1 = require_TagChunk();
    var TerminalNode_1 = require_TerminalNode();
    var TextChunk_1 = require_TextChunk();
    var Token_1 = require_Token();
    var TokenTagToken_1 = require_TokenTagToken();
    var ParseTreePatternMatcher = class _ParseTreePatternMatcher {
      /**
       * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and
       * {@link Parser} object. The lexer input stream is altered for tokenizing
       * the tree patterns. The parser is used as a convenient mechanism to get
       * the grammar name, plus token, rule names.
       */
      constructor(lexer, parser) {
        this.start = "<";
        this.stop = ">";
        this.escape = "\\";
        this.escapeRE = /\\/g;
        this._lexer = lexer;
        this._parser = parser;
      }
      /**
       * Set the delimiters used for marking rule and token tags within concrete
       * syntax used by the tree pattern parser.
       *
       * @param start The start delimiter.
       * @param stop The stop delimiter.
       * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.
       *
       * @throws {@link Error} if `start` is not defined or empty.
       * @throws {@link Error} if `stop` is not defined or empty.
       */
      setDelimiters(start, stop, escapeLeft) {
        if (!start) {
          throw new Error("start cannot be null or empty");
        }
        if (!stop) {
          throw new Error("stop cannot be null or empty");
        }
        this.start = start;
        this.stop = stop;
        this.escape = escapeLeft;
        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
      }
      matches(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.matches(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return !mismatchedNode;
        }
      }
      // Implementation of match
      match(tree, pattern, patternRuleIndex = 0) {
        if (typeof pattern === "string") {
          let p = this.compile(pattern, patternRuleIndex);
          return this.match(tree, p);
        } else {
          let labels = new MultiMap_1.MultiMap();
          let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
          return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
        }
      }
      /**
       * For repeated use of a tree pattern, compile it to a
       * {@link ParseTreePattern} using this method.
       */
      compile(pattern, patternRuleIndex) {
        let tokenList = this.tokenize(pattern);
        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
        const parser = this._parser;
        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);
        let tree;
        try {
          parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
          tree = parserInterp.parse(patternRuleIndex);
        } catch (e) {
          if (e instanceof ParseCancellationException_1.ParseCancellationException) {
            throw e.getCause();
          } else if (e instanceof RecognitionException_1.RecognitionException) {
            throw e;
          } else if (e instanceof Error) {
            throw new _ParseTreePatternMatcher.CannotInvokeStartRule(e);
          } else {
            throw e;
          }
        }
        if (tokens.LA(1) !== Token_1.Token.EOF) {
          throw new _ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();
        }
        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
      }
      /**
       * Used to convert the tree pattern string into a series of tokens. The
       * input stream is reset.
       */
      get lexer() {
        return this._lexer;
      }
      /**
       * Used to collect to the grammar file name, token names, rule names for
       * used to parse the pattern into a parse tree.
       */
      get parser() {
        return this._parser;
      }
      // ---- SUPPORT CODE ----
      /**
       * Recursively walk `tree` against `patternTree`, filling
       * `match.`{@link ParseTreeMatch#labels labels}.
       *
       * @returns the first node encountered in `tree` which does not match
       * a corresponding node in `patternTree`, or `undefined` if the match
       * was successful. The specific node returned depends on the matching
       * algorithm used by the implementation, and may be overridden.
       */
      matchImpl(tree, patternTree, labels) {
        if (!tree) {
          throw new TypeError("tree cannot be null");
        }
        if (!patternTree) {
          throw new TypeError("patternTree cannot be null");
        }
        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
          let mismatchedNode;
          if (tree.symbol.type === patternTree.symbol.type) {
            if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
              let tokenTagToken = patternTree.symbol;
              labels.map(tokenTagToken.tokenName, tree);
              const l = tokenTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else if (tree.text === patternTree.text) {
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
          let mismatchedNode;
          let ruleTagToken = this.getRuleTagToken(patternTree);
          if (ruleTagToken) {
            let m;
            if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
              labels.map(ruleTagToken.ruleName, tree);
              const l = ruleTagToken.label;
              if (l) {
                labels.map(l, tree);
              }
            } else {
              if (!mismatchedNode) {
                mismatchedNode = tree;
              }
            }
            return mismatchedNode;
          }
          if (tree.childCount !== patternTree.childCount) {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
            return mismatchedNode;
          }
          let n = tree.childCount;
          for (let i = 0; i < n; i++) {
            let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
            if (childMatch) {
              return childMatch;
            }
          }
          return mismatchedNode;
        }
        return tree;
      }
      /** Is `t` `(expr <expr>)` subtree? */
      getRuleTagToken(t) {
        if (t instanceof RuleNode_1.RuleNode) {
          if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
            let c = t.getChild(0);
            if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
              return c.symbol;
            }
          }
        }
        return void 0;
      }
      tokenize(pattern) {
        let chunks = this.split(pattern);
        let tokens = [];
        for (let chunk of chunks) {
          if (chunk instanceof TagChunk_1.TagChunk) {
            let tagChunk = chunk;
            const firstChar = tagChunk.tag.substr(0, 1);
            if (firstChar === firstChar.toUpperCase()) {
              let ttype = this._parser.getTokenType(tagChunk.tag);
              if (ttype === Token_1.Token.INVALID_TYPE) {
                throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
              }
              let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
              tokens.push(t);
            } else if (firstChar === firstChar.toLowerCase()) {
              let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
              if (ruleIndex === -1) {
                throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
              }
              let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
              tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
            } else {
              throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
            }
          } else {
            let textChunk = chunk;
            this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
            let t = this._lexer.nextToken();
            while (t.type !== Token_1.Token.EOF) {
              tokens.push(t);
              t = this._lexer.nextToken();
            }
          }
        }
        return tokens;
      }
      /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */
      split(pattern) {
        let p = 0;
        let n = pattern.length;
        let chunks = [];
        let buf;
        let starts = [];
        let stops = [];
        while (p < n) {
          if (p === pattern.indexOf(this.escape + this.start, p)) {
            p += this.escape.length + this.start.length;
          } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
            p += this.escape.length + this.stop.length;
          } else if (p === pattern.indexOf(this.start, p)) {
            starts.push(p);
            p += this.start.length;
          } else if (p === pattern.indexOf(this.stop, p)) {
            stops.push(p);
            p += this.stop.length;
          } else {
            p++;
          }
        }
        if (starts.length > stops.length) {
          throw new Error("unterminated tag in pattern: " + pattern);
        }
        if (starts.length < stops.length) {
          throw new Error("missing start tag in pattern: " + pattern);
        }
        let ntags = starts.length;
        for (let i = 0; i < ntags; i++) {
          if (starts[i] >= stops[i]) {
            throw new Error("tag delimiters out of order in pattern: " + pattern);
          }
        }
        if (ntags === 0) {
          let text = pattern.substring(0, n);
          chunks.push(new TextChunk_1.TextChunk(text));
        }
        if (ntags > 0 && starts[0] > 0) {
          let text = pattern.substring(0, starts[0]);
          chunks.push(new TextChunk_1.TextChunk(text));
        }
        for (let i = 0; i < ntags; i++) {
          let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
          let ruleOrToken = tag;
          let label;
          let colon = tag.indexOf(":");
          if (colon >= 0) {
            label = tag.substring(0, colon);
            ruleOrToken = tag.substring(colon + 1, tag.length);
          }
          chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
          if (i + 1 < ntags) {
            let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
        }
        if (ntags > 0) {
          let afterLastTag = stops[ntags - 1] + this.stop.length;
          if (afterLastTag < n) {
            let text = pattern.substring(afterLastTag, n);
            chunks.push(new TextChunk_1.TextChunk(text));
          }
        }
        for (let i = 0; i < chunks.length; i++) {
          let c = chunks[i];
          if (c instanceof TextChunk_1.TextChunk) {
            let unescaped = c.text.replace(this.escapeRE, "");
            if (unescaped.length < c.text.length) {
              chunks[i] = new TextChunk_1.TextChunk(unescaped);
            }
          }
        }
        return chunks;
      }
    };
    __decorate([
      Decorators_1.NotNull,
      __param(1, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "lexer", null);
    __decorate([
      Decorators_1.NotNull
    ], ParseTreePatternMatcher.prototype, "parser", null);
    __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ParseTreePatternMatcher.prototype, "matchImpl", null);
    exports.ParseTreePatternMatcher = ParseTreePatternMatcher;
    (function(ParseTreePatternMatcher2) {
      class CannotInvokeStartRule extends Error {
        constructor(error) {
          super(`CannotInvokeStartRule: ${error}`);
          this.error = error;
        }
      }
      ParseTreePatternMatcher2.CannotInvokeStartRule = CannotInvokeStartRule;
      class StartRuleDoesNotConsumeFullPattern extends Error {
        constructor() {
          super("StartRuleDoesNotConsumeFullPattern");
        }
      }
      ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
    })(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/DecisionEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionEventInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionEventInfo = class DecisionEventInfo {
      constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
        this.decision = decision;
        this.fullCtx = fullCtx;
        this.stopIndex = stopIndex;
        this.input = input;
        this.startIndex = startIndex;
        this.state = state;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], DecisionEventInfo.prototype, "input", void 0);
    DecisionEventInfo = __decorate([
      __param(2, Decorators_1.NotNull)
    ], DecisionEventInfo);
    exports.DecisionEventInfo = DecisionEventInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AmbiguityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AmbiguityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link AmbiguityInfo} class with the
       * specified detailed ambiguity information.
       *
       * @param decision The decision number
       * @param state The final simulator state identifying the ambiguous
       * alternatives for the current input
       * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.
       *                  The predicted alt is the min(ambigAlts)
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the ambiguity was identified during
       * prediction
       */
      constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.ambigAlts = ambigAlts;
      }
      /**
       * Gets the set of alternatives in the decision that lead to a valid parse.
       *
       * @since 4.5
       */
      get ambiguousAlternatives() {
        return this.ambigAlts;
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambigAlts", void 0);
    __decorate([
      Decorators_1.NotNull
    ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
    AmbiguityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(3, Decorators_1.NotNull)
    ], AmbiguityInfo);
    exports.AmbiguityInfo = AmbiguityInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ContextSensitivityInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextSensitivityInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link ContextSensitivityInfo} class
       * with the specified detailed context sensitivity information.
       *
       * @param decision The decision number
       * @param state The final simulator state containing the unique
       * alternative identified by full-context prediction
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the context sensitivity was
       * identified during full-context prediction
       */
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, true);
      }
    };
    ContextSensitivityInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ContextSensitivityInfo);
    exports.ContextSensitivityInfo = ContextSensitivityInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/DecisionInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecisionInfo = void 0;
    var Decorators_1 = require_Decorators();
    var DecisionInfo = class {
      /**
       * Constructs a new instance of the {@link DecisionInfo} class to contain
       * statistics for a particular decision.
       *
       * @param decision The decision number
       */
      constructor(decision) {
        this.invocations = 0;
        this.timeInPrediction = 0;
        this.SLL_TotalLook = 0;
        this.SLL_MinLook = 0;
        this.SLL_MaxLook = 0;
        this.LL_TotalLook = 0;
        this.LL_MinLook = 0;
        this.LL_MaxLook = 0;
        this.contextSensitivities = [];
        this.errors = [];
        this.ambiguities = [];
        this.predicateEvals = [];
        this.SLL_ATNTransitions = 0;
        this.SLL_DFATransitions = 0;
        this.LL_Fallback = 0;
        this.LL_ATNTransitions = 0;
        this.LL_DFATransitions = 0;
        this.decision = decision;
      }
      toString() {
        return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
      }
    };
    __decorate([
      Decorators_1.Override
    ], DecisionInfo.prototype, "toString", null);
    exports.DecisionInfo = DecisionInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ErrorInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link ErrorInfo} class with the
       * specified detailed syntax error information.
       *
       * @param decision The decision number
       * @param state The final simulator state reached during prediction
       * prior to reaching the {@link ATNSimulator#ERROR} state
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the syntax error was identified
       */
      constructor(decision, state, input, startIndex, stopIndex) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
      }
    };
    ErrorInfo = __decorate([
      __param(1, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull)
    ], ErrorInfo);
    exports.ErrorInfo = ErrorInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/LookaheadEventInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LookaheadEventInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link LookaheadEventInfo} class with
       * the specified detailed lookahead information.
       *
       * @param decision The decision number
       * @param state The final simulator state containing the necessary
       * information to determine the result of a prediction, or `undefined` if
       * the final state is not available
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the prediction was finally made
       * @param fullCtx `true` if the current lookahead is part of an LL
       * prediction; otherwise, `false` if the current lookahead is part of
       * an SLL prediction
       */
      constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
        super(decision, state, input, startIndex, stopIndex, fullCtx);
        this.predictedAlt = predictedAlt;
      }
    };
    LookaheadEventInfo = __decorate([
      __param(3, Decorators_1.NotNull)
    ], LookaheadEventInfo);
    exports.LookaheadEventInfo = LookaheadEventInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/PredicateEvalInfo.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PredicateEvalInfo = void 0;
    var DecisionEventInfo_1 = require_DecisionEventInfo();
    var Decorators_1 = require_Decorators();
    var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
      /**
       * Constructs a new instance of the {@link PredicateEvalInfo} class with the
       * specified detailed predicate evaluation information.
       *
       * @param state The simulator state
       * @param decision The decision number
       * @param input The input token stream
       * @param startIndex The start index for the current prediction
       * @param stopIndex The index at which the predicate evaluation was
       * triggered. Note that the input stream may be reset to other positions for
       * the actual evaluation of individual predicates.
       * @param semctx The semantic context which was evaluated
       * @param evalResult The results of evaluating the semantic context
       * @param predictedAlt The alternative number for the decision which is
       * guarded by the semantic context `semctx`. See {@link #predictedAlt}
       * for more information.
       *
       * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)
       * @see SemanticContext#eval(Recognizer, RuleContext)
       */
      constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
        super(decision, state, input, startIndex, stopIndex, state.useContext);
        this.semctx = semctx;
        this.evalResult = evalResult;
        this.predictedAlt = predictedAlt;
      }
    };
    PredicateEvalInfo = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(2, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull)
    ], PredicateEvalInfo);
    exports.PredicateEvalInfo = PredicateEvalInfo;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/ProfilingATNSimulator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfilingATNSimulator = void 0;
    var AmbiguityInfo_1 = require_AmbiguityInfo();
    var ATN_1 = require_ATN();
    var ATNSimulator_1 = require_ATNSimulator();
    var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
    var DecisionInfo_1 = require_DecisionInfo();
    var ErrorInfo_1 = require_ErrorInfo();
    var Decorators_1 = require_Decorators();
    var LookaheadEventInfo_1 = require_LookaheadEventInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var PredicateEvalInfo_1 = require_PredicateEvalInfo();
    var SemanticContext_1 = require_SemanticContext();
    var SimulatorState_1 = require_SimulatorState();
    var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
      constructor(parser) {
        super(parser.interpreter.atn, parser);
        this._startIndex = 0;
        this._sllStopIndex = 0;
        this._llStopIndex = 0;
        this.currentDecision = 0;
        this.conflictingAltResolvedBySLL = 0;
        this.optimize_ll1 = false;
        this.reportAmbiguities = true;
        this.numDecisions = this.atn.decisionToState.length;
        this.decisions = [];
        for (let i = 0; i < this.numDecisions; i++) {
          this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
        }
      }
      adaptivePredict(input, decision, outerContext, useContext) {
        if (useContext !== void 0) {
          return super.adaptivePredict(input, decision, outerContext, useContext);
        }
        try {
          this._input = input;
          this._startIndex = input.index;
          this._sllStopIndex = this._startIndex - 1;
          this._llStopIndex = -1;
          this.currentDecision = decision;
          this.currentState = void 0;
          this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
          let start = process.hrtime();
          let alt = super.adaptivePredict(input, decision, outerContext);
          let stop = process.hrtime();
          let nanoseconds = (stop[0] - start[0]) * 1e9;
          if (nanoseconds === 0) {
            nanoseconds = stop[1] - start[1];
          } else {
            nanoseconds += 1e9 - start[1] + stop[1];
          }
          this.decisions[decision].timeInPrediction += nanoseconds;
          this.decisions[decision].invocations++;
          let SLL_k = this._sllStopIndex - this._startIndex + 1;
          this.decisions[decision].SLL_TotalLook += SLL_k;
          this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
          if (SLL_k > this.decisions[decision].SLL_MaxLook) {
            this.decisions[decision].SLL_MaxLook = SLL_k;
            this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
          }
          if (this._llStopIndex >= 0) {
            let LL_k = this._llStopIndex - this._startIndex + 1;
            this.decisions[decision].LL_TotalLook += LL_k;
            this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
            if (LL_k > this.decisions[decision].LL_MaxLook) {
              this.decisions[decision].LL_MaxLook = LL_k;
              this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
            }
          }
          return alt;
        } finally {
          this._input = void 0;
          this.currentDecision = -1;
        }
      }
      getStartState(dfa, input, outerContext, useContext) {
        let state = super.getStartState(dfa, input, outerContext, useContext);
        this.currentState = state;
        return state;
      }
      computeStartState(dfa, globalContext, useContext) {
        let state = super.computeStartState(dfa, globalContext, useContext);
        this.currentState = state;
        return state;
      }
      computeReachSet(dfa, previous, t, contextCache) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        let reachState = super.computeReachSet(dfa, previous, t, contextCache);
        if (reachState == null) {
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
        }
        this.currentState = reachState;
        return reachState;
      }
      getExistingTargetState(previousD, t) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (this.currentState.useContext) {
          this._llStopIndex = this._input.index;
        } else {
          this._sllStopIndex = this._input.index;
        }
        let existingTargetState = super.getExistingTargetState(previousD, t);
        if (existingTargetState != null) {
          this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
          if (this.currentState.useContext) {
            this.decisions[this.currentDecision].LL_DFATransitions++;
          } else {
            this.decisions[this.currentDecision].SLL_DFATransitions++;
          }
          if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
            let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
          }
        }
        return existingTargetState;
      }
      computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
        if (useContext) {
          this.decisions[this.currentDecision].LL_ATNTransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_ATNTransitions++;
        }
        return targetState;
      }
      evalSemanticContextImpl(pred, parserCallStack, alt) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
          let fullContext = this._llStopIndex >= 0;
          let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
          this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
        }
        return result;
      }
      reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
        if (this._input === void 0) {
          throw new Error("Invalid state");
        }
        if (prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
        }
        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
      }
      reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
        if (conflictingAlts != null) {
          this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
        } else {
          this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
        }
        this.decisions[this.currentDecision].LL_Fallback++;
        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
      }
      reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.currentState === void 0 || this._input === void 0) {
          throw new Error("Invalid state");
        }
        let prediction;
        if (ambigAlts != null) {
          prediction = ambigAlts.nextSetBit(0);
        } else {
          prediction = configs.getRepresentedAlternatives().nextSetBit(0);
        }
        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
          this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
        }
        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
      }
      // ---------------------------------------------------------------------
      getDecisionInfo() {
        return this.decisions;
      }
      getCurrentState() {
        return this.currentState;
      }
    };
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeStartState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeReachSet", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "computeTargetState", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
    __decorate([
      Decorators_1.Override
    ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.NotNull),
      __param(5, Decorators_1.NotNull),
      __param(6, Decorators_1.NotNull)
    ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
    exports.ProfilingATNSimulator = ProfilingATNSimulator;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/Parser.js"(exports) {
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Utils = require_Utils();
    var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
    var ATNDeserializer_1 = require_ATNDeserializer();
    var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
    var ErrorNode_1 = require_ErrorNode();
    var IntegerStack_1 = require_IntegerStack();
    var Lexer_1 = require_Lexer();
    var Decorators_1 = require_Decorators();
    var ParseInfo_1 = require_ParseInfo();
    var ParserATNSimulator_1 = require_ParserATNSimulator();
    var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
    var Recognizer_1 = require_Recognizer();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var TraceListener = class {
      constructor(ruleNames, tokenStream) {
        this.ruleNames = ruleNames;
        this.tokenStream = tokenStream;
      }
      enterEveryRule(ctx) {
        console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      exitEveryRule(ctx) {
        console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
      }
      visitErrorNode(node) {
      }
      visitTerminal(node) {
        let parent = node.parent.ruleContext;
        let token = node.symbol;
        console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
      }
    };
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "enterEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "exitEveryRule", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitErrorNode", null);
    __decorate([
      Decorators_1.Override
    ], TraceListener.prototype, "visitTerminal", null);
    var Parser = class _Parser extends Recognizer_1.Recognizer {
      constructor(input) {
        super();
        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
        this._precedenceStack = new IntegerStack_1.IntegerStack();
        this._buildParseTrees = true;
        this._parseListeners = [];
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this._precedenceStack.push(0);
        this.inputStream = input;
      }
      reset(resetInput) {
        if (resetInput === void 0 || resetInput) {
          this.inputStream.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = void 0;
        this._syntaxErrors = 0;
        this.matchedEOF = false;
        this.isTrace = false;
        this._precedenceStack.clear();
        this._precedenceStack.push(0);
        let interpreter = this.interpreter;
        if (interpreter != null) {
          interpreter.reset();
        }
      }
      /**
       * Match current input symbol against `ttype`. If the symbol type
       * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are
       * called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link #getBuildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
       *
       * @param ttype the token type to match
       * @returns the matched symbol
       * @ if the current input symbol did not match
       * `ttype` and the error strategy could not recover from the
       * mismatched symbol
       */
      match(ttype) {
        let t = this.currentToken;
        if (t.type === ttype) {
          if (ttype === Token_1.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      /**
       * Match current input symbol as a wildcard. If the symbol type matches
       * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}
       * and {@link #consume} are called to complete the match process.
       *
       * If the symbol type does not match,
       * {@link ANTLRErrorStrategy#recoverInline} is called on the current error
       * strategy to attempt recovery. If {@link #getBuildParseTree} is
       * `true` and the token index of the symbol returned by
       * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to
       * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)}.
       *
       * @returns the matched symbol
       * @ if the current input symbol did not match
       * a wildcard and the error strategy could not recover from the mismatched
       * symbol
       */
      matchWildcard() {
        let t = this.currentToken;
        if (t.type > 0) {
          this._errHandler.reportMatch(this);
          this.consume();
        } else {
          t = this._errHandler.recoverInline(this);
          if (this._buildParseTrees && t.tokenIndex === -1) {
            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
          }
        }
        return t;
      }
      /**
       * Track the {@link ParserRuleContext} objects during the parse and hook
       * them up using the {@link ParserRuleContext#children} list so that it
       * forms a parse tree. The {@link ParserRuleContext} returned from the start
       * rule represents the root of the parse tree.
       *
       * Note that if we are not building parse trees, rule contexts only point
       * upwards. When a rule exits, it returns the context but that gets garbage
       * collected if nobody holds a reference. It points upwards but nobody
       * points at it.
       *
       * When we build parse trees, we are adding all of these contexts to
       * {@link ParserRuleContext#children} list. Contexts are then not candidates
       * for garbage collection.
       */
      set buildParseTree(buildParseTrees) {
        this._buildParseTrees = buildParseTrees;
      }
      /**
       * Gets whether or not a complete parse tree will be constructed while
       * parsing. This property is `true` for a newly constructed parser.
       *
       * @returns `true` if a complete parse tree will be constructed while
       * parsing, otherwise `false`
       */
      get buildParseTree() {
        return this._buildParseTrees;
      }
      getParseListeners() {
        return this._parseListeners;
      }
      /**
       * Registers `listener` to receive events during the parsing process.
       *
       * To support output-preserving grammar transformations (including but not
       * limited to left-recursion removal, automated left-factoring, and
       * optimized code generation), calls to listener methods during the parse
       * may differ substantially from calls made by
       * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In
       * particular, rule entry and exit events may occur in a different order
       * during the parse than after the parser. In addition, calls to certain
       * rule entry methods may be omitted.
       *
       * With the following specific exceptions, calls to listener events are
       * *deterministic*, i.e. for identical input the calls to listener
       * methods will be the same.
       *
       * * Alterations to the grammar used to generate code may change the
       *   behavior of the listener calls.
       * * Alterations to the command line options passed to ANTLR 4 when
       *   generating the parser may change the behavior of the listener calls.
       * * Changing the version of the ANTLR Tool used to generate the parser
       *   may change the behavior of the listener calls.
       *
       * @param listener the listener to add
       *
       * @throws {@link TypeError} if `listener` is `undefined`
       */
      addParseListener(listener) {
        if (listener == null) {
          throw new TypeError("listener cannot be null");
        }
        this._parseListeners.push(listener);
      }
      /**
       * Remove `listener` from the list of parse listeners.
       *
       * If `listener` is `undefined` or has not been added as a parse
       * listener, this method does nothing.
       *
       * @see #addParseListener
       *
       * @param listener the listener to remove
       */
      removeParseListener(listener) {
        let index = this._parseListeners.findIndex((l) => l === listener);
        if (index !== -1) {
          this._parseListeners.splice(index, 1);
        }
      }
      /**
       * Remove all parse listeners.
       *
       * @see #addParseListener
       */
      removeParseListeners() {
        this._parseListeners.length = 0;
      }
      /**
       * Notify any parse listeners of an enter rule event.
       *
       * @see #addParseListener
       */
      triggerEnterRuleEvent() {
        for (let listener of this._parseListeners) {
          if (listener.enterEveryRule) {
            listener.enterEveryRule(this._ctx);
          }
          this._ctx.enterRule(listener);
        }
      }
      /**
       * Notify any parse listeners of an exit rule event.
       *
       * @see #addParseListener
       */
      triggerExitRuleEvent() {
        for (let i = this._parseListeners.length - 1; i >= 0; i--) {
          let listener = this._parseListeners[i];
          this._ctx.exitRule(listener);
          if (listener.exitEveryRule) {
            listener.exitEveryRule(this._ctx);
          }
        }
      }
      /**
       * Gets the number of syntax errors reported during parsing. This value is
       * incremented each time {@link #notifyErrorListeners} is called.
       *
       * @see #notifyErrorListeners
       */
      get numberOfSyntaxErrors() {
        return this._syntaxErrors;
      }
      get tokenFactory() {
        return this._input.tokenSource.tokenFactory;
      }
      /**
       * The ATN with bypass alternatives is expensive to create so we create it
       * lazily.
       *
       * @ if the current parser does not
       * implement the `serializedATN` property.
       */
      getATNWithBypassAlts() {
        let serializedAtn = this.serializedATN;
        if (serializedAtn == null) {
          throw new Error("The current parser does not support an ATN with bypass alternatives.");
        }
        let result = _Parser.bypassAltsAtnCache.get(serializedAtn);
        if (result == null) {
          let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
          deserializationOptions.isGenerateRuleBypassTransitions = true;
          result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));
          _Parser.bypassAltsAtnCache.set(serializedAtn, result);
        }
        return result;
      }
      compileParseTreePattern(pattern, patternRuleIndex, lexer) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!lexer) {
            if (this.inputStream) {
              let tokenSource = this.inputStream.tokenSource;
              if (tokenSource instanceof Lexer_1.Lexer) {
                lexer = tokenSource;
              }
            }
            if (!lexer) {
              throw new Error("Parser can't discover a lexer to use");
            }
          }
          let currentLexer = lexer;
          let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
          let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
          return matcher.compile(pattern, patternRuleIndex);
        });
      }
      get errorHandler() {
        return this._errHandler;
      }
      set errorHandler(handler) {
        this._errHandler = handler;
      }
      get inputStream() {
        return this._input;
      }
      /** Set the token stream and reset the parser. */
      set inputStream(input) {
        this.reset(false);
        this._input = input;
      }
      /** Match needs to return the current input symbol, which gets put
       *  into the label for the associated token ref; e.g., x=ID.
       */
      get currentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(msg, offendingToken, e) {
        if (offendingToken === void 0) {
          offendingToken = this.currentToken;
        } else if (offendingToken === null) {
          offendingToken = void 0;
        }
        this._syntaxErrors++;
        let line = -1;
        let charPositionInLine = -1;
        if (offendingToken != null) {
          line = offendingToken.line;
          charPositionInLine = offendingToken.charPositionInLine;
        }
        let listener = this.getErrorListenerDispatch();
        if (listener.syntaxError) {
          listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
        }
      }
      /**
       * Consume and return the [current symbol](`currentToken`).
       *
       * E.g., given the following input with `A` being the current
       * lookahead symbol, this function moves the cursor to `B` and returns
       * `A`.
       *
       * ```
       * A B
       * ^
       * ```
       *
       * If the parser is not in error recovery mode, the consumed symbol is added
       * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and
       * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.
       * If the parser *is* in error recovery mode, the consumed symbol is
       * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then
       * {@link ParserRuleContext#addErrorNode(ErrorNode)} and
       * {@link ParseTreeListener#visitErrorNode} is called on any parse
       * listeners.
       */
      consume() {
        let o = this.currentToken;
        if (o.type !== _Parser.EOF) {
          this.inputStream.consume();
        }
        let hasListener = this._parseListeners.length !== 0;
        if (this._buildParseTrees || hasListener) {
          if (this._errHandler.inErrorRecoveryMode(this)) {
            let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitErrorNode) {
                  listener.visitErrorNode(node);
                }
              }
            }
          } else {
            let node = this.createTerminalNode(this._ctx, o);
            this._ctx.addChild(node);
            if (hasListener) {
              for (let listener of this._parseListeners) {
                if (listener.visitTerminal) {
                  listener.visitTerminal(node);
                }
              }
            }
          }
        }
        return o;
      }
      /**
       * How to create a token leaf node associated with a parent.
       * Typically, the terminal node to create is not a function of the parent.
       *
       * @since 4.7
       */
      createTerminalNode(parent, t) {
        return new TerminalNode_1.TerminalNode(t);
      }
      /**
       * How to create an error node, given a token, associated with a parent.
       * Typically, the error node to create is not a function of the parent.
       *
       * @since 4.7
       */
      createErrorNode(parent, t) {
        return new ErrorNode_1.ErrorNode(t);
      }
      addContextToParseTree() {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.addChild(this._ctx);
        }
      }
      /**
       * Always called by generated parsers upon entry to a rule. Access field
       * {@link #_ctx} get the current context.
       */
      enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      enterLeftFactoredRule(localctx, state, ruleIndex) {
        this.state = state;
        if (this._buildParseTrees) {
          let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
          this._ctx.removeLastChild();
          factoredContext._parent = localctx;
          localctx.addChild(factoredContext);
        }
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        if (this._buildParseTrees) {
          this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
      }
      exitRule() {
        if (this.matchedEOF) {
          this._ctx._stop = this._input.LT(1);
        } else {
          this._ctx._stop = this._input.tryLT(-1);
        }
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx._parent;
      }
      enterOuterAlt(localctx, altNum) {
        localctx.altNumber = altNum;
        if (this._buildParseTrees && this._ctx !== localctx) {
          let parent = this._ctx._parent;
          if (parent != null) {
            parent.removeLastChild();
            parent.addChild(localctx);
          }
        }
        this._ctx = localctx;
      }
      /**
       * Get the precedence level for the top-most precedence rule.
       *
       * @returns The precedence level for the top-most precedence rule, or -1 if
       * the parser context is not nested within a precedence rule.
       */
      get precedence() {
        if (this._precedenceStack.isEmpty) {
          return -1;
        }
        return this._precedenceStack.peek();
      }
      enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx._start = this._input.LT(1);
        this.triggerEnterRuleEvent();
      }
      /** Like {@link #enterRule} but for recursive rules.
       *  Make the current context the child of the incoming localctx.
       */
      pushNewRecursionContext(localctx, state, ruleIndex) {
        let previous = this._ctx;
        previous._parent = localctx;
        previous.invokingState = state;
        previous._stop = this._input.tryLT(-1);
        this._ctx = localctx;
        this._ctx._start = previous._start;
        if (this._buildParseTrees) {
          this._ctx.addChild(previous);
        }
        this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(_parentctx) {
        this._precedenceStack.pop();
        this._ctx._stop = this._input.tryLT(-1);
        let retctx = this._ctx;
        if (this._parseListeners.length > 0) {
          while (this._ctx !== _parentctx) {
            this.triggerExitRuleEvent();
            this._ctx = this._ctx._parent;
          }
        } else {
          this._ctx = _parentctx;
        }
        retctx._parent = _parentctx;
        if (this._buildParseTrees && _parentctx != null) {
          _parentctx.addChild(retctx);
        }
      }
      getInvokingContext(ruleIndex) {
        let p = this._ctx;
        while (p && p.ruleIndex !== ruleIndex) {
          p = p._parent;
        }
        return p;
      }
      get context() {
        return this._ctx;
      }
      set context(ctx) {
        this._ctx = ctx;
      }
      precpred(localctx, precedence) {
        return precedence >= this._precedenceStack.peek();
      }
      getErrorListenerDispatch() {
        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
      }
      inContext(context) {
        return false;
      }
      /**
       * Checks whether or not `symbol` can follow the current state in the
       * ATN. The behavior of this method is equivalent to the following, but is
       * implemented such that the complete context-sensitive follow set does not
       * need to be explicitly constructed.
       *
       * ```
       * return getExpectedTokens().contains(symbol);
       * ```
       *
       * @param symbol the symbol type to check
       * @returns `true` if `symbol` can follow the current state in
       * the ATN, otherwise `false`.
       */
      isExpectedToken(symbol) {
        let atn = this.interpreter.atn;
        let ctx = this._ctx;
        let s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
          return true;
        }
        if (!following.contains(Token_1.Token.EPSILON)) {
          return false;
        }
        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
          let invokingState = atn.states[ctx.invokingState];
          let rt = invokingState.transition(0);
          following = atn.nextTokens(rt.followState);
          if (following.contains(symbol)) {
            return true;
          }
          ctx = ctx._parent;
        }
        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
          return true;
        }
        return false;
      }
      get isMatchedEOF() {
        return this.matchedEOF;
      }
      /**
       * Computes the set of input symbols which could follow the current parser
       * state and context, as given by {@link #getState} and {@link #getContext},
       * respectively.
       *
       * @see ATN#getExpectedTokens(int, RuleContext)
       */
      getExpectedTokens() {
        return this.atn.getExpectedTokens(this.state, this.context);
      }
      getExpectedTokensWithinCurrentRule() {
        let atn = this.interpreter.atn;
        let s = atn.states[this.state];
        return atn.nextTokens(s);
      }
      /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */
      getRuleIndex(ruleName) {
        let ruleIndex = this.getRuleIndexMap().get(ruleName);
        if (ruleIndex != null) {
          return ruleIndex;
        }
        return -1;
      }
      get ruleContext() {
        return this._ctx;
      }
      /** Return List&lt;String&gt; of the rule names in your parser instance
       *  leading up to a call to the current rule.  You could override if
       *  you want more details such as the file/line info of where
       *  in the ATN a rule is invoked.
       *
       *  This is very useful for error messages.
       */
      getRuleInvocationStack(ctx = this._ctx) {
        let p = ctx;
        let ruleNames = this.ruleNames;
        let stack = [];
        while (p != null) {
          let ruleIndex = p.ruleIndex;
          if (ruleIndex < 0) {
            stack.push("n/a");
          } else {
            stack.push(ruleNames[ruleIndex]);
          }
          p = p._parent;
        }
        return stack;
      }
      /** For debugging and other purposes. */
      getDFAStrings() {
        let s = [];
        for (let dfa of this._interp.atn.decisionToDFA) {
          s.push(dfa.toString(this.vocabulary, this.ruleNames));
        }
        return s;
      }
      /** For debugging and other purposes. */
      dumpDFA() {
        let seenOne = false;
        for (let dfa of this._interp.atn.decisionToDFA) {
          if (!dfa.isEmpty) {
            if (seenOne) {
              console.log();
            }
            console.log("Decision " + dfa.decision + ":");
            process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
            seenOne = true;
          }
        }
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get parseInfo() {
        return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
          let interp = this.interpreter;
          if (interp instanceof m.ProfilingATNSimulator) {
            return new ParseInfo_1.ParseInfo(interp);
          }
          return void 0;
        });
      }
      /**
       * @since 4.3
       */
      setProfile(profile) {
        return __awaiter(this, void 0, void 0, function* () {
          let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
          let interp = this.interpreter;
          if (profile) {
            if (!(interp instanceof m.ProfilingATNSimulator)) {
              this.interpreter = new m.ProfilingATNSimulator(this);
            }
          } else if (interp instanceof m.ProfilingATNSimulator) {
            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
          }
          this.interpreter.setPredictionMode(interp.getPredictionMode());
        });
      }
      /** During a parse is sometimes useful to listen in on the rule entry and exit
       *  events as well as token matches. This is for quick and dirty debugging.
       */
      set isTrace(trace) {
        if (!trace) {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
            this._tracer = void 0;
          }
        } else {
          if (this._tracer) {
            this.removeParseListener(this._tracer);
          } else {
            this._tracer = new TraceListener(this.ruleNames, this._input);
          }
          this.addParseListener(this._tracer);
        }
      }
      /**
       * Gets whether a {@link TraceListener} is registered as a parse listener
       * for the parser.
       */
      get isTrace() {
        return this._tracer != null;
      }
    };
    Parser.bypassAltsAtnCache = /* @__PURE__ */ new Map();
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "_errHandler", void 0);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "match", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "matchWildcard", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getParseListeners", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "addParseListener", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getATNWithBypassAlts", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "errorHandler", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "inputStream", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "currentToken", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Parser.prototype, "enterRule", null);
    __decorate([
      Decorators_1.Override,
      __param(0, Decorators_1.Nullable)
    ], Parser.prototype, "precpred", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "getErrorListenerDispatch", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getExpectedTokens", null);
    __decorate([
      Decorators_1.NotNull
    ], Parser.prototype, "getExpectedTokensWithinCurrentRule", null);
    __decorate([
      Decorators_1.Override
    ], Parser.prototype, "parseInfo", null);
    exports.Parser = Parser;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/tree/Trees.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Trees = void 0;
    var ATN_1 = require_ATN();
    var CommonToken_1 = require_CommonToken();
    var ErrorNode_1 = require_ErrorNode();
    var Decorators_1 = require_Decorators();
    var Parser_1 = require_Parser();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleNode_1 = require_RuleNode();
    var TerminalNode_1 = require_TerminalNode();
    var Token_1 = require_Token();
    var Utils = require_Utils();
    var Trees = class _Trees {
      static toStringTree(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else {
          ruleNames = arg2;
        }
        let s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        if (t.childCount === 0) {
          return s;
        }
        let buf = "";
        buf += "(";
        s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);
        buf += s;
        buf += " ";
        for (let i = 0; i < t.childCount; i++) {
          if (i > 0) {
            buf += " ";
          }
          buf += this.toStringTree(t.getChild(i), ruleNames);
        }
        buf += ")";
        return buf;
      }
      static getNodeText(t, arg2) {
        let ruleNames;
        if (arg2 instanceof Parser_1.Parser) {
          ruleNames = arg2.ruleNames;
        } else if (arg2) {
          ruleNames = arg2;
        } else {
          let payload = t.payload;
          if (typeof payload.text === "string") {
            return payload.text;
          }
          return t.payload.toString();
        }
        if (t instanceof RuleNode_1.RuleNode) {
          let ruleContext = t.ruleContext;
          let ruleIndex = ruleContext.ruleIndex;
          let ruleName = ruleNames[ruleIndex];
          let altNumber = ruleContext.altNumber;
          if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            return ruleName + ":" + altNumber;
          }
          return ruleName;
        } else if (t instanceof ErrorNode_1.ErrorNode) {
          return t.toString();
        } else if (t instanceof TerminalNode_1.TerminalNode) {
          let symbol = t.symbol;
          return symbol.text || "";
        }
        throw new TypeError("Unexpected node type");
      }
      static getChildren(t) {
        let kids = [];
        for (let i = 0; i < t.childCount; i++) {
          kids.push(t.getChild(i));
        }
        return kids;
      }
      static getAncestors(t) {
        let ancestors = [];
        let p = t.parent;
        while (p) {
          ancestors.unshift(p);
          p = p.parent;
        }
        return ancestors;
      }
      /** Return true if t is u's parent or a node on path to root from u.
       *  Use === not equals().
       *
       *  @since 4.5.1
       */
      static isAncestorOf(t, u) {
        if (!t || !u || !t.parent) {
          return false;
        }
        let p = u.parent;
        while (p) {
          if (t === p) {
            return true;
          }
          p = p.parent;
        }
        return false;
      }
      static findAllTokenNodes(t, ttype) {
        return _Trees.findAllNodes(t, ttype, true);
      }
      static findAllRuleNodes(t, ruleIndex) {
        return _Trees.findAllNodes(t, ruleIndex, false);
      }
      static findAllNodes(t, index, findTokens) {
        let nodes = [];
        _Trees._findAllNodes(t, index, findTokens, nodes);
        return nodes;
      }
      static _findAllNodes(t, index, findTokens, nodes) {
        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
          if (t.symbol.type === index) {
            nodes.push(t);
          }
        } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
          if (t.ruleIndex === index) {
            nodes.push(t);
          }
        }
        for (let i = 0; i < t.childCount; i++) {
          _Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
        }
      }
      /** Get all descendents; includes t itself.
       *
       * @since 4.5.1
       */
      static getDescendants(t) {
        let nodes = [];
        function recurse(e) {
          nodes.push(e);
          const n = e.childCount;
          for (let i = 0; i < n; i++) {
            recurse(e.getChild(i));
          }
        }
        recurse(t);
        return nodes;
      }
      /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex
       *  inclusively using postorder traversal.  Recursive depth-first-search.
       *
       *  @since 4.5
       */
      static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let child = t.getChild(i);
          let r = _Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
          if (r) {
            return r;
          }
        }
        if (t instanceof ParserRuleContext_1.ParserRuleContext) {
          let stopToken = t.stop;
          if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?
          (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
            return t;
          }
        }
        return void 0;
      }
      /** Replace any subtree siblings of root that are completely to left
       *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,"...")
       *  node. The source interval for t is not altered to suit smaller range!
       *
       *  WARNING: destructive to t.
       *
       *  @since 4.5.1
       */
      static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
        if (!t) {
          return;
        }
        let count = t.childCount;
        for (let i = 0; i < count; i++) {
          let child = t.getChild(i);
          let range = child.sourceInterval;
          if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
            if (_Trees.isAncestorOf(child, root)) {
              let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
              t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
            }
          }
        }
      }
      static findNodeSuchThat(t, pred) {
        if (pred(t)) {
          return t;
        }
        let n = t.childCount;
        for (let i = 0; i < n; i++) {
          let u = _Trees.findNodeSuchThat(t.getChild(i), pred);
          if (u !== void 0) {
            return u;
          }
        }
        return void 0;
      }
    };
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "toStringTree", null);
    __decorate([
      Decorators_1.NotNull,
      __param(0, Decorators_1.NotNull)
    ], Trees, "getAncestors", null);
    __decorate([
      __param(0, Decorators_1.NotNull)
    ], Trees, "getRootOfSubtreeEnclosingRegion", null);
    exports.Trees = Trees;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/RuleContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleContext = void 0;
    var ATN_1 = require_ATN();
    var Recognizer_1 = require_Recognizer();
    var RuleNode_1 = require_RuleNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var Trees_1 = require_Trees();
    var ParserRuleContext_1 = require_ParserRuleContext();
    var RuleContext = class _RuleContext extends RuleNode_1.RuleNode {
      constructor(parent, invokingState) {
        super();
        this._parent = parent;
        this.invokingState = invokingState != null ? invokingState : -1;
      }
      static getChildContext(parent, invokingState) {
        return new _RuleContext(parent, invokingState);
      }
      depth() {
        let n = 0;
        let p = this;
        while (p) {
          p = p._parent;
          n++;
        }
        return n;
      }
      /** A context is empty if there is no invoking state; meaning nobody called
       *  current context.
       */
      get isEmpty() {
        return this.invokingState === -1;
      }
      // satisfy the ParseTree / SyntaxTree interface
      get sourceInterval() {
        return Interval_1.Interval.INVALID;
      }
      get ruleContext() {
        return this;
      }
      get parent() {
        return this._parent;
      }
      /** @since 4.7. {@see ParseTree#setParent} comment */
      setParent(parent) {
        this._parent = parent;
      }
      get payload() {
        return this;
      }
      /** Return the combined text of all child nodes. This method only considers
       *  tokens which have been added to the parse tree.
       *
       *  Since tokens on hidden channels (e.g. whitespace or comments) are not
       *  added to the parse trees, they will not appear in the output of this
       *  method.
       */
      get text() {
        if (this.childCount === 0) {
          return "";
        }
        let builder = "";
        for (let i = 0; i < this.childCount; i++) {
          builder += this.getChild(i).text;
        }
        return builder.toString();
      }
      get ruleIndex() {
        return -1;
      }
      /** For rule associated with this parse tree internal node, return
       *  the outer alternative number used to match the input. Default
       *  implementation does not compute nor store this alt num. Create
       *  a subclass of ParserRuleContext with backing field and set
       *  option contextSuperClass.
       *  to set it.
       *
       *  @since 4.5.3
       */
      get altNumber() {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      /** Set the outer alternative number for this context node. Default
       *  implementation does nothing to avoid backing field overhead for
       *  trees that don't need it.  Create
       *  a subclass of ParserRuleContext with backing field and set
       *  option contextSuperClass.
       *
       *  @since 4.5.3
       */
      set altNumber(altNumber) {
      }
      getChild(i) {
        throw new RangeError("i must be greater than or equal to 0 and less than childCount");
      }
      get childCount() {
        return 0;
      }
      accept(visitor) {
        return visitor.visitChildren(this);
      }
      toStringTree(recog) {
        return Trees_1.Trees.toStringTree(this, recog);
      }
      toString(arg1, stop) {
        const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
        let buf = "";
        let p = this;
        buf += "[";
        while (p && p !== stop) {
          if (!ruleNames) {
            if (!p.isEmpty) {
              buf += p.invokingState;
            }
          } else {
            let ruleIndex = p.ruleIndex;
            let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
            buf += ruleName;
          }
          if (p._parent && (ruleNames || !p._parent.isEmpty)) {
            buf += " ";
          }
          p = p._parent;
        }
        buf += "]";
        return buf.toString();
      }
    };
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "sourceInterval", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "ruleContext", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "setParent", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "payload", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "text", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "getChild", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "accept", null);
    __decorate([
      Decorators_1.Override
    ], RuleContext.prototype, "toStringTree", null);
    exports.RuleContext = RuleContext;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/ParserRuleContext.js"(exports) {
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParserRuleContext = void 0;
    var ErrorNode_1 = require_ErrorNode();
    var Interval_1 = require_Interval();
    var Decorators_1 = require_Decorators();
    var RuleContext_1 = require_RuleContext();
    var TerminalNode_1 = require_TerminalNode();
    var ParserRuleContext = class _ParserRuleContext extends RuleContext_1.RuleContext {
      constructor(parent, invokingStateNumber) {
        if (invokingStateNumber == null) {
          super();
        } else {
          super(parent, invokingStateNumber);
        }
      }
      static emptyContext() {
        return _ParserRuleContext.EMPTY;
      }
      /**
       * COPY a ctx (I'm deliberately not using copy constructor) to avoid
       * confusion with creating node with parent. Does not copy children
       * (except error leaves).
       *
       * This is used in the generated parser code to flip a generic XContext
       * node for rule X to a YContext for alt label Y. In that sense, it is not
       * really a generic copy function.
       *
       * If we do an error sync() at start of a rule, we might add error nodes
       * to the generic XContext so this function must copy those nodes to the
       * YContext as well else they are lost!
       */
      copyFrom(ctx) {
        this._parent = ctx._parent;
        this.invokingState = ctx.invokingState;
        this._start = ctx._start;
        this._stop = ctx._stop;
        if (ctx.children) {
          this.children = [];
          for (let child of ctx.children) {
            if (child instanceof ErrorNode_1.ErrorNode) {
              this.addChild(child);
            }
          }
        }
      }
      // Double dispatch methods for listeners
      enterRule(listener) {
      }
      exitRule(listener) {
      }
      /** Add a parse tree node to this as a child.  Works for
       *  internal and leaf nodes. Does not set parent link;
       *  other add methods must do that. Other addChild methods
       *  call this.
       *
       *  We cannot set the parent pointer of the incoming node
       *  because the existing interfaces do not have a setParent()
       *  method and I don't want to break backward compatibility for this.
       *
       *  @since 4.7
       */
      addAnyChild(t) {
        if (!this.children) {
          this.children = [t];
        } else {
          this.children.push(t);
        }
        return t;
      }
      addChild(t) {
        let result;
        if (t instanceof TerminalNode_1.TerminalNode) {
          t.setParent(this);
          this.addAnyChild(t);
          return;
        } else if (t instanceof RuleContext_1.RuleContext) {
          this.addAnyChild(t);
          return;
        } else {
          t = new TerminalNode_1.TerminalNode(t);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      addErrorNode(node) {
        if (node instanceof ErrorNode_1.ErrorNode) {
          const errorNode = node;
          errorNode.setParent(this);
          return this.addAnyChild(errorNode);
        } else {
          const badToken = node;
          let t = new ErrorNode_1.ErrorNode(badToken);
          this.addAnyChild(t);
          t.setParent(this);
          return t;
        }
      }
      //	public void trace(int s) {
      //		if ( states==null ) states = new ArrayList<Integer>();
      //		states.add(s);
      //	}
      /** Used by enterOuterAlt to toss out a RuleContext previously added as
       *  we entered a rule. If we have # label, we will need to remove
       *  generic ruleContext object.
       */
      removeLastChild() {
        if (this.children) {
          this.children.pop();
        }
      }
      get parent() {
        let parent = super.parent;
        if (parent === void 0 || parent instanceof _ParserRuleContext) {
          return parent;
        }
        throw new TypeError("Invalid parent type for ParserRuleContext");
      }
      // Note: in TypeScript, order or arguments reversed
      getChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          throw new RangeError("index parameter must be between >= 0 and <= number of children.");
        }
        if (ctxType == null) {
          return this.children[i];
        }
        let result = this.tryGetChild(i, ctxType);
        if (result === void 0) {
          throw new Error("The specified node does not exist");
        }
        return result;
      }
      tryGetChild(i, ctxType) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof ctxType) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
        return void 0;
      }
      getToken(ttype, i) {
        let result = this.tryGetToken(ttype, i);
        if (result === void 0) {
          throw new Error("The specified token does not exist");
        }
        return result;
      }
      tryGetToken(ttype, i) {
        if (!this.children || i < 0 || i >= this.children.length) {
          return void 0;
        }
        let j = -1;
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              j++;
              if (j === i) {
                return o;
              }
            }
          }
        }
        return void 0;
      }
      getTokens(ttype) {
        let tokens = [];
        if (!this.children) {
          return tokens;
        }
        for (let o of this.children) {
          if (o instanceof TerminalNode_1.TerminalNode) {
            let symbol = o.symbol;
            if (symbol.type === ttype) {
              tokens.push(o);
            }
          }
        }
        return tokens;
      }
      get ruleContext() {
        return this;
      }
      // NOTE: argument order change from Java version
      getRuleContext(i, ctxType) {
        return this.getChild(i, ctxType);
      }
      tryGetRuleContext(i, ctxType) {
        return this.tryGetChild(i, ctxType);
      }
      getRuleContexts(ctxType) {
        let contexts = [];
        if (!this.children) {
          return contexts;
        }
        for (let o of this.children) {
          if (o instanceof ctxType) {
            contexts.push(o);
          }
        }
        return contexts;
      }
      get childCount() {
        return this.children ? this.children.length : 0;
      }
      get sourceInterval() {
        if (!this._start) {
          return Interval_1.Interval.INVALID;
        }
        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
          return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
        }
        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
      }
      /**
       * Get the initial token in this context.
       * Note that the range from start to stop is inclusive, so for rules that do not consume anything
       * (for example, zero length or error productions) this token may exceed stop.
       */
      get start() {
        return this._start;
      }
      /**
       * Get the final token in this context.
       * Note that the range from start to stop is inclusive, so for rules that do not consume anything
       * (for example, zero length or error productions) this token may precede start.
       */
      get stop() {
        return this._stop;
      }
      /** Used for rule context info debugging during parse-time, not so much for ATN debugging */
      toInfoString(recognizer) {
        let rules = recognizer.getRuleInvocationStack(this).reverse();
        return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
      }
    };
    ParserRuleContext.EMPTY = new ParserRuleContext();
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "parent", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "childCount", null);
    __decorate([
      Decorators_1.Override
    ], ParserRuleContext.prototype, "sourceInterval", null);
    exports.ParserRuleContext = ParserRuleContext;
  }
});

export {
  require_InputMismatchException,
  require_ATNDeserializationOptions,
  require_ActionTransition,
  require_AtomTransition,
  require_BlockStartState,
  require_BasicBlockStartState,
  require_BlockEndState,
  require_EpsilonTransition,
  require_LexerChannelAction,
  require_LexerCustomAction,
  require_LexerModeAction,
  require_LexerMoreAction,
  require_LexerPopModeAction,
  require_LexerPushModeAction,
  require_LexerSkipAction,
  require_LexerTypeAction,
  require_LoopEndState,
  require_ConflictInfo,
  require_TerminalNode,
  require_ErrorNode,
  require_RuleNode,
  require_Trees,
  require_RuleContext,
  require_ParserRuleContext,
  require_PredictionMode,
  require_SimulatorState,
  require_ParserATNSimulator,
  require_PlusBlockStartState,
  require_PlusLoopbackState,
  require_PrecedencePredicateTransition,
  require_RangeTransition,
  require_RuleStartState,
  require_StarBlockStartState,
  require_StarLoopbackState,
  require_TokensStartState,
  require_ATNDeserializer,
  require_ParseInfo,
  require_ProxyParserErrorListener,
  require_Character,
  require_CodePointBuffer,
  require_CodePointCharStream,
  require_CharStreams,
  require_BufferedTokenStream,
  require_CommonTokenStream,
  require_ListTokenSource,
  require_InterpreterRuleContext,
  require_ParserInterpreter,
  require_DecisionEventInfo,
  require_AmbiguityInfo,
  require_ContextSensitivityInfo,
  require_DecisionInfo,
  require_ErrorInfo,
  require_LookaheadEventInfo,
  require_PredicateEvalInfo,
  require_ProfilingATNSimulator,
  require_Parser,
  require_NoViableAltException,
  require_DefaultErrorStrategy,
  require_BailErrorStrategy
};
/*! Bundled license information:

antlr4ts/tree/TerminalNode.js:
antlr4ts/tree/ErrorNode.js:
antlr4ts/tree/RuleNode.js:
antlr4ts/atn/ATNDeserializationOptions.js:
antlr4ts/atn/ActionTransition.js:
antlr4ts/atn/AtomTransition.js:
antlr4ts/atn/BlockStartState.js:
antlr4ts/atn/BasicBlockStartState.js:
antlr4ts/atn/BlockEndState.js:
antlr4ts/atn/EpsilonTransition.js:
antlr4ts/atn/LexerChannelAction.js:
antlr4ts/atn/LexerCustomAction.js:
antlr4ts/atn/LexerModeAction.js:
antlr4ts/atn/LexerMoreAction.js:
antlr4ts/atn/LexerPopModeAction.js:
antlr4ts/atn/LexerPushModeAction.js:
antlr4ts/atn/LexerSkipAction.js:
antlr4ts/atn/LexerTypeAction.js:
antlr4ts/atn/LoopEndState.js:
antlr4ts/atn/ConflictInfo.js:
antlr4ts/NoViableAltException.js:
antlr4ts/atn/PredictionMode.js:
antlr4ts/atn/SimulatorState.js:
antlr4ts/atn/ParserATNSimulator.js:
antlr4ts/atn/PlusBlockStartState.js:
antlr4ts/atn/PlusLoopbackState.js:
antlr4ts/atn/PrecedencePredicateTransition.js:
antlr4ts/atn/RangeTransition.js:
antlr4ts/atn/RuleStartState.js:
antlr4ts/atn/StarBlockStartState.js:
antlr4ts/atn/StarLoopbackState.js:
antlr4ts/atn/TokensStartState.js:
antlr4ts/misc/UUID.js:
antlr4ts/atn/ATNDeserializer.js:
antlr4ts/InputMismatchException.js:
antlr4ts/DefaultErrorStrategy.js:
antlr4ts/atn/ParseInfo.js:
antlr4ts/ProxyParserErrorListener.js:
antlr4ts/misc/ParseCancellationException.js:
antlr4ts/BailErrorStrategy.js:
antlr4ts/misc/Character.js:
antlr4ts/CodePointBuffer.js:
antlr4ts/CodePointCharStream.js:
antlr4ts/CharStreams.js:
antlr4ts/BufferedTokenStream.js:
antlr4ts/CommonTokenStream.js:
antlr4ts/ListTokenSource.js:
antlr4ts/misc/MultiMap.js:
antlr4ts/InterpreterRuleContext.js:
antlr4ts/ParserInterpreter.js:
antlr4ts/tree/pattern/ParseTreeMatch.js:
antlr4ts/tree/xpath/XPathLexerErrorListener.js:
antlr4ts/tree/xpath/XPathElement.js:
antlr4ts/tree/xpath/XPathRuleAnywhereElement.js:
antlr4ts/tree/xpath/XPathRuleElement.js:
antlr4ts/tree/xpath/XPathTokenAnywhereElement.js:
antlr4ts/tree/xpath/XPathTokenElement.js:
antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js:
antlr4ts/tree/xpath/XPathWildcardElement.js:
antlr4ts/tree/xpath/XPath.js:
antlr4ts/tree/pattern/ParseTreePattern.js:
antlr4ts/tree/pattern/RuleTagToken.js:
antlr4ts/tree/pattern/Chunk.js:
antlr4ts/tree/pattern/TagChunk.js:
antlr4ts/tree/pattern/TextChunk.js:
antlr4ts/tree/pattern/TokenTagToken.js:
antlr4ts/tree/pattern/ParseTreePatternMatcher.js:
antlr4ts/atn/DecisionEventInfo.js:
antlr4ts/atn/AmbiguityInfo.js:
antlr4ts/atn/ContextSensitivityInfo.js:
antlr4ts/atn/DecisionInfo.js:
antlr4ts/atn/ErrorInfo.js:
antlr4ts/atn/LookaheadEventInfo.js:
antlr4ts/atn/PredicateEvalInfo.js:
antlr4ts/atn/ProfilingATNSimulator.js:
antlr4ts/Parser.js:
antlr4ts/tree/Trees.js:
antlr4ts/RuleContext.js:
antlr4ts/ParserRuleContext.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
//# sourceMappingURL=chunk-FXRVVXGU.js.map
