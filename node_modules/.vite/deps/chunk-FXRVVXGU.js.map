{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/TerminalNode.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/ErrorNode.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/RuleNode.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNDeserializationOptions.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ActionTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/AtomTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/BlockStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/BasicBlockStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/BlockEndState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/EpsilonTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerChannelAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerCustomAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerModeAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerMoreAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerPopModeAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerPushModeAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerSkipAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerTypeAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LoopEndState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ConflictInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/NoViableAltException.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PredictionMode.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/SimulatorState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ParserATNSimulator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PlusBlockStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PlusLoopbackState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PrecedencePredicateTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/RangeTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/RuleStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/StarBlockStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/StarLoopbackState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/TokensStartState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/UUID.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNDeserializer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/InputMismatchException.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/DefaultErrorStrategy.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ParseInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ProxyParserErrorListener.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/ParseCancellationException.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/BailErrorStrategy.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/Character.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CodePointBuffer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CodePointCharStream.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CharStreams.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/BufferedTokenStream.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CommonTokenStream.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ListTokenSource.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/MultiMap.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/InterpreterRuleContext.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ParserInterpreter.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/ParseTreeMatch.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathLexer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathLexerErrorListener.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathRuleAnywhereElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathRuleElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathTokenAnywhereElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathTokenElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathWildcardAnywhereElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPathWildcardElement.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/xpath/XPath.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/ParseTreePattern.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/RuleTagToken.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/Chunk.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/TagChunk.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/TextChunk.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/TokenTagToken.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/pattern/ParseTreePatternMatcher.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/DecisionEventInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/AmbiguityInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ContextSensitivityInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/DecisionInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ErrorInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LookaheadEventInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PredicateEvalInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ProfilingATNSimulator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/Parser.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/tree/Trees.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/RuleContext.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ParserRuleContext.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:48.1433686-07:00\r\n\r\nimport { Interval } from \"../misc/Interval\";\r\nimport { Override } from \"../Decorators\";\r\nimport { Parser } from \"../Parser\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { Token } from \"../Token\";\r\n\r\nexport class TerminalNode implements ParseTree {\r\n\tpublic _symbol: Token;\r\n\tpublic _parent: RuleNode | undefined;\r\n\r\n\tconstructor(symbol: Token) {\r\n\t\tthis._symbol = symbol;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getChild(i: number): never {\r\n\t\tthrow new RangeError(\"Terminal Node has no children.\");\r\n\t}\r\n\r\n\tget symbol(): Token {\r\n\t\treturn this._symbol;\r\n\t}\r\n\r\n\t@Override\r\n\tget parent(): RuleNode | undefined {\r\n\t\treturn this._parent;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic setParent(parent: RuleContext): void {\r\n\t\tthis._parent = parent;\r\n\t}\r\n\r\n\t@Override\r\n\tget payload(): Token {\r\n\t\treturn this._symbol;\r\n\t}\r\n\r\n\t@Override\r\n\tget sourceInterval(): Interval {\r\n\t\tlet tokenIndex: number = this._symbol.tokenIndex;\r\n\t\treturn new Interval(tokenIndex, tokenIndex);\r\n\t}\r\n\r\n\t@Override\r\n\tget childCount(): number {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\r\n\t\treturn visitor.visitTerminal(this);\r\n\t}\r\n\r\n\t@Override\r\n\tget text(): string {\r\n\t\treturn this._symbol.text || \"\";\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toStringTree(parser?: Parser): string {\r\n\t\treturn this.toString();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tif (this._symbol.type === Token.EOF) {\r\n\t\t\treturn \"<EOF>\";\r\n\t\t}\r\n\r\n\t\treturn this._symbol.text || \"\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.4646355-07:00\r\n\r\nimport { Override } from \"../Decorators\";\r\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\nimport { Token } from \"../Token\";\r\n\r\n/** Represents a token that was consumed during resynchronization\r\n *  rather than during a valid match operation. For example,\r\n *  we will create this kind of a node during single token insertion\r\n *  and deletion as well as during \"consume until error recovery set\"\r\n *  upon no viable alternative exceptions.\r\n */\r\nexport class ErrorNode extends TerminalNode {\r\n\tconstructor(token: Token) {\r\n\t\tsuper(token);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\r\n\t\treturn visitor.visitErrorNode(this);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.9232756-07:00\r\n\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\r\nimport { Parser } from \"../Parser\";\r\nimport { Interval } from \"../misc/Interval\";\r\n\r\nexport abstract class RuleNode implements ParseTree {\r\n\tpublic abstract readonly ruleContext: RuleContext;\r\n\r\n\t//@Override\r\n\tpublic abstract readonly parent: RuleNode | undefined;\r\n\r\n\tpublic abstract setParent(parent: RuleContext): void;\r\n\r\n\tpublic abstract getChild(i: number): ParseTree;\r\n\r\n\tpublic abstract accept<T>(visitor: ParseTreeVisitor<T>): T;\r\n\r\n\tpublic abstract readonly text: string;\r\n\r\n\tpublic abstract toStringTree(parser?: Parser | undefined): string;\r\n\r\n\tpublic abstract readonly sourceInterval: Interval;\r\n\r\n\tpublic abstract readonly payload: any;\r\n\r\n\tpublic abstract readonly childCount: number;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:25.8187912-07:00\r\n\r\nimport { NotNull } from \"../Decorators\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ATNDeserializationOptions {\r\n\tprivate static _defaultOptions?: ATNDeserializationOptions;\r\n\r\n\tprivate readOnly: boolean = false;\r\n\tprivate verifyATN: boolean;\r\n\tprivate generateRuleBypassTransitions: boolean;\r\n\tprivate optimize: boolean;\r\n\r\n\tconstructor(options?: ATNDeserializationOptions) {\r\n\t\tif (options) {\r\n\t\t\tthis.verifyATN = options.verifyATN;\r\n\t\t\tthis.generateRuleBypassTransitions = options.generateRuleBypassTransitions;\r\n\t\t\tthis.optimize = options.optimize;\r\n\t\t} else {\r\n\t\t\tthis.verifyATN = true;\r\n\t\t\tthis.generateRuleBypassTransitions = false;\r\n\t\t\tthis.optimize = true;\r\n\t\t}\r\n\t}\r\n\r\n\t@NotNull\r\n\tstatic get defaultOptions(): ATNDeserializationOptions {\r\n\t\tif (ATNDeserializationOptions._defaultOptions == null) {\r\n\t\t\tATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();\r\n\t\t\tATNDeserializationOptions._defaultOptions.makeReadOnly();\r\n\t\t}\r\n\r\n\t\treturn ATNDeserializationOptions._defaultOptions;\r\n\t}\r\n\r\n\tget isReadOnly(): boolean {\r\n\t\treturn this.readOnly;\r\n\t}\r\n\r\n\tpublic makeReadOnly(): void {\r\n\t\tthis.readOnly = true;\r\n\t}\r\n\r\n\tget isVerifyATN(): boolean {\r\n\t\treturn this.verifyATN;\r\n\t}\r\n\r\n\tset isVerifyATN(verifyATN: boolean) {\r\n\t\tthis.throwIfReadOnly();\r\n\t\tthis.verifyATN = verifyATN;\r\n\t}\r\n\r\n\tget isGenerateRuleBypassTransitions(): boolean {\r\n\t\treturn this.generateRuleBypassTransitions;\r\n\t}\r\n\r\n\tset isGenerateRuleBypassTransitions(generateRuleBypassTransitions: boolean) {\r\n\t\tthis.throwIfReadOnly();\r\n\t\tthis.generateRuleBypassTransitions = generateRuleBypassTransitions;\r\n\t}\r\n\r\n\tget isOptimize(): boolean {\r\n\t\treturn this.optimize;\r\n\t}\r\n\r\n\tset isOptimize(optimize: boolean) {\r\n\t\tthis.throwIfReadOnly();\r\n\t\tthis.optimize = optimize;\r\n\t}\r\n\r\n\tprotected throwIfReadOnly(): void {\r\n\t\tif (this.isReadOnly) {\r\n\t\t\tthrow new Error(\"The object is read only.\");\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:24.7363448-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\nexport class ActionTransition extends Transition {\r\n\tpublic ruleIndex: number;\r\n\tpublic actionIndex: number;\r\n\tpublic isCtxDependent: boolean;  // e.g., $i ref in action\r\n\r\n\tconstructor(@NotNull target: ATNState, ruleIndex: number, actionIndex: number = -1, isCtxDependent: boolean = false) {\r\n\t\tsuper(target);\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t\tthis.actionIndex = actionIndex;\r\n\t\tthis.isCtxDependent = isCtxDependent;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.ACTION;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEpsilon(): boolean {\r\n\t\treturn true; // we are to be ignored by analysis 'cept for predicates\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"action_\" + this.ruleIndex + \":\" + this.actionIndex;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.6769122-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/** TODO: make all transitions sets? no, should remove set edges */\r\nexport class AtomTransition extends Transition {\r\n\t/** The token type or character value; or, signifies special label. */\r\n\tpublic _label: number;\r\n\r\n\tconstructor(@NotNull target: ATNState, label: number) {\r\n\t\tsuper(target);\r\n\t\tthis._label = label;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.ATOM;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tget label(): IntervalSet {\r\n\t\treturn IntervalSet.of(this._label);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn this._label === symbol;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn String(this.label);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.9930394-07:00\r\n\r\nimport { BlockEndState } from \"./BlockEndState\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/**  The start of a regular `(...)` block. */\r\nexport abstract class BlockStartState extends DecisionState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic endState!: BlockEndState;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.7669801-07:00\r\n\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BlockStartState } from \"./BlockStartState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class BasicBlockStartState extends BlockStartState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.BLOCK_START;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.9125304-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BlockStartState } from \"./BlockStartState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** Terminal node of a simple `(a|b|c)` block. */\r\nexport class BlockEndState extends ATNState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic startState!: BlockStartState;\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.BLOCK_END;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.6283213-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\nexport class EpsilonTransition extends Transition {\r\n\r\n\tprivate _outermostPrecedenceReturn: number;\r\n\r\n\tconstructor(@NotNull target: ATNState, outermostPrecedenceReturn: number = -1) {\r\n\t\tsuper(target);\r\n\t\tthis._outermostPrecedenceReturn = outermostPrecedenceReturn;\r\n\t}\r\n\r\n\t/**\r\n\t * @returns the rule index of a precedence rule for which this transition is\r\n\t * returning from, where the precedence value is 0; otherwise, -1.\r\n\t *\r\n\t * @see ATNConfig.isPrecedenceFilterSuppressed\r\n\t * @see ParserATNSimulator#applyPrecedenceFilter(ATNConfigSet, ParserRuleContext, PredictionContextCache)\r\n\t * @since 4.4.1\r\n\t */\r\n\tget outermostPrecedenceReturn(): number {\r\n\t\treturn this._outermostPrecedenceReturn;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.EPSILON;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEpsilon(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn \"epsilon\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.5634388-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `channel` lexer action by calling\r\n * {@link Lexer#setChannel} with the assigned channel.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerChannelAction implements LexerAction {\r\n\tprivate readonly _channel: number;\r\n\r\n\t/**\r\n\t * Constructs a new `channel` action with the specified channel value.\r\n\t * @param channel The channel value to pass to {@link Lexer#setChannel}.\r\n\t */\r\n\tconstructor(channel: number) {\r\n\t\tthis._channel = channel;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the channel to use for the {@link Token} created by the lexer.\r\n\t *\r\n\t * @returns The channel to use for the {@link Token} created by the lexer.\r\n\t */\r\n\tget channel(): number {\r\n\t\treturn this._channel;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#CHANNEL}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.CHANNEL;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#setChannel} with the\r\n\t * value provided by {@link #getChannel}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.channel = this._channel;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\thash = MurmurHash.update(hash, this._channel);\r\n\t\treturn MurmurHash.finish(hash, 2);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerChannelAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._channel === obj._channel;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn `channel(${this._channel})`;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.6567992-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Executes a custom lexer action by calling {@link Recognizer#action} with the\r\n * rule and action indexes assigned to the custom action. The implementation of\r\n * a custom action is added to the generated code for the lexer in an override\r\n * of {@link Recognizer#action} when the grammar is compiled.\r\n *\r\n * This class may represent embedded actions created with the `{...}`\r\n * syntax in ANTLR 4, as well as actions created for lexer commands where the\r\n * command argument could not be evaluated when the grammar was compiled.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerCustomAction implements LexerAction {\r\n\tprivate readonly _ruleIndex: number;\r\n\tprivate readonly _actionIndex: number;\r\n\r\n\t/**\r\n\t * Constructs a custom lexer action with the specified rule and action\r\n\t * indexes.\r\n\t *\r\n\t * @param ruleIndex The rule index to use for calls to\r\n\t * {@link Recognizer#action}.\r\n\t * @param actionIndex The action index to use for calls to\r\n\t * {@link Recognizer#action}.\r\n\t */\r\n\tconstructor(ruleIndex: number, actionIndex: number) {\r\n\t\tthis._ruleIndex = ruleIndex;\r\n\t\tthis._actionIndex = actionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the rule index to use for calls to {@link Recognizer#action}.\r\n\t *\r\n\t * @returns The rule index for the custom action.\r\n\t */\r\n\tget ruleIndex(): number {\r\n\t\treturn this._ruleIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the action index to use for calls to {@link Recognizer#action}.\r\n\t *\r\n\t * @returns The action index for the custom action.\r\n\t */\r\n\tget actionIndex(): number {\r\n\t\treturn this._actionIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * @returns This method returns {@link LexerActionType#CUSTOM}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.CUSTOM;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether the lexer action is position-dependent. Position-dependent\r\n\t * actions may have different semantics depending on the {@link CharStream}\r\n\t * index at the time the action is executed.\r\n\t *\r\n\t * Custom actions are position-dependent since they may represent a\r\n\t * user-defined embedded action which makes calls to methods like\r\n\t * {@link Lexer#getText}.\r\n\t *\r\n\t * @returns This method returns `true`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * Custom actions are implemented by calling {@link Lexer#action} with the\r\n\t * appropriate rule and action indexes.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.action(undefined, this._ruleIndex, this._actionIndex);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\thash = MurmurHash.update(hash, this._ruleIndex);\r\n\t\thash = MurmurHash.update(hash, this._actionIndex);\r\n\t\treturn MurmurHash.finish(hash, 3);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerCustomAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._ruleIndex === obj._ruleIndex\r\n\t\t\t&& this._actionIndex === obj._actionIndex;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.8653427-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `mode` lexer action by calling {@link Lexer#mode} with\r\n * the assigned mode.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerModeAction implements LexerAction {\r\n\tprivate readonly _mode: number;\r\n\r\n\t/**\r\n\t * Constructs a new `mode` action with the specified mode value.\r\n\t * @param mode The mode value to pass to {@link Lexer#mode}.\r\n\t */\r\n\tconstructor(mode: number) {\r\n\t\tthis._mode = mode;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the lexer mode this action should transition the lexer to.\r\n\t *\r\n\t * @returns The lexer mode for this `mode` command.\r\n\t */\r\n\tget mode(): number {\r\n\t\treturn this._mode;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#MODE}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.MODE;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#mode} with the\r\n\t * value provided by {@link #getMode}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.mode(this._mode);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\thash = MurmurHash.update(hash, this._mode);\r\n\t\treturn MurmurHash.finish(hash, 2);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerModeAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._mode === obj._mode;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn `mode(${this._mode})`;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.9613221-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `more` lexer action by calling {@link Lexer#more}.\r\n *\r\n * The `more` command does not have any parameters, so this action is\r\n * implemented as a singleton instance exposed by {@link #INSTANCE}.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerMoreAction implements LexerAction {\r\n\t/**\r\n\t * Constructs the singleton instance of the lexer `more` command.\r\n\t */\r\n\tconstructor() {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#MORE}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.MORE;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#more}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.more();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\treturn MurmurHash.finish(hash, 1);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\treturn obj === this;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"more\";\r\n\t}\r\n}\r\n\r\nexport namespace LexerMoreAction {\r\n\t/**\r\n\t * Provides a singleton instance of this parameterless lexer action.\r\n\t */\r\n\texport const INSTANCE: LexerMoreAction = new LexerMoreAction();\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.0449220-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `popMode` lexer action by calling {@link Lexer#popMode}.\r\n *\r\n * The `popMode` command does not have any parameters, so this action is\r\n * implemented as a singleton instance exposed by {@link #INSTANCE}.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerPopModeAction implements LexerAction {\r\n\t/**\r\n\t * Constructs the singleton instance of the lexer `popMode` command.\r\n\t */\r\n\tconstructor() {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#POP_MODE}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.POP_MODE;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#popMode}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.popMode();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\treturn MurmurHash.finish(hash, 1);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\treturn obj === this;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"popMode\";\r\n\t}\r\n}\r\n\r\nexport namespace LexerPopModeAction {\r\n\t/**\r\n\t * Provides a singleton instance of this parameterless lexer action.\r\n\t */\r\n\texport const INSTANCE: LexerPopModeAction = new LexerPopModeAction();\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.1378801-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `pushMode` lexer action by calling\r\n * {@link Lexer#pushMode} with the assigned mode.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerPushModeAction implements LexerAction {\r\n\tprivate readonly _mode: number;\r\n\r\n\t/**\r\n\t * Constructs a new `pushMode` action with the specified mode value.\r\n\t * @param mode The mode value to pass to {@link Lexer#pushMode}.\r\n\t */\r\n\tconstructor(mode: number) {\r\n\t\tthis._mode = mode;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the lexer mode this action should transition the lexer to.\r\n\t *\r\n\t * @returns The lexer mode for this `pushMode` command.\r\n\t */\r\n\tget mode(): number {\r\n\t\treturn this._mode;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#PUSH_MODE}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.PUSH_MODE;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#pushMode} with the\r\n\t * value provided by {@link #getMode}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.pushMode(this._mode);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\thash = MurmurHash.update(hash, this._mode);\r\n\t\treturn MurmurHash.finish(hash, 2);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerPushModeAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._mode === obj._mode;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn `pushMode(${this._mode})`;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.2324460-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `skip` lexer action by calling {@link Lexer#skip}.\r\n *\r\n * The `skip` command does not have any parameters, so this action is\r\n * implemented as a singleton instance exposed by {@link #INSTANCE}.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerSkipAction implements LexerAction {\r\n\t/**\r\n\t * Constructs the singleton instance of the lexer `skip` command.\r\n\t */\r\n\tconstructor() {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#SKIP}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.SKIP;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by calling {@link Lexer#skip}.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.skip();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\treturn MurmurHash.finish(hash, 1);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\treturn obj === this;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"skip\";\r\n\t}\r\n}\r\n\r\nexport namespace LexerSkipAction {\r\n\t/**\r\n\t * Provides a singleton instance of this parameterless lexer action.\r\n\t */\r\n\texport const INSTANCE: LexerSkipAction = new LexerSkipAction();\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.3204839-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Implements the `type` lexer action by setting `Lexer.type`\r\n * with the assigned type.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerTypeAction implements LexerAction {\r\n\tprivate readonly _type: number;\r\n\r\n\t/**\r\n\t * Constructs a new `type` action with the specified token type value.\r\n\t * @param type The type to assign to the token using `Lexer.type`.\r\n\t */\r\n\tconstructor(type: number) {\r\n\t\tthis._type = type;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the type to assign to a token created by the lexer.\r\n\t * @returns The type to assign to a token created by the lexer.\r\n\t */\r\n\tget type(): number {\r\n\t\treturn this._type;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns {@link LexerActionType#TYPE}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn LexerActionType.TYPE;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `false`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This action is implemented by setting `Lexer.type` with the\r\n\t * value provided by `type`.\r\n\t */\r\n\t@Override\r\n\tpublic execute(@NotNull lexer: Lexer): void {\r\n\t\tlexer.type = this._type;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this.actionType);\r\n\t\thash = MurmurHash.update(hash, this._type);\r\n\t\treturn MurmurHash.finish(hash, 2);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerTypeAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._type === obj._type;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn `type(${this._type})`;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.7737978-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** Mark the end of a * or + loop. */\r\nexport class LoopEndState extends ATNState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic loopBackState!: ATNState;\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.LOOP_END;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.0710131-07:00\r\n\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { Override } from \"../Decorators\";\r\nimport * as Utils from \"../misc/Utils\";\r\n\r\n/**\r\n * This class stores information about a configuration conflict.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ConflictInfo {\r\n\tprivate _conflictedAlts: BitSet;\r\n\r\n\tprivate exact: boolean;\r\n\r\n\tconstructor(conflictedAlts: BitSet, exact: boolean) {\r\n\t\tthis._conflictedAlts = conflictedAlts;\r\n\t\tthis.exact = exact;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the set of conflicting alternatives for the configuration set.\r\n\t */\r\n\tget conflictedAlts(): BitSet {\r\n\t\treturn this._conflictedAlts;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether or not the configuration conflict is an exact conflict.\r\n\t * An exact conflict occurs when the prediction algorithm determines that\r\n\t * the represented alternatives for a particular configuration set cannot be\r\n\t * further reduced by consuming additional input. After reaching an exact\r\n\t * conflict during an SLL prediction, only switch to full-context prediction\r\n\t * could reduce the set of viable alternatives. In LL prediction, an exact\r\n\t * conflict indicates a true ambiguity in the input.\r\n\t *\r\n\t * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,\r\n\t * accept states are conflicting but not exact are treated as non-accept\r\n\t * states.\r\n\t */\r\n\tget isExact(): boolean {\r\n\t\treturn this.exact;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof ConflictInfo)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.isExact === obj.isExact\r\n\t\t\t&& Utils.equals(this.conflictedAlts, obj.conflictedAlts);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\treturn this.conflictedAlts.hashCode();\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:52.3255548-07:00\r\n\r\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenStream } from \"./TokenStream\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { NotNull } from \"./Decorators\";\r\n\r\n/** Indicates that the parser could not decide which of two or more paths\r\n *  to take based upon the remaining input. It tracks the starting token\r\n *  of the offending input and also knows where the parser was\r\n *  in the various paths when the error. Reported by reportNoViableAlternative()\r\n */\r\nexport class NoViableAltException extends RecognitionException {\r\n\t//private static serialVersionUID: number =  5096000008992867052L;\r\n\r\n\t/** Which configurations did we try at input.index that couldn't match input.LT(1)? */\r\n\tprivate _deadEndConfigs?: ATNConfigSet;\r\n\r\n\t/** The token object at the start index; the input stream might\r\n\t * \tnot be buffering tokens so get a reference to it. (At the\r\n\t *  time the error occurred, of course the stream needs to keep a\r\n\t *  buffer all of the tokens but later we might not have access to those.)\r\n\t */\r\n\t@NotNull\r\n\tprivate _startToken: Token;\r\n\r\n\tconstructor(/*@NotNull*/ recognizer: Parser);\r\n\tconstructor(\r\n\t\t/*@NotNull*/\r\n\t\trecognizer: Recognizer<Token, any>,\r\n\t\t/*@NotNull*/\r\n\t\tinput: TokenStream,\r\n\t\t/*@NotNull*/\r\n\t\tstartToken: Token,\r\n\t\t/*@NotNull*/\r\n\t\toffendingToken: Token,\r\n\t\tdeadEndConfigs: ATNConfigSet | undefined,\r\n\t\t/*@NotNull*/\r\n\t\tctx: ParserRuleContext);\r\n\r\n\tconstructor(\r\n\t\trecognizer: Recognizer<Token, any>,\r\n\t\tinput?: TokenStream,\r\n\t\tstartToken?: Token,\r\n\t\toffendingToken?: Token,\r\n\t\tdeadEndConfigs?: ATNConfigSet,\r\n\t\tctx?: ParserRuleContext) {\r\n\t\tif (recognizer instanceof Parser) {\r\n\t\t\tif (input === undefined) {\r\n\t\t\t\tinput = recognizer.inputStream;\r\n\t\t\t}\r\n\r\n\t\t\tif (startToken === undefined) {\r\n\t\t\t\tstartToken = recognizer.currentToken;\r\n\t\t\t}\r\n\r\n\t\t\tif (offendingToken === undefined) {\r\n\t\t\t\toffendingToken = recognizer.currentToken;\r\n\t\t\t}\r\n\r\n\t\t\tif (ctx === undefined) {\r\n\t\t\t\tctx = recognizer.context;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper(recognizer, input, ctx);\r\n\t\tthis._deadEndConfigs = deadEndConfigs;\r\n\t\tthis._startToken = startToken as Token;\r\n\t\tthis.setOffendingToken(recognizer, offendingToken);\r\n\t}\r\n\r\n\tget startToken(): Token {\r\n\t\treturn this._startToken;\r\n\t}\r\n\r\n\tget deadEndConfigs(): ATNConfigSet | undefined {\r\n\t\treturn this._deadEndConfigs;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.2673893-07:00\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { Override } from \"../Decorators\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\n\r\n/**\r\n * This enumeration defines the prediction modes available in ANTLR 4 along with\r\n * utility methods for analyzing configuration sets for conflicts and/or\r\n * ambiguities.\r\n */\r\nexport enum PredictionMode {\r\n\t/**\r\n\t * The SLL(*) prediction mode. This prediction mode ignores the current\r\n\t * parser context when making predictions. This is the fastest prediction\r\n\t * mode, and provides correct results for many grammars. This prediction\r\n\t * mode is more powerful than the prediction mode provided by ANTLR 3, but\r\n\t * may result in syntax errors for grammar and input combinations which are\r\n\t * not SLL.\r\n\t *\r\n\t * When using this prediction mode, the parser will either return a correct\r\n\t * parse tree (i.e. the same parse tree that would be returned with the\r\n\t * {@link #LL} prediction mode), or it will report a syntax error. If a\r\n\t * syntax error is encountered when using the {@link #SLL} prediction mode,\r\n\t * it may be due to either an actual syntax error in the input or indicate\r\n\t * that the particular combination of grammar and input requires the more\r\n\t * powerful {@link #LL} prediction abilities to complete successfully.\r\n\t *\r\n\t * This prediction mode does not provide any guarantees for prediction\r\n\t * behavior for syntactically-incorrect inputs.\r\n\t */\r\n\tSLL,\r\n\t/**\r\n\t * The LL(*) prediction mode. This prediction mode allows the current parser\r\n\t * context to be used for resolving SLL conflicts that occur during\r\n\t * prediction. This is the fastest prediction mode that guarantees correct\r\n\t * parse results for all combinations of grammars with syntactically correct\r\n\t * inputs.\r\n\t *\r\n\t * When using this prediction mode, the parser will make correct decisions\r\n\t * for all syntactically-correct grammar and input combinations. However, in\r\n\t * cases where the grammar is truly ambiguous this prediction mode might not\r\n\t * report a precise answer for *exactly which* alternatives are\r\n\t * ambiguous.\r\n\t *\r\n\t * This prediction mode does not provide any guarantees for prediction\r\n\t * behavior for syntactically-incorrect inputs.\r\n\t */\r\n\tLL,\r\n\t/**\r\n\t * The LL(*) prediction mode with exact ambiguity detection. In addition to\r\n\t * the correctness guarantees provided by the {@link #LL} prediction mode,\r\n\t * this prediction mode instructs the prediction algorithm to determine the\r\n\t * complete and exact set of ambiguous alternatives for every ambiguous\r\n\t * decision encountered while parsing.\r\n\t *\r\n\t * This prediction mode may be used for diagnosing ambiguities during\r\n\t * grammar development. Due to the performance overhead of calculating sets\r\n\t * of ambiguous alternatives, this prediction mode should be avoided when\r\n\t * the exact results are not necessary.\r\n\t *\r\n\t * This prediction mode does not provide any guarantees for prediction\r\n\t * behavior for syntactically-incorrect inputs.\r\n\t */\r\n\tLL_EXACT_AMBIG_DETECTION,\r\n}\r\n\r\nexport namespace PredictionMode {\r\n\t/** A Map that uses just the state and the stack context as the key. */\r\n\t// NOTE: Base type used to be FlexibleHashMap<ATNConfig, BitSet>\r\n\tclass AltAndContextMap extends Array2DHashMap<ATNConfig, BitSet> {\r\n\t\tconstructor() {\r\n\t\t\tsuper(AltAndContextConfigEqualityComparator.INSTANCE);\r\n\t\t}\r\n\t}\r\n\r\n\tclass AltAndContextConfigEqualityComparator implements EqualityComparator<ATNConfig> {\r\n\t\tpublic static readonly INSTANCE: AltAndContextConfigEqualityComparator = new AltAndContextConfigEqualityComparator();\r\n\r\n\t\tprivate AltAndContextConfigEqualityComparator() {\r\n\t\t\t// intentionally empty\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * The hash code is only a function of the {@link ATNState#stateNumber}\r\n\t\t * and {@link ATNConfig#context}.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic hashCode(o: ATNConfig): number {\r\n\t\t\tlet hashCode: number = MurmurHash.initialize(7);\r\n\t\t\thashCode = MurmurHash.update(hashCode, o.state.stateNumber);\r\n\t\t\thashCode = MurmurHash.update(hashCode, o.context);\r\n\t\t\thashCode = MurmurHash.finish(hashCode, 2);\r\n\t\t\treturn hashCode;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(a: ATNConfig, b: ATNConfig): boolean {\r\n\t\t\tif (a === b) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (a == null || b == null) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn a.state.stateNumber === b.state.stateNumber\r\n\t\t\t\t&& a.context.equals(b.context);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if any configuration in `configs` is in a\r\n\t * {@link RuleStopState}. Configurations meeting this condition have reached\r\n\t * the end of the decision rule (local context) or end of start rule (full\r\n\t * context).\r\n\t *\r\n\t * @param configs the configuration set to test\r\n\t * @returns `true` if any configuration in `configs` is in a\r\n\t * {@link RuleStopState}, otherwise `false`\r\n\t */\r\n\texport function hasConfigInRuleStopState(configs: ATNConfigSet): boolean {\r\n\t\tfor (let c of configs) {\r\n\t\t\tif (c.state instanceof RuleStopState) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if all configurations in `configs` are in a\r\n\t * {@link RuleStopState}. Configurations meeting this condition have reached\r\n\t * the end of the decision rule (local context) or end of start rule (full\r\n\t * context).\r\n\t *\r\n\t * @param configs the configuration set to test\r\n\t * @returns `true` if all configurations in `configs` are in a\r\n\t * {@link RuleStopState}, otherwise `false`\r\n\t */\r\n\texport function allConfigsInRuleStopStates(/*@NotNull*/ configs: ATNConfigSet): boolean {\r\n\t\tfor (let config of configs) {\r\n\t\t\tif (!(config.state instanceof RuleStopState)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.3871984-07:00\r\n\r\nimport { DFAState } from \"../dfa/DFAState\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class SimulatorState {\r\n\tpublic outerContext: ParserRuleContext;\r\n\r\n\tpublic s0: DFAState;\r\n\r\n\tpublic useContext: boolean;\r\n\tpublic remainingOuterContext: ParserRuleContext | undefined;\r\n\r\n\tconstructor(outerContext: ParserRuleContext, @NotNull s0: DFAState, useContext: boolean, remainingOuterContext: ParserRuleContext | undefined) {\r\n\t\tthis.outerContext = outerContext != null ? outerContext : ParserRuleContext.emptyContext();\r\n\t\tthis.s0 = s0;\r\n\t\tthis.useContext = useContext;\r\n\t\tthis.remainingOuterContext = remainingOuterContext;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:31.1989835-07:00\r\n\r\nimport { AcceptStateInfo } from \"../dfa/AcceptStateInfo\";\r\nimport { ActionTransition } from \"./ActionTransition\";\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { Arrays } from \"../misc/Arrays\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { ATNSimulator } from \"./ATNSimulator\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { AtomTransition } from \"./AtomTransition\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { ConflictInfo } from \"./ConflictInfo\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { DFAState } from \"../dfa/DFAState\";\r\nimport { EpsilonTransition } from \"./EpsilonTransition\";\r\nimport { IntegerList } from \"../misc/IntegerList\";\r\nimport { Interval } from \"../misc/Interval\";\r\nimport { IntStream } from \"../IntStream\";\r\nimport { NotNull, Nullable, Override } from \"../Decorators\";\r\nimport { NotSetTransition } from \"./NotSetTransition\";\r\nimport { NoViableAltException } from \"../NoViableAltException\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { Parser } from \"../Parser\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\nimport { PrecedencePredicateTransition } from \"./PrecedencePredicateTransition\";\r\nimport { PredicateTransition } from \"./PredicateTransition\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { PredictionContextCache } from \"./PredictionContextCache\";\r\nimport { PredictionMode } from \"./PredictionMode\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\nimport { SetTransition } from \"./SetTransition\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { StarLoopEntryState } from \"./StarLoopEntryState\";\r\nimport { Token } from \"../Token\";\r\nimport { TokenStream } from \"../TokenStream\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\nimport { Vocabulary } from \"../Vocabulary\";\r\nimport { VocabularyImpl } from \"../VocabularyImpl\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\nconst MAX_SHORT_VALUE = 0xFFFF;\r\nconst MIN_INTEGER_VALUE = -((1 << 31) >>> 0);\r\n\r\n/**\r\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\r\n *\r\n * The basic complexity of the adaptive strategy makes it harder to understand.\r\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\r\n * requests go through the DFA first. If they reach a state without an edge for\r\n * the current symbol, the algorithm fails over to the ATN simulation to\r\n * complete the DFA path for the current input (until it finds a conflict state\r\n * or uniquely predicting state).\r\n *\r\n * All of that is done without using the outer context because we want to create\r\n * a DFA that is not dependent upon the rule invocation stack when we do a\r\n * prediction. One DFA works in all contexts. We avoid using context not\r\n * necessarily because it's slower, although it can be, but because of the DFA\r\n * caching problem. The closure routine only considers the rule invocation stack\r\n * created during prediction beginning in the decision rule. For example, if\r\n * prediction occurs without invoking another rule's ATN, there are no context\r\n * stacks in the configurations. When lack of context leads to a conflict, we\r\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\r\n * strategy (versus full LL(*)).\r\n *\r\n * When SLL yields a configuration set with conflict, we rewind the input and\r\n * retry the ATN simulation, this time using full outer context without adding\r\n * to the DFA. Configuration context stacks will be the full invocation stacks\r\n * from the start rule. If we get a conflict using full context, then we can\r\n * definitively say we have a true ambiguity for that input sequence. If we\r\n * don't get a conflict, it implies that the decision is sensitive to the outer\r\n * context. (It is not context-sensitive in the sense of context-sensitive\r\n * grammars.)\r\n *\r\n * The next time we reach this DFA state with an SLL conflict, through DFA\r\n * simulation, we will again retry the ATN simulation using full context mode.\r\n * This is slow because we can't save the results and have to \"interpret\" the\r\n * ATN each time we get that input.\r\n *\r\n * **CACHING FULL CONTEXT PREDICTIONS**\r\n *\r\n * We could cache results from full context to predicted alternative easily and\r\n * that saves a lot of time but doesn't work in presence of predicates. The set\r\n * of visible predicates from the ATN start state changes depending on the\r\n * context, because closure can fall off the end of a rule. I tried to cache\r\n * tuples (stack context, semantic context, predicted alt) but it was slower\r\n * than interpreting and much more complicated. Also required a huge amount of\r\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\r\n * to keep this algorithm simple. By launching multiple threads, we can improve\r\n * the speed of parsing across a large number of files.\r\n *\r\n * There is no strict ordering between the amount of input used by SLL vs LL,\r\n * which makes it really hard to build a cache for full context. Let's say that\r\n * we have input A B C that leads to an SLL conflict with full context X. That\r\n * implies that using X we might only use A B but we could also use A B C D to\r\n * resolve conflict. Input A B C D could predict alternative 1 in one position\r\n * in the input and A B C E could predict alternative 2 in another position in\r\n * input. The conflicting SLL configurations could still be non-unique in the\r\n * full context prediction, which would lead us to requiring more input than the\r\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\r\n * input\tused during the previous prediction. That amounts to a cache that maps\r\n * X to a specific DFA for that context.\r\n *\r\n * Something should be done for left-recursive expression predictions. They are\r\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\r\n * with full LL thing Sam does.\r\n *\r\n * **AVOIDING FULL CONTEXT PREDICTION**\r\n *\r\n * We avoid doing full context retry when the outer context is empty, we did not\r\n * dip into the outer context by falling off the end of the decision state rule,\r\n * or when we force SLL mode.\r\n *\r\n * As an example of the not dip into outer context case, consider as super\r\n * constructor calls versus function calls. One grammar might look like\r\n * this:\r\n *\r\n * ```antlr\r\n * ctorBody\r\n *   : '{' superCall? stat* '}'\r\n *   ;\r\n * ```\r\n *\r\n * Or, you might see something like\r\n *\r\n * ```antlr\r\n * stat\r\n *   : superCall ';'\r\n *   | expression ';'\r\n *   | ...\r\n *   ;\r\n * ```\r\n *\r\n * In both cases I believe that no closure operations will dip into the outer\r\n * context. In the first case ctorBody in the worst case will stop at the '}'.\r\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\r\n * entry rule and not dip into the outer context.\r\n *\r\n * **PREDICATES**\r\n *\r\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\r\n * LL simulation deals with predicates differently. SLL collects predicates as\r\n * it performs closure operations like ANTLR v3 did. It delays predicate\r\n * evaluation until it reaches and accept state. This allows us to cache the SLL\r\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\r\n * closure, the DFA state configuration sets would be different and we couldn't\r\n * build up a suitable DFA.\r\n *\r\n * When building a DFA accept state during ATN simulation, we evaluate any\r\n * predicates and return the sole semantically valid alternative. If there is\r\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\r\n * we throw an exception. Alternatives without predicates act like they have\r\n * true predicates. The simple way to think about it is to strip away all\r\n * alternatives with false predicates and choose the minimum alternative that\r\n * remains.\r\n *\r\n * When we start in the DFA and reach an accept state that's predicated, we test\r\n * those and return the minimum semantically viable alternative. If no\r\n * alternatives are viable, we throw an exception.\r\n *\r\n * During full LL ATN simulation, closure always evaluates predicates and\r\n * on-the-fly. This is crucial to reducing the configuration set size during\r\n * closure. It hits a landmine when parsing with the Java grammar, for example,\r\n * without this on-the-fly evaluation.\r\n *\r\n * **SHARING DFA**\r\n *\r\n * All instances of the same parser share the same decision DFAs through a\r\n * static field. Each instance gets its own ATN simulator but they share the\r\n * same {@link ATN#decisionToDFA} field. They also share a\r\n * {@link PredictionContextCache} object that makes sure that all\r\n * {@link PredictionContext} objects are shared among the DFA states. This makes\r\n * a big size difference.\r\n *\r\n * **THREAD SAFETY**\r\n *\r\n * The {@link ParserATNSimulator} locks on the {@link ATN#decisionToDFA} field when\r\n * it adds a new DFA object to that array. {@link #addDFAEdge}\r\n * locks on the DFA for the current decision when setting the\r\n * {@link DFAState#edges} field. {@link #addDFAState} locks on\r\n * the DFA for the current decision when looking up a DFA state to see if it\r\n * already exists. We must make sure that all requests to add DFA states that\r\n * are equivalent result in the same shared DFA object. This is because lots of\r\n * threads will be trying to update the DFA at once. The\r\n * {@link #addDFAState} method also locks inside the DFA lock\r\n * but this time on the shared context cache when it rebuilds the\r\n * configurations' {@link PredictionContext} objects using cached\r\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\r\n * safe as long as we can guarantee that all threads referencing\r\n * `s.edge[t]` get the same physical target {@link DFAState}, or\r\n * `undefined`. Once into the DFA, the DFA simulation does not reference the\r\n * {@link DFA#states} map. It follows the {@link DFAState#edges} field to new\r\n * targets. The DFA simulator will either find {@link DFAState#edges} to be\r\n * `undefined`, to be non-`undefined` and `dfa.edges[t]` undefined, or\r\n * `dfa.edges[t]` to be non-undefined. The\r\n * {@link #addDFAEdge} method could be racing to set the field\r\n * but in either case the DFA simulator works; if `undefined`, and requests ATN\r\n * simulation. It could also race trying to get `dfa.edges[t]`, but either\r\n * way it will work because it's not doing a test and set operation.\r\n *\r\n * **Starting with SLL then failing to combined SLL/LL (Two-Stage\r\n * Parsing)**\r\n *\r\n * Sam pointed out that if SLL does not give a syntax error, then there is no\r\n * point in doing full LL, which is slower. We only have to try LL if we get a\r\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\r\n * mode with the {@link BailErrorStrategy}:\r\n *\r\n * ```\r\n * parser.interpreter.{@link #setPredictionMode setPredictionMode}`(`{@link PredictionMode#SLL}`)`;\r\n * parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\r\n * ```\r\n *\r\n * If it does not get a syntax error, then we're done. If it does get a syntax\r\n * error, we need to retry with the combined SLL/LL strategy.\r\n *\r\n * The reason this works is as follows. If there are no SLL conflicts, then the\r\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\r\n * the full LL analysis must yield a set of viable alternatives which is a\r\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\r\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\r\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\r\n * is truly ambiguous on the current input. If the LL set is smaller, then the\r\n * SLL conflict resolution might choose an alternative that the full LL would\r\n * rule out as a possibility based upon better context information. If that's\r\n * the case, then the SLL parse will definitely get an error because the full LL\r\n * analysis says it's not viable. If SLL conflict resolution chooses an\r\n * alternative within the LL set, them both SLL and LL would choose the same\r\n * alternative because they both choose the minimum of multiple conflicting\r\n * alternatives.\r\n *\r\n * Let's say we have a set of SLL conflicting alternatives `{1, 2, 3}` and\r\n * a smaller LL set called *s*. If *s* is `{2, 3}`, then SLL\r\n * parsing will get an error because SLL will pursue alternative 1. If\r\n * *s* is `{1, 2}` or `{1, 3}` then both SLL and LL will\r\n * choose the same alternative because alternative one is the minimum of either\r\n * set. If *s* is `{2}` or `{3}` then SLL will get a syntax\r\n * error. If *s* is `{1}` then SLL will succeed.\r\n *\r\n * Of course, if the input is invalid, then we will get an error for sure in\r\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\r\n * the input.\r\n */\r\nexport class ParserATNSimulator extends ATNSimulator {\r\n\tpublic static debug: boolean = false;\r\n\tpublic static dfa_debug: boolean = false;\r\n\tpublic static retry_debug: boolean = false;\r\n\r\n\t@NotNull\r\n\tprivate predictionMode: PredictionMode = PredictionMode.LL;\r\n\tpublic force_global_context: boolean = false;\r\n\tpublic always_try_local_context: boolean = true;\r\n\r\n\t/**\r\n\t * Determines whether the DFA is used for full-context predictions. When\r\n\t * `true`, the DFA stores transition information for both full-context\r\n\t * and SLL parsing; otherwise, the DFA only stores SLL transition\r\n\t * information.\r\n\t *\r\n\t * For some grammars, enabling the full-context DFA can result in a\r\n\t * substantial performance improvement. However, this improvement typically\r\n\t * comes at the expense of memory used for storing the cached DFA states,\r\n\t * configuration sets, and prediction contexts.\r\n\t *\r\n\t * The default value is `false`.\r\n\t */\r\n\tpublic enable_global_context_dfa: boolean = false;\r\n\tpublic optimize_unique_closure: boolean = true;\r\n\tpublic optimize_ll1: boolean = true;\r\n\tpublic optimize_tail_calls: boolean = true;\r\n\tpublic tail_call_preserves_sll: boolean = true;\r\n\tpublic treat_sllk1_conflict_as_ambiguity: boolean = false;\r\n\r\n\tprotected _parser: Parser;\r\n\r\n\t/**\r\n\t * When `true`, ambiguous alternatives are reported when they are\r\n\t * encountered within {@link #execATN}. When `false`, these messages\r\n\t * are suppressed. The default is `false`.\r\n\t *\r\n\t * When messages about ambiguous alternatives are not required, setting this\r\n\t * to `false` enables additional internal optimizations which may lose\r\n\t * this information.\r\n\t */\r\n\tpublic reportAmbiguities: boolean = false;\r\n\r\n\t/** By default we do full context-sensitive LL(*) parsing not\r\n\t *  Strong LL(*) parsing. If we fail with Strong LL(*) we\r\n\t *  try full LL(*). That means we rewind and use context information\r\n\t *  when closure operations fall off the end of the rule that\r\n\t *  holds the decision were evaluating.\r\n\t */\r\n\tprotected userWantsCtxSensitive: boolean = true;\r\n\r\n\tprivate dfa?: DFA;\r\n\r\n\tconstructor(@NotNull atn: ATN, parser: Parser) {\r\n\t\tsuper(atn);\r\n\t\tthis._parser = parser;\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getPredictionMode(): PredictionMode {\r\n\t\treturn this.predictionMode;\r\n\t}\r\n\r\n\tpublic setPredictionMode(@NotNull predictionMode: PredictionMode): void {\r\n\t\tthis.predictionMode = predictionMode;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reset(): void {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined): number;\r\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined, useContext: boolean): number;\r\n\tpublic adaptivePredict(\r\n\t\t@NotNull input: TokenStream,\r\n\t\tdecision: number,\r\n\t\touterContext: ParserRuleContext | undefined,\r\n\t\tuseContext?: boolean): number {\r\n\t\tif (useContext === undefined) {\r\n\t\t\tuseContext = false;\r\n\t\t}\r\n\r\n\t\tlet dfa: DFA = this.atn.decisionToDFA[decision];\r\n\t\tassert(dfa != null);\r\n\t\tif (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {\r\n\t\t\tlet ll_1: number = input.LA(1);\r\n\t\t\tif (ll_1 >= 0 && ll_1 <= 0xFFFF) {\r\n\t\t\t\tlet key: number = ((decision << 16) >>> 0) + ll_1;\r\n\t\t\t\tlet alt: number | undefined = this.atn.LL1Table.get(key);\r\n\t\t\t\tif (alt != null) {\r\n\t\t\t\t\treturn alt;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.dfa = dfa;\r\n\r\n\t\tif (this.force_global_context) {\r\n\t\t\tuseContext = true;\r\n\t\t}\r\n\t\telse if (!this.always_try_local_context) {\r\n\t\t\tuseContext = useContext || dfa.isContextSensitive;\r\n\t\t}\r\n\r\n\t\tthis.userWantsCtxSensitive = useContext || (this.predictionMode !== PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll);\r\n\t\tif (outerContext == null) {\r\n\t\t\touterContext = ParserRuleContext.emptyContext();\r\n\t\t}\r\n\r\n\t\tlet state: SimulatorState | undefined;\r\n\t\tif (!dfa.isEmpty) {\r\n\t\t\tstate = this.getStartState(dfa, input, outerContext, useContext);\r\n\t\t}\r\n\r\n\t\tif (state == null) {\r\n\t\t\tif (outerContext == null) {\r\n\t\t\t\touterContext = ParserRuleContext.emptyContext();\r\n\t\t\t}\r\n\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\tconsole.log(\"ATN decision \" + dfa.decision +\r\n\t\t\t\t\t\" exec LA(1)==\" + this.getLookaheadName(input) +\r\n\t\t\t\t\t\", outerContext=\" + outerContext.toString(this._parser));\r\n\t\t\t}\r\n\r\n\t\t\tstate = this.computeStartState(dfa, outerContext, useContext);\r\n\t\t}\r\n\r\n\t\tlet m: number = input.mark();\r\n\t\tlet index: number = input.index;\r\n\t\ttry {\r\n\t\t\tlet alt: number = this.execDFA(dfa, input, index, state);\r\n\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\tconsole.log(\"DFA after predictATN: \" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\r\n\t\t\t}\r\n\t\t\treturn alt;\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tthis.dfa = undefined;\r\n\t\t\tinput.seek(index);\r\n\t\t\tinput.release(m);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getStartState(\r\n\t\t@NotNull dfa: DFA,\r\n\t\t@NotNull input: TokenStream,\r\n\t\t@NotNull outerContext: ParserRuleContext,\r\n\t\tuseContext: boolean): SimulatorState | undefined {\r\n\r\n\t\tif (!useContext) {\r\n\t\t\tif (dfa.isPrecedenceDfa) {\r\n\t\t\t\t// the start state for a precedence DFA depends on the current\r\n\t\t\t\t// parser precedence, and is provided by a DFA method.\r\n\t\t\t\tlet state: DFAState | undefined = dfa.getPrecedenceStartState(this._parser.precedence, false);\r\n\t\t\t\tif (state == null) {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new SimulatorState(outerContext, state, false, outerContext);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (dfa.s0 == null) {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new SimulatorState(outerContext, dfa.s0, false, outerContext);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!this.enable_global_context_dfa) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet remainingContext: ParserRuleContext | undefined = outerContext;\r\n\t\tassert(outerContext != null);\r\n\t\tlet s0: DFAState | undefined;\r\n\t\tif (dfa.isPrecedenceDfa) {\r\n\t\t\ts0 = dfa.getPrecedenceStartState(this._parser.precedence, true);\r\n\t\t}\r\n\t\telse {\r\n\t\t\ts0 = dfa.s0full;\r\n\t\t}\r\n\r\n\t\twhile (remainingContext != null && s0 != null && s0.isContextSensitive) {\r\n\t\t\tremainingContext = this.skipTailCalls(remainingContext);\r\n\t\t\ts0 = s0.getContextTarget(this.getReturnState(remainingContext));\r\n\t\t\tif (remainingContext.isEmpty) {\r\n\t\t\t\tassert(s0 == null || !s0.isContextSensitive);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tremainingContext = remainingContext.parent;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (s0 == null) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn new SimulatorState(outerContext, s0, useContext, remainingContext);\r\n\t}\r\n\r\n\tprotected execDFA(\r\n\t\t@NotNull dfa: DFA,\r\n\t\t@NotNull input: TokenStream, startIndex: number,\r\n\t\t@NotNull state: SimulatorState): number {\r\n\t\tlet outerContext: ParserRuleContext = state.outerContext;\r\n\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\r\n\t\t\t\t\" exec LA(1)==\" + this.getLookaheadName(input) +\r\n\t\t\t\t\", outerContext=\" + outerContext.toString(this._parser));\r\n\t\t}\r\n\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\tconsole.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\r\n\t\t}\r\n\t\tlet s: DFAState = state.s0;\r\n\r\n\t\tlet t: number = input.LA(1);\r\n\t\tlet remainingOuterContext: ParserRuleContext | undefined = state.remainingOuterContext;\r\n\r\n\t\twhile (true) {\r\n\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\tconsole.log(\"DFA state \" + s.stateNumber + \" LA(1)==\" + this.getLookaheadName(input));\r\n\t\t\t}\r\n\t\t\tif (state.useContext) {\r\n\t\t\t\twhile (s.isContextSymbol(t)) {\r\n\t\t\t\t\tlet next: DFAState | undefined;\r\n\t\t\t\t\tif (remainingOuterContext != null) {\r\n\t\t\t\t\t\tremainingOuterContext = this.skipTailCalls(remainingOuterContext);\r\n\t\t\t\t\t\tnext = s.getContextTarget(this.getReturnState(remainingOuterContext));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (next == null) {\r\n\t\t\t\t\t\t// fail over to ATN\r\n\t\t\t\t\t\tlet initialState: SimulatorState = new SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);\r\n\t\t\t\t\t\treturn this.execATN(dfa, input, startIndex, initialState);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tassert(remainingOuterContext != null);\r\n\t\t\t\t\tremainingOuterContext = remainingOuterContext.parent;\r\n\t\t\t\t\ts = next;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.isAcceptState(s, state.useContext)) {\r\n\t\t\t\tif (s.predicates != null) {\r\n\t\t\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\t\tconsole.log(\"accept \" + s);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\t\tconsole.log(\"accept; predict \" + s.prediction + \" in state \" + s.stateNumber);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// keep going unless we're at EOF or state only has one alt number\r\n\t\t\t\t// mentioned in configs; check if something else could match\r\n\t\t\t\t// TODO: don't we always stop? only lexer would keep going\r\n\t\t\t\t// TODO: v3 dfa don't do this.\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// t is not updated if one of these states is reached\r\n\t\t\tassert(!this.isAcceptState(s, state.useContext));\r\n\r\n\t\t\t// if no edge, pop over to ATN interpreter, update DFA and return\r\n\t\t\tlet target: DFAState | undefined = this.getExistingTargetState(s, t);\r\n\t\t\tif (target == null) {\r\n\t\t\t\tif (ParserATNSimulator.dfa_debug && t >= 0) {\r\n\t\t\t\t\tconsole.log(\"no edge for \" + this._parser.vocabulary.getDisplayName(t));\r\n\t\t\t\t}\r\n\t\t\t\tlet alt: number;\r\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\tlet interval: Interval = Interval.of(startIndex, this._parser.inputStream.index);\r\n\t\t\t\t\tconsole.log(\"ATN exec upon \" +\r\n\t\t\t\t\t\tthis._parser.inputStream.getText(interval) +\r\n\t\t\t\t\t\t\" at DFA state \" + s.stateNumber);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet initialState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\r\n\t\t\t\talt = this.execATN(dfa, input, startIndex, initialState);\r\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\tconsole.log(\"back from DFA update, alt=\" + alt + \", dfa=\\n\" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\r\n\t\t\t\t\t//dump(dfa);\r\n\t\t\t\t}\r\n\t\t\t\t// action already executed\r\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\r\n\t\t\t\t\t\t\" predicts \" + alt);\r\n\t\t\t\t}\r\n\t\t\t\treturn alt; // we've updated DFA, exec'd action, and have our deepest answer\r\n\t\t\t}\r\n\t\t\telse if (target === ATNSimulator.ERROR) {\r\n\t\t\t\tlet errorState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\r\n\t\t\t\treturn this.handleNoViableAlt(input, startIndex, errorState);\r\n\t\t\t}\r\n\t\t\ts = target;\r\n\t\t\tif (!this.isAcceptState(s, state.useContext) && t !== IntStream.EOF) {\r\n\t\t\t\tinput.consume();\r\n\t\t\t\tt = input.LA(1);\r\n\t\t\t}\r\n\t\t}\r\n//\t\tif ( acceptState==null ) {\r\n//\t\t\tif ( debug ) System.out.println(\"!!! no viable alt in dfa\");\r\n//\t\t\treturn -1;\r\n//\t\t}\r\n\r\n\t\tif (!state.useContext && s.configs.conflictInfo != null) {\r\n\t\t\tif (dfa.atnStartState instanceof DecisionState) {\r\n\t\t\t\tif (!this.userWantsCtxSensitive ||\r\n\t\t\t\t\t(!s.configs.dipsIntoOuterContext && s.configs.isExactConflict) ||\r\n\t\t\t\t\t(this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex)) {\r\n\t\t\t\t\t// we don't report the ambiguity again\r\n\t\t\t\t\t//if ( !this.acceptState.configset.hasSemanticContext ) {\r\n\t\t\t\t\t// \tthis.reportAmbiguity(dfa, acceptState, startIndex, input.index, acceptState.configset.conflictingAlts, acceptState.configset);\r\n\t\t\t\t\t//}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tassert(!state.useContext);\r\n\r\n\t\t\t\t\t// Before attempting full context prediction, check to see if there are\r\n\t\t\t\t\t// disambiguating or validating predicates to evaluate which allow an\r\n\t\t\t\t\t// immediate decision\r\n\t\t\t\t\tlet conflictingAlts: BitSet | undefined;\r\n\t\t\t\t\tlet predicates: DFAState.PredPrediction[] | undefined = s.predicates;\r\n\t\t\t\t\tif (predicates != null) {\r\n\t\t\t\t\t\tlet conflictIndex: number = input.index;\r\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\r\n\t\t\t\t\t\t\tinput.seek(startIndex);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconflictingAlts = this.evalSemanticContext(predicates, outerContext, true);\r\n\t\t\t\t\t\tif (conflictingAlts.cardinality() === 1) {\r\n\t\t\t\t\t\t\treturn conflictingAlts.nextSetBit(0);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\r\n\t\t\t\t\t\t\t// restore the index so reporting the fallback to full\r\n\t\t\t\t\t\t\t// context occurs with the index at the correct spot\r\n\t\t\t\t\t\t\tinput.seek(conflictIndex);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.reportAmbiguities) {\r\n\t\t\t\t\t\tlet conflictState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\r\n\t\t\t\t\t\tthis.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tinput.seek(startIndex);\r\n\t\t\t\t\treturn this.adaptivePredict(input, dfa.decision, outerContext, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Before jumping to prediction, check to see if there are\r\n\t\t// disambiguating or validating predicates to evaluate\r\n\t\tlet predicates: DFAState.PredPrediction[] | undefined = s.predicates;\r\n\t\tif (predicates != null) {\r\n\t\t\tlet stopIndex: number = input.index;\r\n\t\t\tif (startIndex !== stopIndex) {\r\n\t\t\t\tinput.seek(startIndex);\r\n\t\t\t}\r\n\r\n\t\t\tlet alts: BitSet = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode.LL_EXACT_AMBIG_DETECTION);\r\n\t\t\tswitch (alts.cardinality()) {\r\n\t\t\tcase 0:\r\n\t\t\t\tthrow this.noViableAlt(input, outerContext, s.configs, startIndex);\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\treturn alts.nextSetBit(0);\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// report ambiguity after predicate evaluation to make sure the correct\r\n\t\t\t\t// set of ambig alts is reported.\r\n\t\t\t\tif (startIndex !== stopIndex) {\r\n\t\t\t\t\tinput.seek(stopIndex);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);\r\n\t\t\t\treturn alts.nextSetBit(0);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.dfa_debug) {\r\n\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\r\n\t\t\t\t\" predicts \" + s.prediction);\r\n\t\t}\r\n\t\treturn s.prediction;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if a particular DFA state should be treated as an accept state\r\n\t * for the current prediction mode. In addition to the `useContext`\r\n\t * parameter, the {@link #getPredictionMode()} method provides the\r\n\t * prediction mode controlling the prediction algorithm as a whole.\r\n\t *\r\n\t * The default implementation simply returns the value of\r\n\t * `DFAState.isAcceptState` except for conflict states when\r\n\t * `useContext` is `true` and {@link #getPredictionMode()} is\r\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only\r\n\t * conflict states where {@link ATNConfigSet#isExactConflict} is\r\n\t * `true` are considered accept states.\r\n\t *\r\n\t * @param state The DFA state to check.\r\n\t * @param useContext `true` if the prediction algorithm is currently\r\n\t * considering the full parser context; otherwise, `false` if the\r\n\t * algorithm is currently performing a local context prediction.\r\n\t *\r\n\t * @returns `true` if the specified `state` is an accept state;\r\n\t * otherwise, `false`.\r\n\t */\r\n\tprotected isAcceptState(state: DFAState, useContext: boolean): boolean {\r\n\t\tif (!state.isAcceptState) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (state.configs.conflictingAlts == null) {\r\n\t\t\t// unambiguous\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// More picky when we need exact conflicts\r\n\t\tif (useContext && this.predictionMode === PredictionMode.LL_EXACT_AMBIG_DETECTION) {\r\n\t\t\treturn state.configs.isExactConflict;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/** Performs ATN simulation to compute a predicted alternative based\r\n\t *  upon the remaining input, but also updates the DFA cache to avoid\r\n\t *  having to traverse the ATN again for the same input sequence.\r\n\t *\r\n\t * There are some key conditions we're looking for after computing a new\r\n\t * set of ATN configs (proposed DFA state):\r\n\t *\r\n\t * * if the set is empty, there is no viable alternative for current symbol\r\n\t * * does the state uniquely predict an alternative?\r\n\t * * does the state have a conflict that would prevent us from\r\n\t *   putting it on the work list?\r\n\t * * if in non-greedy decision is there a config at a rule stop state?\r\n\t *\r\n\t * We also have some key operations to do:\r\n\t *\r\n\t * * add an edge from previous DFA state to potentially new DFA state, D,\r\n\t *   upon current symbol but only if adding to work list, which means in all\r\n\t *   cases except no viable alternative (and possibly non-greedy decisions?)\r\n\t * * collecting predicates and adding semantic context to DFA accept states\r\n\t * * adding rule context to context-sensitive DFA accept states\r\n\t * * consuming an input symbol\r\n\t * * reporting a conflict\r\n\t * * reporting an ambiguity\r\n\t * * reporting a context sensitivity\r\n\t * * reporting insufficient predicates\r\n\t *\r\n\t * We should isolate those operations, which are side-effecting, to the\r\n\t * main work loop. We can isolate lots of code into other functions, but\r\n\t * they should be side effect free. They can return package that\r\n\t * indicates whether we should report something, whether we need to add a\r\n\t * DFA edge, whether we need to augment accept state with semantic\r\n\t * context or rule invocation context. Actually, it seems like we always\r\n\t * add predicates if they exist, so that can simply be done in the main\r\n\t * loop for any accept state creation or modification request.\r\n\t *\r\n\t * cover these cases:\r\n\t *   dead end\r\n\t *   single alt\r\n\t *   single alt + preds\r\n\t *   conflict\r\n\t *   conflict + preds\r\n\t *\r\n\t * TODO: greedy + those\r\n\t */\r\n\tprotected execATN(\r\n\t\t@NotNull dfa: DFA,\r\n\t\t@NotNull input: TokenStream, startIndex: number,\r\n\t\t@NotNull initialState: SimulatorState): number {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input));\r\n\t\t}\r\n\r\n\t\tlet outerContext: ParserRuleContext = initialState.outerContext;\r\n\t\tlet useContext: boolean = initialState.useContext;\r\n\r\n\t\tlet t: number = input.LA(1);\r\n\r\n\t\tlet previous: SimulatorState = initialState;\r\n\r\n\t\tlet contextCache: PredictionContextCache = new PredictionContextCache();\r\n\t\twhile (true) { // while more work\r\n\t\t\tlet nextState: SimulatorState | undefined = this.computeReachSet(dfa, previous, t, contextCache);\r\n\t\t\tif (nextState == null) {\r\n\t\t\t\tthis.setDFAEdge(previous.s0, input.LA(1), ATNSimulator.ERROR);\r\n\t\t\t\treturn this.handleNoViableAlt(input, startIndex, previous);\r\n\t\t\t}\r\n\r\n\t\t\tlet D: DFAState = nextState.s0;\r\n\r\n\t\t\t// predicted alt => accept state\r\n\t\t\tassert(D.isAcceptState || D.prediction === ATN.INVALID_ALT_NUMBER);\r\n\t\t\t// conflicted => accept state\r\n\t\t\tassert(D.isAcceptState || D.configs.conflictInfo == null);\r\n\r\n\t\t\tif (this.isAcceptState(D, useContext)) {\r\n\t\t\t\tlet conflictingAlts: BitSet | undefined = D.configs.conflictingAlts;\r\n\t\t\t\tlet predictedAlt: number = conflictingAlts == null ? D.prediction : ATN.INVALID_ALT_NUMBER;\r\n\t\t\t\tif (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\t\t\tif (this.optimize_ll1\r\n\t\t\t\t\t\t&& input.index === startIndex\r\n\t\t\t\t\t\t&& !dfa.isPrecedenceDfa\r\n\t\t\t\t\t\t&& nextState.outerContext === nextState.remainingOuterContext\r\n\t\t\t\t\t\t&& dfa.decision >= 0\r\n\t\t\t\t\t\t&& !D.configs.hasSemanticContext) {\r\n\t\t\t\t\t\tif (t >= 0 && t <= MAX_SHORT_VALUE) {\r\n\t\t\t\t\t\t\tlet key: number = ((dfa.decision << 16) >>> 0) + t;\r\n\t\t\t\t\t\t\tthis.atn.LL1Table.set(key, predictedAlt);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (useContext && this.always_try_local_context) {\r\n\t\t\t\t\t\tthis.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpredictedAlt = D.prediction;\r\n//\t\t\t\tint k = input.index - startIndex + 1; // how much input we used\r\n//\t\t\t\tSystem.out.println(\"used k=\"+k);\r\n\t\t\t\tlet attemptFullContext: boolean = conflictingAlts != null && this.userWantsCtxSensitive;\r\n\t\t\t\tif (attemptFullContext) {\r\n\t\t\t\t\t// Only exact conflicts are known to be ambiguous when local\r\n\t\t\t\t\t// prediction does not step out of the decision rule.\r\n\t\t\t\t\tattemptFullContext = !useContext\r\n\t\t\t\t\t\t&& (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict)\r\n\t\t\t\t\t\t&& (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (D.configs.hasSemanticContext) {\r\n\t\t\t\t\tlet predPredictions: DFAState.PredPrediction[] | undefined = D.predicates;\r\n\t\t\t\t\tif (predPredictions != null) {\r\n\t\t\t\t\t\tlet conflictIndex: number = input.index;\r\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\r\n\t\t\t\t\t\t\tinput.seek(startIndex);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// use complete evaluation here if we'll want to retry with full context if still ambiguous\r\n\t\t\t\t\t\tconflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);\r\n\t\t\t\t\t\tswitch (conflictingAlts.cardinality()) {\r\n\t\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\t\tthrow this.noViableAlt(input, outerContext, D.configs, startIndex);\r\n\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\treturn conflictingAlts.nextSetBit(0);\r\n\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\r\n\t\t\t\t\t\t\t// restore the index so reporting the fallback to full\r\n\t\t\t\t\t\t\t// context occurs with the index at the correct spot\r\n\t\t\t\t\t\t\tinput.seek(conflictIndex);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!attemptFullContext) {\r\n\t\t\t\t\tif (conflictingAlts != null) {\r\n\t\t\t\t\t\tif (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {\r\n\t\t\t\t\t\t\tthis.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpredictedAlt = conflictingAlts.nextSetBit(0);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn predictedAlt;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tassert(!useContext);\r\n\t\t\t\t\tassert(this.isAcceptState(D, false));\r\n\r\n\t\t\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\t\t\tconsole.log(\"RETRY with outerContext=\" + outerContext);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet fullContextState: SimulatorState = this.computeStartState(dfa, outerContext, true);\r\n\t\t\t\t\tif (this.reportAmbiguities) {\r\n\t\t\t\t\t\tthis.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tinput.seek(startIndex);\r\n\t\t\t\t\treturn this.execATN(dfa, input, startIndex, fullContextState);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tprevious = nextState;\r\n\r\n\t\t\tif (t !== IntStream.EOF) {\r\n\t\t\t\tinput.consume();\r\n\t\t\t\tt = input.LA(1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method is used to improve the localization of error messages by\r\n\t * choosing an alternative rather than throwing a\r\n\t * {@link NoViableAltException} in particular prediction scenarios where the\r\n\t * {@link #ERROR} state was reached during ATN simulation.\r\n\t *\r\n\t * The default implementation of this method uses the following\r\n\t * algorithm to identify an ATN configuration which successfully parsed the\r\n\t * decision entry rule. Choosing such an alternative ensures that the\r\n\t * {@link ParserRuleContext} returned by the calling rule will be complete\r\n\t * and valid, and the syntax error will be reported later at a more\r\n\t * localized location.\r\n\t *\r\n\t * * If no configuration in `configs` reached the end of the\r\n\t *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.\r\n\t * * If all configurations in `configs` which reached the end of the\r\n\t *   decision rule predict the same alternative, return that alternative.\r\n\t * * If the configurations in `configs` which reached the end of the\r\n\t *   decision rule predict multiple alternatives (call this *S*),\r\n\t *   choose an alternative in the following order.\r\n\t *\r\n\t *     1. Filter the configurations in `configs` to only those\r\n\t *        configurations which remain viable after evaluating semantic predicates.\r\n\t *        If the set of these filtered configurations which also reached the end of\r\n\t *        the decision rule is not empty, return the minimum alternative\r\n\t *        represented in this set.\r\n\t *     1. Otherwise, choose the minimum alternative in *S*.\r\n\t *\r\n\t * In some scenarios, the algorithm described above could predict an\r\n\t * alternative which will result in a {@link FailedPredicateException} in\r\n\t * parser. Specifically, this could occur if the *only* configuration\r\n\t * capable of successfully parsing to the end of the decision rule is\r\n\t * blocked by a semantic predicate. By choosing this alternative within\r\n\t * {@link #adaptivePredict} instead of throwing a\r\n\t * {@link NoViableAltException}, the resulting\r\n\t * {@link FailedPredicateException} in the parser will identify the specific\r\n\t * predicate which is preventing the parser from successfully parsing the\r\n\t * decision rule, which helps developers identify and correct logic errors\r\n\t * in semantic predicates.\r\n\t *\r\n\t * @param input The input {@link TokenStream}\r\n\t * @param startIndex The start index for the current prediction, which is\r\n\t * the input index where any semantic context in `configs` should be\r\n\t * evaluated\r\n\t * @param previous The ATN simulation state immediately before the\r\n\t * {@link #ERROR} state was reached\r\n\t *\r\n\t * @returns The value to return from {@link #adaptivePredict}, or\r\n\t * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not\r\n\t * identified and {@link #adaptivePredict} should report an error instead.\r\n\t */\r\n\tprotected handleNoViableAlt(@NotNull input: TokenStream, startIndex: number, @NotNull previous: SimulatorState): number {\r\n\t\tif (previous.s0 != null) {\r\n\t\t\tlet alts: BitSet = new BitSet();\r\n\t\t\tlet maxAlt: number = 0;\r\n\t\t\tfor (let config of previous.s0.configs) {\r\n\t\t\t\tif (config.reachesIntoOuterContext || config.state instanceof RuleStopState) {\r\n\t\t\t\t\talts.set(config.alt);\r\n\t\t\t\t\tmaxAlt = Math.max(maxAlt, config.alt);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tswitch (alts.cardinality()) {\r\n\t\t\tcase 0:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\treturn alts.nextSetBit(0);\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tif (!previous.s0.configs.hasSemanticContext) {\r\n\t\t\t\t\t// configs doesn't contain any predicates, so the predicate\r\n\t\t\t\t\t// filtering code below would be pointless\r\n\t\t\t\t\treturn alts.nextSetBit(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*\r\n\t\t\t\t * Try to find a configuration set that not only dipped into the outer\r\n\t\t\t\t * context, but also isn't eliminated by a predicate.\r\n\t\t\t\t */\r\n\t\t\t\tlet filteredConfigs: ATNConfigSet = new ATNConfigSet();\r\n\t\t\t\tfor (let config of previous.s0.configs) {\r\n\t\t\t\t\tif (config.reachesIntoOuterContext || config.state instanceof RuleStopState) {\r\n\t\t\t\t\t\tfilteredConfigs.add(config);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* The following code blocks are adapted from predicateDFAState with\r\n\t\t\t\t * the following key changes.\r\n\t\t\t\t *\r\n\t\t\t\t *  1. The code operates on an ATNConfigSet rather than a DFAState.\r\n\t\t\t\t *  2. Predicates are collected for all alternatives represented in\r\n\t\t\t\t *     filteredConfigs, rather than restricting the evaluation to\r\n\t\t\t\t *     conflicting and/or unique configurations.\r\n\t\t\t\t */\r\n\t\t\t\tlet altToPred: SemanticContext[] | undefined = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);\r\n\t\t\t\tif (altToPred != null) {\r\n\t\t\t\t\tlet predicates: DFAState.PredPrediction[] | undefined = this.getPredicatePredictions(alts, altToPred);\r\n\t\t\t\t\tif (predicates != null) {\r\n\t\t\t\t\t\tlet stopIndex: number = input.index;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tinput.seek(startIndex);\r\n\t\t\t\t\t\t\tlet filteredAlts: BitSet = this.evalSemanticContext(predicates, previous.outerContext, false);\r\n\t\t\t\t\t\t\tif (!filteredAlts.isEmpty) {\r\n\t\t\t\t\t\t\t\treturn filteredAlts.nextSetBit(0);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally {\r\n\t\t\t\t\t\t\tinput.seek(stopIndex);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn alts.nextSetBit(0);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);\r\n\t}\r\n\r\n\tprotected computeReachSet(dfa: DFA, previous: SimulatorState, t: number, contextCache: PredictionContextCache): SimulatorState | undefined {\r\n\t\tlet useContext: boolean = previous.useContext;\r\n\t\tlet remainingGlobalContext: ParserRuleContext | undefined = previous.remainingOuterContext;\r\n\r\n\t\tlet s: DFAState = previous.s0;\r\n\t\tif (useContext) {\r\n\t\t\twhile (s.isContextSymbol(t)) {\r\n\t\t\t\tlet next: DFAState | undefined;\r\n\t\t\t\tif (remainingGlobalContext != null) {\r\n\t\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\r\n\t\t\t\t\tnext = s.getContextTarget(this.getReturnState(remainingGlobalContext));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (next == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassert(remainingGlobalContext != null);\r\n\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\r\n\t\t\t\ts = next;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tassert(!this.isAcceptState(s, useContext));\r\n\t\tif (this.isAcceptState(s, useContext)) {\r\n\t\t\treturn new SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);\r\n\t\t}\r\n\r\n\t\tlet s0: DFAState = s;\r\n\r\n\t\tlet target: DFAState | undefined = this.getExistingTargetState(s0, t);\r\n\t\tif (target == null) {\r\n\t\t\tlet result: [DFAState, ParserRuleContext | undefined] = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);\r\n\t\t\ttarget = result[0];\r\n\t\t\tremainingGlobalContext = result[1];\r\n\t\t}\r\n\r\n\t\tif (target === ATNSimulator.ERROR) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tassert(!useContext || !target.configs.dipsIntoOuterContext);\r\n\t\treturn new SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);\r\n\t}\r\n\r\n\t/**\r\n\t * Get an existing target state for an edge in the DFA. If the target state\r\n\t * for the edge has not yet been computed or is otherwise not available,\r\n\t * this method returns `undefined`.\r\n\t *\r\n\t * @param s The current DFA state\r\n\t * @param t The next input symbol\r\n\t * @returns The existing target DFA state for the given input symbol\r\n\t * `t`, or `undefined` if the target state for this edge is not\r\n\t * already cached\r\n\t */\r\n\tprotected getExistingTargetState(@NotNull s: DFAState, t: number): DFAState | undefined {\r\n\t\treturn s.getTarget(t);\r\n\t}\r\n\r\n\t/**\r\n\t * Compute a target state for an edge in the DFA, and attempt to add the\r\n\t * computed state and corresponding edge to the DFA.\r\n\t *\r\n\t * @param dfa\r\n\t * @param s The current DFA state\r\n\t * @param remainingGlobalContext\r\n\t * @param t The next input symbol\r\n\t * @param useContext\r\n\t * @param contextCache\r\n\t *\r\n\t * @returns The computed target DFA state for the given input symbol\r\n\t * `t`. If `t` does not lead to a valid DFA state, this method\r\n\t * returns {@link #ERROR}.\r\n\t */\r\n\t@NotNull\r\n\tprotected computeTargetState(@NotNull dfa: DFA, @NotNull s: DFAState, remainingGlobalContext: ParserRuleContext | undefined, t: number, useContext: boolean, contextCache: PredictionContextCache): [DFAState, ParserRuleContext | undefined] {\r\n\t\tlet closureConfigs: ATNConfig[] = s.configs.toArray();\r\n\t\tlet contextElements: IntegerList | undefined;\r\n\t\tlet reach: ATNConfigSet = new ATNConfigSet();\r\n\t\tlet stepIntoGlobal: boolean;\r\n\t\tdo {\r\n\t\t\tlet hasMoreContext: boolean = !useContext || remainingGlobalContext != null;\r\n\t\t\tif (!hasMoreContext) {\r\n\t\t\t\treach.isOutermostConfigSet = true;\r\n\t\t\t}\r\n\r\n\t\t\tlet reachIntermediate: ATNConfigSet = new ATNConfigSet();\r\n\r\n\t\t\t/* Configurations already in a rule stop state indicate reaching the end\r\n\t\t\t * of the decision rule (local context) or end of the start rule (full\r\n\t\t\t * context). Once reached, these configurations are never updated by a\r\n\t\t\t * closure operation, so they are handled separately for the performance\r\n\t\t\t * advantage of having a smaller intermediate set when calling closure.\r\n\t\t\t *\r\n\t\t\t * For full-context reach operations, separate handling is required to\r\n\t\t\t * ensure that the alternative matching the longest overall sequence is\r\n\t\t\t * chosen when multiple such configurations can match the input.\r\n\t\t\t */\r\n\t\t\tlet skippedStopStates: ATNConfig[] | undefined;\r\n\r\n\t\t\tfor (let c of closureConfigs) {\r\n\t\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\t\tconsole.log(\"testing \" + this.getTokenName(t) + \" at \" + c.toString());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c.state instanceof RuleStopState) {\r\n\t\t\t\t\tassert(c.context.isEmpty);\r\n\t\t\t\t\tif (useContext && !c.reachesIntoOuterContext || t === IntStream.EOF) {\r\n\t\t\t\t\t\tif (skippedStopStates == null) {\r\n\t\t\t\t\t\t\tskippedStopStates = [];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tskippedStopStates.push(c);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet n: number = c.state.numberOfOptimizedTransitions;\r\n\t\t\t\tfor (let ti = 0; ti < n; ti++) {               // for each optimized transition\r\n\t\t\t\t\tlet trans: Transition = c.state.getOptimizedTransition(ti);\r\n\t\t\t\t\tlet target: ATNState | undefined = this.getReachableTarget(c, trans, t);\r\n\t\t\t\t\tif (target != null) {\r\n\t\t\t\t\t\treachIntermediate.add(c.transform(target, false), contextCache);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* This block optimizes the reach operation for intermediate sets which\r\n\t\t\t * trivially indicate a termination state for the overall\r\n\t\t\t * adaptivePredict operation.\r\n\t\t\t *\r\n\t\t\t * The conditions assume that intermediate\r\n\t\t\t * contains all configurations relevant to the reach set, but this\r\n\t\t\t * condition is not true when one or more configurations have been\r\n\t\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\r\n\t\t\t */\r\n\t\t\tif (this.optimize_unique_closure && skippedStopStates == null && t !== Token.EOF && reachIntermediate.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\t\treachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;\r\n\t\t\t\treach = reachIntermediate;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t/* If the reach set could not be trivially determined, perform a closure\r\n\t\t\t * operation on the intermediate set to compute its initial value.\r\n\t\t\t */\r\n\t\t\tlet collectPredicates: boolean = false;\r\n\t\t\tlet treatEofAsEpsilon: boolean = t === Token.EOF;\r\n\t\t\tthis.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);\r\n\t\t\tstepIntoGlobal = reach.dipsIntoOuterContext;\r\n\r\n\t\t\tif (t === IntStream.EOF) {\r\n\t\t\t\t/* After consuming EOF no additional input is possible, so we are\r\n\t\t\t\t * only interested in configurations which reached the end of the\r\n\t\t\t\t * decision rule (local context) or end of the start rule (full\r\n\t\t\t\t * context). Update reach to contain only these configurations. This\r\n\t\t\t\t * handles both explicit EOF transitions in the grammar and implicit\r\n\t\t\t\t * EOF transitions following the end of the decision or start rule.\r\n\t\t\t\t *\r\n\t\t\t\t * This is handled before the configurations in skippedStopStates,\r\n\t\t\t\t * because any configurations potentially added from that list are\r\n\t\t\t\t * already guaranteed to meet this condition whether or not it's\r\n\t\t\t\t * required.\r\n\t\t\t\t */\r\n\t\t\t\treach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);\r\n\t\t\t}\r\n\r\n\t\t\t/* If skippedStopStates is not undefined, then it contains at least one\r\n\t\t\t * configuration. For full-context reach operations, these\r\n\t\t\t * configurations reached the end of the start rule, in which case we\r\n\t\t\t * only add them back to reach if no configuration during the current\r\n\t\t\t * closure operation reached such a state. This ensures adaptivePredict\r\n\t\t\t * chooses an alternative matching the longest overall sequence when\r\n\t\t\t * multiple alternatives are viable.\r\n\t\t\t */\r\n\t\t\tif (skippedStopStates != null && (!useContext || !PredictionMode.hasConfigInRuleStopState(reach))) {\r\n\t\t\t\tassert(skippedStopStates.length > 0);\r\n\t\t\t\tfor (let c of skippedStopStates) {\r\n\t\t\t\t\treach.add(c, contextCache);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (useContext && stepIntoGlobal) {\r\n\t\t\t\treach.clear();\r\n\r\n\t\t\t\t// We know remainingGlobalContext is not undefined at this point (why?)\r\n\t\t\t\tremainingGlobalContext = remainingGlobalContext as ParserRuleContext;\r\n\r\n\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\r\n\t\t\t\tlet nextContextElement: number = this.getReturnState(remainingGlobalContext);\r\n\t\t\t\tif (contextElements == null) {\r\n\t\t\t\t\tcontextElements = new IntegerList();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (remainingGlobalContext.isEmpty) {\r\n\t\t\t\t\tremainingGlobalContext = undefined;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontextElements.add(nextContextElement);\r\n\t\t\t\tif (nextContextElement !== PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\t\tfor (let i = 0; i < closureConfigs.length; i++) {\r\n\t\t\t\t\t\tclosureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} while (useContext && stepIntoGlobal);\r\n\r\n\t\tif (reach.isEmpty) {\r\n\t\t\tthis.setDFAEdge(s, t, ATNSimulator.ERROR);\r\n\t\t\treturn [ATNSimulator.ERROR, remainingGlobalContext];\r\n\t\t}\r\n\r\n\t\tlet result: DFAState = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);\r\n\t\treturn [result, remainingGlobalContext];\r\n\t}\r\n\r\n\t/**\r\n\t * Return a configuration set containing only the configurations from\r\n\t * `configs` which are in a {@link RuleStopState}. If all\r\n\t * configurations in `configs` are already in a rule stop state, this\r\n\t * method simply returns `configs`.\r\n\t *\r\n\t * @param configs the configuration set to update\r\n\t * @param contextCache the {@link PredictionContext} cache\r\n\t *\r\n\t * @returns `configs` if all configurations in `configs` are in a\r\n\t * rule stop state, otherwise return a new configuration set containing only\r\n\t * the configurations from `configs` which are in a rule stop state\r\n\t */\r\n\t@NotNull\r\n\tprotected removeAllConfigsNotInRuleStopState(@NotNull configs: ATNConfigSet, contextCache: PredictionContextCache): ATNConfigSet {\r\n\t\tif (PredictionMode.allConfigsInRuleStopStates(configs)) {\r\n\t\t\treturn configs;\r\n\t\t}\r\n\r\n\t\tlet result: ATNConfigSet = new ATNConfigSet();\r\n\t\tfor (let config of configs) {\r\n\t\t\tif (!(config.state instanceof RuleStopState)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tresult.add(config, contextCache);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected computeStartState(\r\n\t\tdfa: DFA,\r\n\t\tglobalContext: ParserRuleContext,\r\n\t\tuseContext: boolean): SimulatorState {\r\n\t\tlet s0: DFAState | undefined =\r\n\t\t\tdfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) :\r\n\t\t\t\tuseContext ? dfa.s0full :\r\n\t\t\t\t\tdfa.s0;\r\n\r\n\t\tif (s0 != null) {\r\n\t\t\tif (!useContext) {\r\n\t\t\t\treturn new SimulatorState(globalContext, s0, useContext, globalContext);\r\n\t\t\t}\r\n\r\n\t\t\ts0.setContextSensitive(this.atn);\r\n\t\t}\r\n\r\n\t\tlet decision: number = dfa.decision;\r\n\t\t// @NotNull\r\n\t\tlet p: ATNState = dfa.atnStartState;\r\n\r\n\t\tlet previousContext: number = 0;\r\n\t\tlet remainingGlobalContext: ParserRuleContext | undefined = globalContext;\r\n\t\tlet initialContext: PredictionContext = useContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL; // always at least the implicit call to start rule\r\n\t\tlet contextCache: PredictionContextCache = new PredictionContextCache();\r\n\t\tif (useContext) {\r\n\t\t\tif (!this.enable_global_context_dfa) {\r\n\t\t\t\twhile (remainingGlobalContext != null) {\r\n\t\t\t\t\tif (remainingGlobalContext.isEmpty) {\r\n\t\t\t\t\t\tpreviousContext = PredictionContext.EMPTY_FULL_STATE_KEY;\r\n\t\t\t\t\t\tremainingGlobalContext = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpreviousContext = this.getReturnState(remainingGlobalContext);\r\n\t\t\t\t\t\tinitialContext = initialContext.appendSingleContext(previousContext, contextCache);\r\n\t\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {\r\n\t\t\t\tlet next: DFAState | undefined;\r\n\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\r\n\t\t\t\tif (remainingGlobalContext.isEmpty) {\r\n\t\t\t\t\tnext = s0.getContextTarget(PredictionContext.EMPTY_FULL_STATE_KEY);\r\n\t\t\t\t\tpreviousContext = PredictionContext.EMPTY_FULL_STATE_KEY;\r\n\t\t\t\t\tremainingGlobalContext = undefined;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpreviousContext = this.getReturnState(remainingGlobalContext);\r\n\t\t\t\t\tnext = s0.getContextTarget(previousContext);\r\n\t\t\t\t\tinitialContext = initialContext.appendSingleContext(previousContext, contextCache);\r\n\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (next == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ts0 = next;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (s0 != null && !s0.isContextSensitive) {\r\n\t\t\treturn new SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\r\n\t\t}\r\n\r\n\t\tlet configs: ATNConfigSet = new ATNConfigSet();\r\n\t\twhile (true) {\r\n\t\t\tlet reachIntermediate: ATNConfigSet = new ATNConfigSet();\r\n\t\t\tlet n: number = p.numberOfTransitions;\r\n\t\t\tfor (let ti = 0; ti < n; ti++) {\r\n\t\t\t\t// for each transition\r\n\t\t\t\tlet target: ATNState = p.transition(ti).target;\r\n\t\t\t\treachIntermediate.add(ATNConfig.create(target, ti + 1, initialContext));\r\n\t\t\t}\r\n\r\n\t\t\tlet hasMoreContext: boolean = remainingGlobalContext != null;\r\n\t\t\tif (!hasMoreContext) {\r\n\t\t\t\tconfigs.isOutermostConfigSet = true;\r\n\t\t\t}\r\n\r\n\t\t\tlet collectPredicates: boolean = true;\r\n\t\t\tthis.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);\r\n\t\t\tlet stepIntoGlobal: boolean = configs.dipsIntoOuterContext;\r\n\r\n\t\t\tlet next: DFAState;\r\n\t\t\tif (useContext && !this.enable_global_context_dfa) {\r\n\t\t\t\ts0 = this.addDFAState(dfa, configs, contextCache);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse if (s0 == null) {\r\n\t\t\t\tif (!dfa.isPrecedenceDfa) {\r\n\t\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\r\n\t\t\t\t\tif (useContext) {\r\n\t\t\t\t\t\tif (!dfa.s0full) {\r\n\t\t\t\t\t\t\tdfa.s0full = next;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnext = dfa.s0full;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (!dfa.s0) {\r\n\t\t\t\t\t\t\tdfa.s0 = next;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnext = dfa.s0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t/* If this is a precedence DFA, we use applyPrecedenceFilter\r\n\t\t\t\t\t * to convert the computed start state to a precedence start\r\n\t\t\t\t\t * state. We then use DFA.setPrecedenceStartState to set the\r\n\t\t\t\t\t * appropriate start state for the precedence level rather\r\n\t\t\t\t\t * than simply setting DFA.s0.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tconfigs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\r\n\t\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\r\n\t\t\t\t\tdfa.setPrecedenceStartState(this._parser.precedence, useContext, next);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (dfa.isPrecedenceDfa) {\r\n\t\t\t\t\tconfigs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\r\n\t\t\t\ts0.setContextTarget(previousContext, next);\r\n\t\t\t}\r\n\r\n\t\t\ts0 = next;\r\n\r\n\t\t\tif (!useContext || !stepIntoGlobal) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: make sure it distinguishes empty stack states\r\n\t\t\tnext.setContextSensitive(this.atn);\r\n\r\n\t\t\t// We know remainingGlobalContext is not undefined at this point (why?)\r\n\t\t\tremainingGlobalContext = remainingGlobalContext as ParserRuleContext;\r\n\r\n\t\t\tconfigs.clear();\r\n\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\r\n\t\t\tlet nextContextElement: number = this.getReturnState(remainingGlobalContext);\r\n\r\n\t\t\tif (remainingGlobalContext.isEmpty) {\r\n\t\t\t\tremainingGlobalContext = undefined;\r\n\t\t\t} else {\r\n\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\r\n\t\t\t}\r\n\r\n\t\t\tif (nextContextElement !== PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\tinitialContext = initialContext.appendSingleContext(nextContextElement, contextCache);\r\n\t\t\t}\r\n\r\n\t\t\tpreviousContext = nextContextElement;\r\n\t\t}\r\n\r\n\t\treturn new SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\r\n\t}\r\n\r\n\t/**\r\n\t * This method transforms the start state computed by\r\n\t * {@link #computeStartState} to the special start state used by a\r\n\t * precedence DFA for a particular precedence value. The transformation\r\n\t * process applies the following changes to the start state's configuration\r\n\t * set.\r\n\t *\r\n\t * 1. Evaluate the precedence predicates for each configuration using\r\n\t *    {@link SemanticContext#evalPrecedence}.\r\n\t * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,\r\n\t *    remove all configurations which predict an alternative greater than 1,\r\n\t *    for which another configuration that predicts alternative 1 is in the\r\n\t *    same ATN state with the same prediction context. This transformation is\r\n\t *    valid for the following reasons:\r\n\t *\r\n\t *     * The closure block cannot contain any epsilon transitions which bypass\r\n\t *       the body of the closure, so all states reachable via alternative 1 are\r\n\t *       part of the precedence alternatives of the transformed left-recursive\r\n\t *       rule.\r\n\t *     * The \"primary\" portion of a left recursive rule cannot contain an\r\n\t *       epsilon transition, so the only way an alternative other than 1 can exist\r\n\t *       in a state that is also reachable via alternative 1 is by nesting calls\r\n\t *       to the left-recursive rule, with the outer calls not being at the\r\n\t *       preferred precedence level. The\r\n\t *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN\r\n\t *       configurations which do not meet this condition, and therefore are not\r\n\t *       eligible for elimination during the filtering process.\r\n\t *\r\n\t * The prediction context must be considered by this filter to address\r\n\t * situations like the following.\r\n\t *\r\n\t * ```antlr\r\n\t * grammar TA;\r\n\t * prog: statement* EOF;\r\n\t * statement: letterA | statement letterA 'b' ;\r\n\t * letterA: 'a';\r\n\t * ```\r\n\t *\r\n\t * If the above grammar, the ATN state immediately before the token\r\n\t * reference `'a'` in `letterA` is reachable from the left edge\r\n\t * of both the primary and closure blocks of the left-recursive rule\r\n\t * `statement`. The prediction context associated with each of these\r\n\t * configurations distinguishes between them, and prevents the alternative\r\n\t * which stepped out to `prog` (and then back in to `statement`\r\n\t * from being eliminated by the filter.\r\n\t *\r\n\t * @param configs The configuration set computed by\r\n\t * {@link #computeStartState} as the start state for the DFA.\r\n\t * @returns The transformed configuration set representing the start state\r\n\t * for a precedence DFA at a particular precedence level (determined by\r\n\t * calling {@link Parser#getPrecedence}).\r\n\t */\r\n\t@NotNull\r\n\tprotected applyPrecedenceFilter(@NotNull configs: ATNConfigSet, globalContext: ParserRuleContext, contextCache: PredictionContextCache): ATNConfigSet {\r\n\t\tlet statesFromAlt1: Map<number, PredictionContext> = new Map<number, PredictionContext>();\r\n\t\tlet configSet: ATNConfigSet = new ATNConfigSet();\r\n\t\tfor (let config of configs) {\r\n\t\t\t// handle alt 1 first\r\n\t\t\tif (config.alt !== 1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet updatedContext: SemanticContext | undefined = config.semanticContext.evalPrecedence(this._parser, globalContext);\r\n\t\t\tif (updatedContext == null) {\r\n\t\t\t\t// the configuration was eliminated\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tstatesFromAlt1.set(config.state.stateNumber, config.context);\r\n\t\t\tif (updatedContext !== config.semanticContext) {\r\n\t\t\t\tconfigSet.add(config.transform(config.state, false, updatedContext), contextCache);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconfigSet.add(config, contextCache);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let config of configs) {\r\n\t\t\tif (config.alt === 1) {\r\n\t\t\t\t// already handled\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (!config.isPrecedenceFilterSuppressed) {\r\n\t\t\t\t/* In the future, this elimination step could be updated to also\r\n\t\t\t\t * filter the prediction context for alternatives predicting alt>1\r\n\t\t\t\t * (basically a graph subtraction algorithm).\r\n\t\t\t\t */\r\n\t\t\t\tlet context: PredictionContext | undefined = statesFromAlt1.get(config.state.stateNumber);\r\n\t\t\t\tif (context != null && context.equals(config.context)) {\r\n\t\t\t\t\t// eliminated\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tconfigSet.add(config, contextCache);\r\n\t\t}\r\n\r\n\t\treturn configSet;\r\n\t}\r\n\r\n\tprotected getReachableTarget(@NotNull source: ATNConfig, @NotNull trans: Transition, ttype: number): ATNState | undefined {\r\n\t\tif (trans.matches(ttype, 0, this.atn.maxTokenType)) {\r\n\t\t\treturn trans.target;\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/** collect and set D's semantic context */\r\n\tprotected predicateDFAState(\r\n\t\tD: DFAState,\r\n\t\tconfigs: ATNConfigSet,\r\n\t\tnalts: number): DFAState.PredPrediction[] | undefined {\r\n\t\tlet conflictingAlts: BitSet | undefined = this.getConflictingAltsFromConfigSet(configs);\r\n\t\tif (!conflictingAlts) {\r\n\t\t\tthrow new Error(\"This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.\");\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"predicateDFAState \" + D);\r\n\t\t}\r\n\t\tlet altToPred: SemanticContext[] | undefined = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);\r\n\t\t// altToPred[uniqueAlt] is now our validating predicate (if any)\r\n\t\tlet predPredictions: DFAState.PredPrediction[] | undefined;\r\n\t\tif (altToPred != null) {\r\n\t\t\t// we have a validating predicate; test it\r\n\t\t\t// Update DFA so reach becomes accept state with predicate\r\n\t\t\tpredPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);\r\n\t\t\tD.predicates = predPredictions;\r\n\t\t}\r\n\t\treturn predPredictions;\r\n\t}\r\n\r\n\tprotected getPredsForAmbigAlts(\r\n\t\t@NotNull ambigAlts: BitSet,\r\n\t\t@NotNull configs: ATNConfigSet,\r\n\t\tnalts: number): SemanticContext[] | undefined {\r\n\t\t// REACH=[1|1|[]|0:0, 1|2|[]|0:1]\r\n\r\n\t\t/* altToPred starts as an array of all undefined contexts. The entry at index i\r\n\t\t * corresponds to alternative i. altToPred[i] may have one of three values:\r\n\t\t *   1. undefined: no ATNConfig c is found such that c.alt===i\r\n\t\t *   2. SemanticContext.NONE: At least one ATNConfig c exists such that\r\n\t\t *      c.alt===i and c.semanticContext===SemanticContext.NONE. In other words,\r\n\t\t *      alt i has at least one unpredicated config.\r\n\t\t *   3. Non-NONE Semantic Context: There exists at least one, and for all\r\n\t\t *      ATNConfig c such that c.alt===i, c.semanticContext!==SemanticContext.NONE.\r\n\t\t *\r\n\t\t * From this, it is clear that NONE||anything==NONE.\r\n\t\t */\r\n\t\tlet altToPred: Array<SemanticContext | undefined> | undefined = new Array<SemanticContext>(nalts + 1);\r\n\t\tlet n: number = altToPred.length;\r\n\t\tfor (let c of configs) {\r\n\t\t\tif (ambigAlts.get(c.alt)) {\r\n\t\t\t\taltToPred[c.alt] = SemanticContext.or(altToPred[c.alt], c.semanticContext);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet nPredAlts: number = 0;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tif (altToPred[i] == null) {\r\n\t\t\t\taltToPred[i] = SemanticContext.NONE;\r\n\t\t\t}\r\n\t\t\telse if (altToPred[i] !== SemanticContext.NONE) {\r\n\t\t\t\tnPredAlts++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// At this point we know `altToPred` doesn't contain any undefined entries\r\n\t\tlet result: SemanticContext[] | undefined = altToPred as SemanticContext[];\r\n\r\n\t\t// nonambig alts are undefined in result\r\n\t\tif (nPredAlts === 0) {\r\n\t\t\tresult = undefined;\r\n\t\t}\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"getPredsForAmbigAlts result \" + (result ? Arrays.toString(result) : \"undefined\"));\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected getPredicatePredictions(ambigAlts: BitSet | undefined, altToPred: SemanticContext[]): DFAState.PredPrediction[] | undefined {\r\n\t\tlet pairs: DFAState.PredPrediction[] = [];\r\n\t\tlet containsPredicate: boolean = false;\r\n\t\tfor (let i = 1; i < altToPred.length; i++) {\r\n\t\t\tlet pred: SemanticContext = altToPred[i];\r\n\r\n\t\t\t// unpredicated is indicated by SemanticContext.NONE\r\n\t\t\tassert(pred != null);\r\n\r\n\t\t\t// find first unpredicated but ambig alternative, if any.\r\n\t\t\t// Only ambiguous alternatives will have SemanticContext.NONE.\r\n\t\t\t// Any unambig alts or ambig naked alts after first ambig naked are ignored\r\n\t\t\t// (undefined, i) means alt i is the default prediction\r\n\t\t\t// if no (undefined, i), then no default prediction.\r\n\t\t\tif (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext.NONE) {\r\n\t\t\t\tpairs.push(new DFAState.PredPrediction(pred, i));\r\n\t\t\t}\r\n\t\t\telse if (pred !== SemanticContext.NONE) {\r\n\t\t\t\tcontainsPredicate = true;\r\n\t\t\t\tpairs.push(new DFAState.PredPrediction(pred, i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!containsPredicate) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n//\t\tSystem.out.println(Arrays.toString(altToPred)+\"->\"+pairs);\r\n\t\treturn pairs;\r\n\t}\r\n\r\n\t/** Look through a list of predicate/alt pairs, returning alts for the\r\n\t *  pairs that win. An `undefined` predicate indicates an alt containing an\r\n\t *  unpredicated config which behaves as \"always true.\"\r\n\t */\r\n\tprotected evalSemanticContext(\r\n\t\t@NotNull predPredictions: DFAState.PredPrediction[],\r\n\t\touterContext: ParserRuleContext,\r\n\t\tcomplete: boolean): BitSet {\r\n\t\tlet predictions: BitSet = new BitSet();\r\n\t\tfor (let pair of predPredictions) {\r\n\t\t\tif (pair.pred === SemanticContext.NONE) {\r\n\t\t\t\tpredictions.set(pair.alt);\r\n\t\t\t\tif (!complete) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet evaluatedResult: boolean = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);\r\n\t\t\tif (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\r\n\t\t\t\tconsole.log(\"eval pred \" + pair + \"=\" + evaluatedResult);\r\n\t\t\t}\r\n\r\n\t\t\tif (evaluatedResult) {\r\n\t\t\t\tif (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\r\n\t\t\t\t\tconsole.log(\"PREDICT \" + pair.alt);\r\n\t\t\t\t}\r\n\t\t\t\tpredictions.set(pair.alt);\r\n\t\t\t\tif (!complete) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn predictions;\r\n\t}\r\n\r\n\t/**\r\n\t * Evaluate a semantic context within a specific parser context.\r\n\t *\r\n\t * This method might not be called for every semantic context evaluated\r\n\t * during the prediction process. In particular, we currently do not\r\n\t * evaluate the following but it may change in the future:\r\n\t *\r\n\t * * Precedence predicates (represented by\r\n\t *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated\r\n\t *   through this method.\r\n\t * * Operator predicates (represented by {@link SemanticContext.AND} and\r\n\t *   {@link SemanticContext.OR}) are evaluated as a single semantic\r\n\t *   context, rather than evaluating the operands individually.\r\n\t *   Implementations which require evaluation results from individual\r\n\t *   predicates should override this method to explicitly handle evaluation of\r\n\t *   the operands within operator predicates.\r\n\t *\r\n\t * @param pred The semantic context to evaluate\r\n\t * @param parserCallStack The parser context in which to evaluate the\r\n\t * semantic context\r\n\t * @param alt The alternative which is guarded by `pred`\r\n\t *\r\n\t * @since 4.3\r\n\t */\r\n\tprotected evalSemanticContextImpl(@NotNull pred: SemanticContext, parserCallStack: ParserRuleContext, alt: number): boolean {\r\n\t\treturn pred.eval(this._parser, parserCallStack);\r\n\t}\r\n\r\n\t/* TODO: If we are doing predicates, there is no point in pursuing\r\n\t\t closure operations if we reach a DFA state that uniquely predicts\r\n\t\t alternative. We will not be caching that DFA state and it is a\r\n\t\t waste to pursue the closure. Might have to advance when we do\r\n\t\t ambig detection thought :(\r\n\t\t  */\r\n\r\n\tprotected closure(\r\n\t\tsourceConfigs: ATNConfigSet,\r\n\t\t@NotNull configs: ATNConfigSet,\r\n\t\tcollectPredicates: boolean,\r\n\t\thasMoreContext: boolean,\r\n\t\t@Nullable contextCache: PredictionContextCache,\r\n\t\ttreatEofAsEpsilon: boolean): void {\r\n\t\tif (contextCache == null) {\r\n\t\t\tcontextCache = PredictionContextCache.UNCACHED;\r\n\t\t}\r\n\r\n\t\tlet currentConfigs: ATNConfigSet = sourceConfigs;\r\n\t\tlet closureBusy: Array2DHashSet<ATNConfig> = new Array2DHashSet<ATNConfig>(ObjectEqualityComparator.INSTANCE);\r\n\t\twhile (currentConfigs.size > 0) {\r\n\t\t\tlet intermediate: ATNConfigSet = new ATNConfigSet();\r\n\t\t\tfor (let config of currentConfigs) {\r\n\t\t\t\tthis.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);\r\n\t\t\t}\r\n\r\n\t\t\tcurrentConfigs = intermediate;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected closureImpl(\r\n\t\t@NotNull config: ATNConfig,\r\n\t\t@NotNull configs: ATNConfigSet,\r\n\t\t@Nullable intermediate: ATNConfigSet,\r\n\t\t@NotNull closureBusy: Array2DHashSet<ATNConfig>,\r\n\t\tcollectPredicates: boolean,\r\n\t\thasMoreContexts: boolean,\r\n\t\t@NotNull contextCache: PredictionContextCache,\r\n\t\tdepth: number,\r\n\t\ttreatEofAsEpsilon: boolean): void {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"closure(\" + config.toString(this._parser, true) + \")\");\r\n\t\t}\r\n\r\n\t\tif (config.state instanceof RuleStopState) {\r\n\t\t\t// We hit rule end. If we have context info, use it\r\n\t\t\tif (!config.context.isEmpty) {\r\n\t\t\t\tlet hasEmpty: boolean = config.context.hasEmpty;\r\n\t\t\t\tlet nonEmptySize: number = config.context.size - (hasEmpty ? 1 : 0);\r\n\t\t\t\tfor (let i = 0; i < nonEmptySize; i++) {\r\n\t\t\t\t\tlet newContext: PredictionContext = config.context.getParent(i); // \"pop\" return state\r\n\t\t\t\t\tlet returnState: ATNState = this.atn.states[config.context.getReturnState(i)];\r\n\t\t\t\t\tlet c: ATNConfig = ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);\r\n\t\t\t\t\t// While we have context to pop back from, we may have\r\n\t\t\t\t\t// gotten that context AFTER having fallen off a rule.\r\n\t\t\t\t\t// Make sure we track that we are now out of context.\r\n\t\t\t\t\tc.outerContextDepth = config.outerContextDepth;\r\n\t\t\t\t\tc.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;\r\n\t\t\t\t\tassert(depth > MIN_INTEGER_VALUE);\r\n\t\t\t\t\tthis.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!hasEmpty || !hasMoreContexts) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconfig = config.transform(config.state, false, PredictionContext.EMPTY_LOCAL);\r\n\t\t\t}\r\n\t\t\telse if (!hasMoreContexts) {\r\n\t\t\t\tconfigs.add(config, contextCache);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// else if we have no context info, just chase follow links (if greedy)\r\n\t\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\t\tconsole.log(\"FALLING off rule \" +\r\n\t\t\t\t\t\tthis.getRuleName(config.state.ruleIndex));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (config.context === PredictionContext.EMPTY_FULL) {\r\n\t\t\t\t\t// no need to keep full context overhead when we step out\r\n\t\t\t\t\tconfig = config.transform(config.state, false, PredictionContext.EMPTY_LOCAL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!config.reachesIntoOuterContext && PredictionContext.isEmptyLocal(config.context)) {\r\n\t\t\t\t\t// add stop state when leaving decision rule for the first time\r\n\t\t\t\t\tconfigs.add(config, contextCache);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet p: ATNState = config.state;\r\n\t\t// optimization\r\n\t\tif (!p.onlyHasEpsilonTransitions) {\r\n\t\t\tconfigs.add(config, contextCache);\r\n\t\t\t// make sure to not return here, because EOF transitions can act as\r\n\t\t\t// both epsilon transitions and non-epsilon transitions.\r\n\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\tconsole.log(\"added config \" + configs);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\r\n\t\t\t// This block implements first-edge elimination of ambiguous LR\r\n\t\t\t// alternatives as part of dynamic disambiguation during prediction.\r\n\t\t\t// See antlr/antlr4#1398.\r\n\t\t\tif (i === 0\r\n\t\t\t\t&& p.stateType === ATNStateType.STAR_LOOP_ENTRY\r\n\t\t\t\t&& (p as StarLoopEntryState).precedenceRuleDecision\r\n\t\t\t\t&& !config.context.hasEmpty) {\r\n\r\n\t\t\t\tlet precedenceDecision = p as StarLoopEntryState;\r\n\r\n\t\t\t\t// When suppress is true, it means the outgoing edge i==0 is\r\n\t\t\t\t// ambiguous with the outgoing edge i==1, and thus the closure\r\n\t\t\t\t// operation can dynamically disambiguate by suppressing this\r\n\t\t\t\t// edge during the closure operation.\r\n\t\t\t\tlet suppress: boolean = true;\r\n\t\t\t\tfor (let j: number = 0; j < config.context.size; j++) {\r\n\t\t\t\t\tif (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {\r\n\t\t\t\t\t\tsuppress = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (suppress) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet t: Transition = p.getOptimizedTransition(i);\r\n\t\t\tlet continueCollecting: boolean =\r\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\r\n\t\t\tlet c: ATNConfig | undefined = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);\r\n\t\t\tif (c != null) {\r\n\t\t\t\tif (t instanceof RuleTransition) {\r\n\t\t\t\t\tif (intermediate != null && !collectPredicates) {\r\n\t\t\t\t\t\tintermediate.add(c, contextCache);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet newDepth: number = depth;\r\n\t\t\t\tif (config.state instanceof RuleStopState) {\r\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\r\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\r\n\t\t\t\t\t// track how far we dip into outer context.  Might\r\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\r\n\t\t\t\t\t// preds if this is > 0.\r\n\r\n\t\t\t\t\tif (this.dfa != null && this.dfa.isPrecedenceDfa) {\r\n\t\t\t\t\t\tlet outermostPrecedenceReturn: number = (t as EpsilonTransition).outermostPrecedenceReturn;\r\n\t\t\t\t\t\tif (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {\r\n\t\t\t\t\t\t\tc.isPrecedenceFilterSuppressed = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tc.outerContextDepth = c.outerContextDepth + 1;\r\n\r\n\t\t\t\t\tif (!closureBusy.add(c)) {\r\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tassert(newDepth > MIN_INTEGER_VALUE);\r\n\t\t\t\t\tnewDepth--;\r\n\t\t\t\t\tif (ParserATNSimulator.debug) {\r\n\t\t\t\t\t\tconsole.log(\"dips into outer ctx: \" + c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (t instanceof RuleTransition) {\r\n\t\t\t\t\tif (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext.isEmptyLocal(config.context))) {\r\n\t\t\t\t\t\tassert(c.context === config.context);\r\n\t\t\t\t\t\tif (newDepth === 0) {\r\n\t\t\t\t\t\t\t// the pop/push of a tail call would keep the depth\r\n\t\t\t\t\t\t\t// constant, except we latch if it goes negative\r\n\t\t\t\t\t\t\tnewDepth--;\r\n\t\t\t\t\t\t\tif (!this.tail_call_preserves_sll && PredictionContext.isEmptyLocal(config.context)) {\r\n\t\t\t\t\t\t\t\t// make sure the SLL config \"dips into the outer context\" or prediction may not fall back to LL on conflict\r\n\t\t\t\t\t\t\t\tc.outerContextDepth = c.outerContextDepth + 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\r\n\t\t\t\t\t\tif (newDepth >= 0) {\r\n\t\t\t\t\t\t\tnewDepth++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (!t.isEpsilon && !closureBusy.add(c)) {\r\n\t\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getRuleName(index: number): string {\r\n\t\tif (this._parser != null && index >= 0) {\r\n\t\t\treturn this._parser.ruleNames[index];\r\n\t\t}\r\n\t\treturn \"<rule \" + index + \">\";\r\n\t}\r\n\r\n\tprotected getEpsilonTarget(@NotNull config: ATNConfig, @NotNull t: Transition, collectPredicates: boolean, inContext: boolean, contextCache: PredictionContextCache, treatEofAsEpsilon: boolean): ATNConfig | undefined {\r\n\t\tswitch (t.serializationType) {\r\n\t\tcase TransitionType.RULE:\r\n\t\t\treturn this.ruleTransition(config, t as RuleTransition, contextCache);\r\n\r\n\t\tcase TransitionType.PRECEDENCE:\r\n\t\t\treturn this.precedenceTransition(config, t as PrecedencePredicateTransition, collectPredicates, inContext);\r\n\r\n\t\tcase TransitionType.PREDICATE:\r\n\t\t\treturn this.predTransition(config, t as PredicateTransition, collectPredicates, inContext);\r\n\r\n\t\tcase TransitionType.ACTION:\r\n\t\t\treturn this.actionTransition(config, t as ActionTransition);\r\n\r\n\t\tcase TransitionType.EPSILON:\r\n\t\t\treturn config.transform(t.target, false);\r\n\r\n\t\tcase TransitionType.ATOM:\r\n\t\tcase TransitionType.RANGE:\r\n\t\tcase TransitionType.SET:\r\n\t\t\t// EOF transitions act like epsilon transitions after the first EOF\r\n\t\t\t// transition is traversed\r\n\t\t\tif (treatEofAsEpsilon) {\r\n\t\t\t\tif (t.matches(Token.EOF, 0, 1)) {\r\n\t\t\t\t\treturn config.transform(t.target, false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\r\n\t\tdefault:\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected actionTransition(@NotNull config: ATNConfig, @NotNull t: ActionTransition): ATNConfig {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\r\n\t\t}\r\n\t\treturn config.transform(t.target, false);\r\n\t}\r\n\r\n\t@Nullable\r\n\tprotected precedenceTransition(\r\n\t\t@NotNull config: ATNConfig,\r\n\t\t@NotNull pt: PrecedencePredicateTransition,\r\n\t\tcollectPredicates: boolean,\r\n\t\tinContext: boolean): ATNConfig {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\r\n\t\t\t\tpt.precedence + \">=_p\" +\r\n\t\t\t\t\", ctx dependent=true\");\r\n\t\t\tif (this._parser != null) {\r\n\t\t\t\tconsole.log(\"context surrounding pred is \" +\r\n\t\t\t\t\tthis._parser.getRuleInvocationStack());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet c: ATNConfig;\r\n\t\tif (collectPredicates && inContext) {\r\n\t\t\tlet newSemCtx: SemanticContext = SemanticContext.and(config.semanticContext, pt.predicate);\r\n\t\t\tc = config.transform(pt.target, false, newSemCtx);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc = config.transform(pt.target, false);\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"config from pred transition=\" + c);\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n\r\n\t@Nullable\r\n\tprotected predTransition(\r\n\t\t@NotNull config: ATNConfig,\r\n\t\t@NotNull pt: PredicateTransition,\r\n\t\tcollectPredicates: boolean,\r\n\t\tinContext: boolean): ATNConfig {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\r\n\t\t\t\tpt.ruleIndex + \":\" + pt.predIndex +\r\n\t\t\t\t\", ctx dependent=\" + pt.isCtxDependent);\r\n\t\t\tif (this._parser != null) {\r\n\t\t\t\tconsole.log(\"context surrounding pred is \" +\r\n\t\t\t\t\tthis._parser.getRuleInvocationStack());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet c: ATNConfig;\r\n\t\tif (collectPredicates &&\r\n\t\t\t(!pt.isCtxDependent || (pt.isCtxDependent && inContext))) {\r\n\t\t\tlet newSemCtx: SemanticContext = SemanticContext.and(config.semanticContext, pt.predicate);\r\n\t\t\tc = config.transform(pt.target, false, newSemCtx);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tc = config.transform(pt.target, false);\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"config from pred transition=\" + c);\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected ruleTransition(@NotNull config: ATNConfig, @NotNull t: RuleTransition, @Nullable contextCache: PredictionContextCache): ATNConfig {\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) +\r\n\t\t\t\t\", ctx=\" + config.context);\r\n\t\t}\r\n\r\n\t\tlet returnState: ATNState = t.followState;\r\n\t\tlet newContext: PredictionContext;\r\n\r\n\t\tif (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext.isEmptyLocal(config.context))) {\r\n\t\t\tnewContext = config.context;\r\n\t\t}\r\n\t\telse if (contextCache != null) {\r\n\t\t\tnewContext = contextCache.getChild(config.context, returnState.stateNumber);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnewContext = config.context.getChild(returnState.stateNumber);\r\n\t\t}\r\n\r\n\t\treturn config.transform(t.target, false, newContext);\r\n\t}\r\n\r\n\tprivate static STATE_ALT_SORT_COMPARATOR: (o1: ATNConfig, o2: ATNConfig) => number =\r\n\t\t(o1: ATNConfig, o2: ATNConfig): number => {\r\n\t\t\tlet diff: number = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;\r\n\t\t\tif (diff !== 0) {\r\n\t\t\t\treturn diff;\r\n\t\t\t}\r\n\r\n\t\t\tdiff = o1.alt - o2.alt;\r\n\t\t\tif (diff !== 0) {\r\n\t\t\t\treturn diff;\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\tprivate isConflicted(@NotNull configset: ATNConfigSet, contextCache: PredictionContextCache): ConflictInfo | undefined {\r\n\t\tif (configset.uniqueAlt !== ATN.INVALID_ALT_NUMBER || configset.size <= 1) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet configs: ATNConfig[] = configset.toArray();\r\n\t\tconfigs.sort(ParserATNSimulator.STATE_ALT_SORT_COMPARATOR);\r\n\r\n\t\tlet exact: boolean = !configset.dipsIntoOuterContext;\r\n\t\tlet alts: BitSet = new BitSet();\r\n\t\tlet minAlt: number = configs[0].alt;\r\n\t\talts.set(minAlt);\r\n\r\n\t\t/* Quick checks come first (single pass, no context joining):\r\n\t\t *  1. Make sure first config in the sorted list predicts the minimum\r\n\t\t *     represented alternative.\r\n\t\t *  2. Make sure every represented state has at least one configuration\r\n\t\t *     which predicts the minimum represented alternative.\r\n\t\t *  3. (exact only) make sure every represented state has at least one\r\n\t\t *     configuration which predicts each represented alternative.\r\n\t\t */\r\n\r\n\t\t// quick check 1 & 2 => if we assume #1 holds and check #2 against the\r\n\t\t// minAlt from the first state, #2 will fail if the assumption was\r\n\t\t// incorrect\r\n\t\tlet currentState: number = configs[0].state.nonStopStateNumber;\r\n\t\tfor (let config of configs) {\r\n\t\t\tlet stateNumber: number = config.state.nonStopStateNumber;\r\n\t\t\tif (stateNumber !== currentState) {\r\n\t\t\t\tif (config.alt !== minAlt) {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentState = stateNumber;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet representedAlts: BitSet;\r\n\t\tif (exact) {\r\n\t\t\tcurrentState = configs[0].state.nonStopStateNumber;\r\n\r\n\t\t\t// get the represented alternatives of the first state\r\n\t\t\trepresentedAlts = new BitSet();\r\n\t\t\tlet maxAlt: number = minAlt;\r\n\t\t\tfor (let config of configs) {\r\n\t\t\t\tif (config.state.nonStopStateNumber !== currentState) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet alt: number = config.alt;\r\n\t\t\t\trepresentedAlts.set(alt);\r\n\t\t\t\tmaxAlt = alt;\r\n\t\t\t}\r\n\r\n\t\t\t// quick check #3:\r\n\t\t\tcurrentState = configs[0].state.nonStopStateNumber;\r\n\t\t\tlet currentAlt: number = minAlt;\r\n\t\t\tfor (let config of configs) {\r\n\t\t\t\tlet stateNumber: number = config.state.nonStopStateNumber;\r\n\t\t\t\tlet alt: number = config.alt;\r\n\t\t\t\tif (stateNumber !== currentState) {\r\n\t\t\t\t\tif (currentAlt !== maxAlt) {\r\n\t\t\t\t\t\texact = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrentState = stateNumber;\r\n\t\t\t\t\tcurrentAlt = minAlt;\r\n\t\t\t\t}\r\n\t\t\t\telse if (alt !== currentAlt) {\r\n\t\t\t\t\tif (alt !== representedAlts.nextSetBit(currentAlt + 1)) {\r\n\t\t\t\t\t\texact = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrentAlt = alt;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcurrentState = configs[0].state.nonStopStateNumber;\r\n\t\tlet firstIndexCurrentState: number = 0;\r\n\t\tlet lastIndexCurrentStateMinAlt: number = 0;\r\n\t\tlet joinedCheckContext: PredictionContext = configs[0].context;\r\n\t\tfor (let i = 1; i < configs.length; i++) {\r\n\t\t\tlet config: ATNConfig = configs[i];\r\n\t\t\tif (config.alt !== minAlt) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (config.state.nonStopStateNumber !== currentState) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlastIndexCurrentStateMinAlt = i;\r\n\t\t\tjoinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);\r\n\t\t}\r\n\r\n\t\tfor (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {\r\n\t\t\tlet config: ATNConfig = configs[i];\r\n\t\t\tlet state: ATNState = config.state;\r\n\t\t\talts.set(config.alt);\r\n\t\t\tif (state.nonStopStateNumber !== currentState) {\r\n\t\t\t\tcurrentState = state.nonStopStateNumber;\r\n\t\t\t\tfirstIndexCurrentState = i;\r\n\t\t\t\tlastIndexCurrentStateMinAlt = i;\r\n\t\t\t\tjoinedCheckContext = config.context;\r\n\t\t\t\tfor (let j = firstIndexCurrentState + 1; j < configs.length; j++) {\r\n\t\t\t\t\tlet config2: ATNConfig = configs[j];\r\n\t\t\t\t\tif (config2.alt !== minAlt) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (config2.state.nonStopStateNumber !== currentState) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlastIndexCurrentStateMinAlt = j;\r\n\t\t\t\t\tjoinedCheckContext = contextCache.join(joinedCheckContext, config2.context);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti = lastIndexCurrentStateMinAlt;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet joinedCheckContext2: PredictionContext = config.context;\r\n\t\t\tlet currentAlt: number = config.alt;\r\n\t\t\tlet lastIndexCurrentStateCurrentAlt: number = i;\r\n\t\t\tfor (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {\r\n\t\t\t\tlet config2: ATNConfig = configs[j];\r\n\t\t\t\tif (config2.alt !== currentAlt) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (config2.state.nonStopStateNumber !== currentState) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlastIndexCurrentStateCurrentAlt = j;\r\n\t\t\t\tjoinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);\r\n\t\t\t}\r\n\r\n\t\t\ti = lastIndexCurrentStateCurrentAlt;\r\n\r\n\t\t\tlet check: PredictionContext = contextCache.join(joinedCheckContext, joinedCheckContext2);\r\n\t\t\tif (!joinedCheckContext.equals(check)) {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\r\n\t\t\t// update exact if necessary\r\n\t\t\texact = exact && joinedCheckContext.equals(joinedCheckContext2);\r\n\t\t}\r\n\r\n\t\treturn new ConflictInfo(alts, exact);\r\n\t}\r\n\r\n\tprotected getConflictingAltsFromConfigSet(configs: ATNConfigSet): BitSet | undefined {\r\n\t\tlet conflictingAlts: BitSet | undefined = configs.conflictingAlts;\r\n\t\tif (conflictingAlts == null && configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\tconflictingAlts = new BitSet();\r\n\t\t\tconflictingAlts.set(configs.uniqueAlt);\r\n\t\t}\r\n\r\n\t\treturn conflictingAlts;\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getTokenName(t: number): string {\r\n\t\tif (t === Token.EOF) {\r\n\t\t\treturn \"EOF\";\r\n\t\t}\r\n\r\n\t\tlet vocabulary: Vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl.EMPTY_VOCABULARY;\r\n\t\tlet displayName: string = vocabulary.getDisplayName(t);\r\n\t\tif (displayName === String(t)) {\r\n\t\t\treturn displayName;\r\n\t\t}\r\n\r\n\t\treturn displayName + \"<\" + t + \">\";\r\n\t}\r\n\r\n\tpublic getLookaheadName(input: TokenStream): string {\r\n\t\treturn this.getTokenName(input.LA(1));\r\n\t}\r\n\r\n\tpublic dumpDeadEndConfigs(@NotNull nvae: NoViableAltException): void {\r\n\t\tconsole.log(\"dead end configs: \");\r\n\t\tlet deadEndConfigs = nvae.deadEndConfigs;\r\n\t\tif (!deadEndConfigs) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (let c of deadEndConfigs) {\r\n\t\t\tlet trans: string = \"no edges\";\r\n\t\t\tif (c.state.numberOfOptimizedTransitions > 0) {\r\n\t\t\t\tlet t: Transition = c.state.getOptimizedTransition(0);\r\n\t\t\t\tif (t instanceof AtomTransition) {\r\n\t\t\t\t\ttrans = \"Atom \" + this.getTokenName(t._label);\r\n\t\t\t\t}\r\n\t\t\t\telse if (t instanceof SetTransition) {\r\n\t\t\t\t\tlet not: boolean = t instanceof NotSetTransition;\r\n\t\t\t\t\ttrans = (not ? \"~\" : \"\") + \"Set \" + t.set.toString();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconsole.log(c.toString(this._parser, true) + \":\" + trans);\r\n\t\t}\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected noViableAlt(\r\n\t\t@NotNull input: TokenStream,\r\n\t\t@NotNull outerContext: ParserRuleContext,\r\n\t\t@NotNull configs: ATNConfigSet,\r\n\t\tstartIndex: number): NoViableAltException {\r\n\t\treturn new NoViableAltException(this._parser, input,\r\n\t\t\tinput.get(startIndex),\r\n\t\t\tinput.LT(1),\r\n\t\t\tconfigs, outerContext);\r\n\t}\r\n\r\n\tprotected getUniqueAlt(@NotNull configs: Iterable<ATNConfig>): number {\r\n\t\tlet alt: number = ATN.INVALID_ALT_NUMBER;\r\n\t\tfor (let c of configs) {\r\n\t\t\tif (alt === ATN.INVALID_ALT_NUMBER) {\r\n\t\t\t\talt = c.alt; // found first alt\r\n\t\t\t}\r\n\t\t\telse if (c.alt !== alt) {\r\n\t\t\t\treturn ATN.INVALID_ALT_NUMBER;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn alt;\r\n\t}\r\n\r\n\tprotected configWithAltAtStopState(@NotNull configs: Iterable<ATNConfig>, alt: number): boolean {\r\n\t\tfor (let c of configs) {\r\n\t\t\tif (c.alt === alt) {\r\n\t\t\t\tif (c.state instanceof RuleStopState) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected addDFAEdge(\r\n\t\t@NotNull dfa: DFA,\r\n\t\t@NotNull fromState: DFAState,\r\n\t\tt: number,\r\n\t\tcontextTransitions: IntegerList | undefined,\r\n\t\t@NotNull toConfigs: ATNConfigSet,\r\n\t\tcontextCache: PredictionContextCache): DFAState {\r\n\t\tassert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);\r\n\r\n\t\tlet from: DFAState = fromState;\r\n\t\tlet to: DFAState = this.addDFAState(dfa, toConfigs, contextCache);\r\n\r\n\t\tif (contextTransitions != null) {\r\n\t\t\tfor (let context of contextTransitions.toArray()) {\r\n\t\t\t\tif (context === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\t\tif (from.configs.isOutermostConfigSet) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfrom.setContextSensitive(this.atn);\r\n\t\t\t\tfrom.setContextSymbol(t);\r\n\t\t\t\tlet next: DFAState | undefined = from.getContextTarget(context);\r\n\t\t\t\tif (next != null) {\r\n\t\t\t\t\tfrom = next;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnext = this.addDFAContextState(dfa, from.configs, context, contextCache);\r\n\t\t\t\tassert(context !== PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);\r\n\t\t\t\tfrom.setContextTarget(context, next);\r\n\t\t\t\tfrom = next;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\r\n\t\t}\r\n\t\tthis.setDFAEdge(from, t, to);\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"DFA=\\n\" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : undefined));\r\n\t\t}\r\n\t\treturn to;\r\n\t}\r\n\r\n\tprotected setDFAEdge(@Nullable p: DFAState, t: number, @Nullable q: DFAState): void {\r\n\t\tif (p != null) {\r\n\t\t\tp.setTarget(t, q);\r\n\t\t}\r\n\t}\r\n\r\n\t/** See comment on LexerInterpreter.addDFAState. */\r\n\t@NotNull\r\n\tprotected addDFAContextState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet, returnContext: number, contextCache: PredictionContextCache): DFAState {\r\n\t\tif (returnContext !== PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\tlet contextConfigs: ATNConfigSet = new ATNConfigSet();\r\n\t\t\tfor (let config of configs) {\r\n\t\t\t\tcontextConfigs.add(config.appendContext(returnContext, contextCache));\r\n\t\t\t}\r\n\r\n\t\t\treturn this.addDFAState(dfa, contextConfigs, contextCache);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tassert(!configs.isOutermostConfigSet, \"Shouldn't be adding a duplicate edge.\");\r\n\t\t\tconfigs = configs.clone(true);\r\n\t\t\tconfigs.isOutermostConfigSet = true;\r\n\t\t\treturn this.addDFAState(dfa, configs, contextCache);\r\n\t\t}\r\n\t}\r\n\r\n\t/** See comment on LexerInterpreter.addDFAState. */\r\n\t@NotNull\r\n\tprotected addDFAState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet, contextCache: PredictionContextCache): DFAState {\r\n\t\tlet enableDfa: boolean = this.enable_global_context_dfa || !configs.isOutermostConfigSet;\r\n\t\tif (enableDfa) {\r\n\t\t\tif (!configs.isReadOnly) {\r\n\t\t\t\tconfigs.optimizeConfigs(this);\r\n\t\t\t}\r\n\r\n\t\t\tlet proposed: DFAState = this.createDFAState(dfa, configs);\r\n\t\t\tlet existing: DFAState | undefined = dfa.states.get(proposed);\r\n\t\t\tif (existing != null) {\r\n\t\t\t\treturn existing;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!configs.isReadOnly) {\r\n\t\t\tif (configs.conflictInfo == null) {\r\n\t\t\t\tconfigs.conflictInfo = this.isConflicted(configs, contextCache);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet newState: DFAState = this.createDFAState(dfa, configs.clone(true));\r\n\t\t// getDecisionState won't return undefined when we request a known valid decision\r\n\t\tlet decisionState: DecisionState = this.atn.getDecisionState(dfa.decision) as DecisionState;\r\n\t\tlet predictedAlt: number = this.getUniqueAlt(configs);\r\n\t\tif (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(predictedAlt);\r\n\t\t} else if (configs.conflictingAlts != null) {\r\n\t\t\tlet conflictingAlts = configs.conflictingAlts;\r\n\t\t\tif (conflictingAlts) {\r\n\t\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(conflictingAlts.nextSetBit(0));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newState.isAcceptState && configs.hasSemanticContext) {\r\n\t\t\tthis.predicateDFAState(newState, configs, decisionState.numberOfTransitions);\r\n\t\t}\r\n\r\n\t\tif (!enableDfa) {\r\n\t\t\treturn newState;\r\n\t\t}\r\n\r\n\t\tlet added: DFAState = dfa.addState(newState);\r\n\t\tif (ParserATNSimulator.debug && added === newState) {\r\n\t\t\tconsole.log(\"adding new DFA state: \" + newState);\r\n\t\t}\r\n\t\treturn added;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected createDFAState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet): DFAState {\r\n\t\treturn new DFAState(configs);\r\n\t}\r\n\r\n\tprotected reportAttemptingFullContext(@NotNull dfa: DFA, conflictingAlts: BitSet | undefined, @NotNull conflictState: SimulatorState, startIndex: number, stopIndex: number): void {\r\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\r\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\r\n\t\t\tconsole.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + conflictState.s0.configs +\r\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\r\n\t\t}\r\n\t\tif (this._parser != null) {\r\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\r\n\t\t\tif (listener.reportAttemptingFullContext) {\r\n\t\t\t\tlistener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected reportContextSensitivity(@NotNull dfa: DFA, prediction: number, @NotNull acceptState: SimulatorState, startIndex: number, stopIndex: number): void {\r\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\r\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\r\n\t\t\tconsole.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + acceptState.s0.configs +\r\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\r\n\t\t}\r\n\t\tif (this._parser != null) {\r\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\r\n\t\t\tif (listener.reportContextSensitivity) {\r\n\t\t\t\tlistener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** If context sensitive parsing, we know it's ambiguity not conflict */\r\n\tprotected reportAmbiguity(\r\n\t\t@NotNull dfa: DFA,\r\n\t\tD: DFAState,  // the DFA state from execATN(): void that had SLL conflicts\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\texact: boolean,\r\n\t\t@NotNull ambigAlts: BitSet,\r\n\t\t@NotNull configs: ATNConfigSet) // configs that LL not SLL considered conflicting\r\n\t{\r\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\r\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\r\n\t\t\tconsole.log(\"reportAmbiguity \" +\r\n\t\t\t\tambigAlts + \":\" + configs +\r\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\r\n\t\t}\r\n\t\tif (this._parser != null) {\r\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\r\n\t\t\tif (listener.reportAmbiguity) {\r\n\t\t\t\tlistener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getReturnState(context: RuleContext): number {\r\n\t\tif (context.isEmpty) {\r\n\t\t\treturn PredictionContext.EMPTY_FULL_STATE_KEY;\r\n\t\t}\r\n\r\n\t\tlet state: ATNState = this.atn.states[context.invokingState];\r\n\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\r\n\t\treturn transition.followState.stateNumber;\r\n\t}\r\n\r\n\tprotected skipTailCalls(context: ParserRuleContext): ParserRuleContext {\r\n\t\tif (!this.optimize_tail_calls) {\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\twhile (!context.isEmpty) {\r\n\t\t\tlet state: ATNState = this.atn.states[context.invokingState];\r\n\t\t\tassert(state.numberOfTransitions === 1 && state.transition(0).serializationType === TransitionType.RULE);\r\n\t\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\r\n\t\t\tif (!transition.tailCall) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// This method requires that the root ancestor of the ParserRuleContext be empty. If we make it to this\r\n\t\t\t// line, we know the current node is not empty, which means it does have a parent.\r\n\t\t\tcontext = context.parent as ParserRuleContext;\r\n\t\t}\r\n\r\n\t\treturn context;\r\n\t}\r\n\r\n\t/**\r\n\t * @since 4.3\r\n\t */\r\n\tget parser(): Parser {\r\n\t\treturn this._parser;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:34.9572142-07:00\r\n\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BlockStartState } from \"./BlockStartState\";\r\nimport { Override } from \"../Decorators\";\r\nimport { PlusLoopbackState } from \"./PlusLoopbackState\";\r\n\r\n/** Start of `(A|B|...)+` loop. Technically a decision state, but\r\n *  we don't use for code generation; somebody might need it, so I'm defining\r\n *  it for completeness. In reality, the {@link PlusLoopbackState} node is the\r\n *  real decision-making note for `A+`.\r\n */\r\nexport class PlusBlockStartState extends BlockStartState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic loopBackState!: PlusLoopbackState;\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.PLUS_BLOCK_START;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.0257730-07:00\r\n\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** Decision state for `A+` and `(A|B)+`.  It has two transitions:\r\n *  one to the loop back to start of the block and one to exit.\r\n */\r\nexport class PlusLoopbackState extends DecisionState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.PLUS_LOOP_BACK;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.0994191-07:00\r\n\r\nimport { AbstractPredicateTransition } from \"./AbstractPredicateTransition\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class PrecedencePredicateTransition extends AbstractPredicateTransition {\r\n\tpublic precedence: number;\r\n\r\n\tconstructor( @NotNull target: ATNState, precedence: number) {\r\n\t\tsuper(target);\r\n\t\tthis.precedence = precedence;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.PRECEDENCE;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEpsilon(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget predicate(): SemanticContext.PrecedencePredicate {\r\n\t\treturn new SemanticContext.PrecedencePredicate(this.precedence);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this.precedence + \" >= _p\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.5959980-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\nexport class RangeTransition extends Transition {\r\n\tpublic from: number;\r\n\tpublic to: number;\r\n\r\n\tconstructor(@NotNull target: ATNState, from: number, to: number) {\r\n\t\tsuper(target);\r\n\t\tthis.from = from;\r\n\t\tthis.to = to;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.RANGE;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tget label(): IntervalSet {\r\n\t\treturn IntervalSet.of(this.from, this.to);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn symbol >= this.from && symbol <= this.to;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn \"'\" + String.fromCodePoint(this.from) + \"'..'\" + String.fromCodePoint(this.to) + \"'\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.6806851-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { Override } from \"../Decorators\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\n\r\nexport class RuleStartState extends ATNState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic stopState!: RuleStopState;\r\n\tpublic isPrecedenceRule: boolean = false;\r\n\tpublic leftFactored: boolean = false;\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.RULE_START;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.5657409-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BlockStartState } from \"./BlockStartState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** The block that begins a closure loop. */\r\nexport class StarBlockStartState extends BlockStartState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.STAR_BLOCK_START;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.6368726-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { Override } from \"../Decorators\";\r\nimport { StarLoopEntryState } from \"./StarLoopEntryState\";\r\n\r\nexport class StarLoopbackState extends ATNState {\r\n\tget loopEntryState(): StarLoopEntryState {\r\n\t\treturn this.transition(0).target as StarLoopEntryState;\r\n\t}\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.STAR_LOOP_BACK;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.7814046-07:00\r\n\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** The Tokens rule start state linking to each lexer rule start state */\r\nexport class TokensStartState extends DecisionState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.TOKEN_START;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport { Equatable } from \"./Stubs\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\n\r\nexport class UUID implements Equatable {\r\n\tprivate readonly data: Uint32Array;\r\n\r\n\tconstructor(mostSigBits: number, moreSigBits: number, lessSigBits: number, leastSigBits: number) {\r\n\t\tthis.data = new Uint32Array(4);\r\n\t\tthis.data[0] = mostSigBits;\r\n\t\tthis.data[1] = moreSigBits;\r\n\t\tthis.data[2] = lessSigBits;\r\n\t\tthis.data[3] = leastSigBits;\r\n\t}\r\n\r\n\tpublic static fromString(data: string): UUID {\r\n\t\tif (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {\r\n\t\t\tthrow new Error(\"Incorrectly formatted UUID\");\r\n\t\t}\r\n\r\n\t\tlet segments = data.split(\"-\");\r\n\t\tlet mostSigBits = parseInt(segments[0], 16);\r\n\t\tlet moreSigBits = ((parseInt(segments[1], 16) << 16) >>> 0) + parseInt(segments[2], 16);\r\n\t\tlet lessSigBits = ((parseInt(segments[3], 16) << 16) >>> 0) + parseInt(segments[4].substr(0, 4), 16);\r\n\t\tlet leastSigBits = parseInt(segments[4].substr(-8), 16);\r\n\t\treturn new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\r\n\t}\r\n\r\n\tpublic hashCode(): number {\r\n\t\treturn MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);\r\n\t}\r\n\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof UUID)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.data[0] === obj.data[0]\r\n\t\t\t&& this.data[1] === obj.data[1]\r\n\t\t\t&& this.data[2] === obj.data[2]\r\n\t\t\t&& this.data[3] === obj.data[3];\r\n\t}\r\n\r\n\tpublic toString(): string {\r\n\t\treturn (\"00000000\" + this.data[0].toString(16)).substr(-8)\r\n\t\t\t+ \"-\" + (\"0000\" + (this.data[1] >>> 16).toString(16)).substr(-4)\r\n\t\t\t+ \"-\" + (\"0000\" + this.data[1].toString(16)).substr(-4)\r\n\t\t\t+ \"-\" + (\"0000\" + (this.data[2] >>> 16).toString(16)).substr(-4)\r\n\t\t\t+ \"-\" + (\"0000\" + this.data[2].toString(16)).substr(-4)\r\n\t\t\t+ (\"00000000\" + this.data[3].toString(16)).substr(-8);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:25.9683447-07:00\r\n\r\nimport { ActionTransition } from \"./ActionTransition\";\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNDeserializationOptions } from \"./ATNDeserializationOptions\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { ATNType } from \"./ATNType\";\r\nimport { AtomTransition } from \"./AtomTransition\";\r\nimport { BasicBlockStartState } from \"./BasicBlockStartState\";\r\nimport { BasicState } from \"./BasicState\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { BlockEndState } from \"./BlockEndState\";\r\nimport { BlockStartState } from \"./BlockStartState\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { EpsilonTransition } from \"./EpsilonTransition\";\r\nimport { Interval } from \"../misc/Interval\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { InvalidState } from \"./InvalidState\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { LexerChannelAction } from \"./LexerChannelAction\";\r\nimport { LexerCustomAction } from \"./LexerCustomAction\";\r\nimport { LexerModeAction } from \"./LexerModeAction\";\r\nimport { LexerMoreAction } from \"./LexerMoreAction\";\r\nimport { LexerPopModeAction } from \"./LexerPopModeAction\";\r\nimport { LexerPushModeAction } from \"./LexerPushModeAction\";\r\nimport { LexerSkipAction } from \"./LexerSkipAction\";\r\nimport { LexerTypeAction } from \"./LexerTypeAction\";\r\nimport { LoopEndState } from \"./LoopEndState\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { NotSetTransition } from \"./NotSetTransition\";\r\nimport { ParserATNSimulator } from \"./ParserATNSimulator\";\r\nimport { PlusBlockStartState } from \"./PlusBlockStartState\";\r\nimport { PlusLoopbackState } from \"./PlusLoopbackState\";\r\nimport { PrecedencePredicateTransition } from \"./PrecedencePredicateTransition\";\r\nimport { PredicateTransition } from \"./PredicateTransition\";\r\nimport { RangeTransition } from \"./RangeTransition\";\r\nimport { RuleStartState } from \"./RuleStartState\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\nimport { SetTransition } from \"./SetTransition\";\r\nimport { StarBlockStartState } from \"./StarBlockStartState\";\r\nimport { StarLoopbackState } from \"./StarLoopbackState\";\r\nimport { StarLoopEntryState } from \"./StarLoopEntryState\";\r\nimport { Token } from \"../Token\";\r\nimport { TokensStartState } from \"./TokensStartState\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\nimport { UUID } from \"../misc/UUID\";\r\nimport { WildcardTransition } from \"./WildcardTransition\";\r\n\r\ninterface UnicodeDeserializer {\r\n\t// Wrapper for readInt() or readInt32()\r\n\treadUnicode(data: Uint16Array, p: number): number;\r\n\r\n\t// Work around Java not allowing mutation of captured variables\r\n\t// by returning amount by which to increment p after each read\r\n\treadonly size: number;\r\n}\r\n\r\nconst enum UnicodeDeserializingMode {\r\n\tUNICODE_BMP,\r\n\tUNICODE_SMP,\r\n}\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ATNDeserializer {\r\n\tstatic get SERIALIZED_VERSION(): number {\r\n\t\t/* This value should never change. Updates following this version are\r\n\t\t * reflected as change in the unique ID SERIALIZED_UUID.\r\n\t\t */\r\n\t\treturn 3;\r\n\t}\r\n\r\n\t/* WARNING: DO NOT MERGE THESE LINES. If UUIDs differ during a merge,\r\n\t * resolve the conflict by generating a new ID!\r\n\t */\r\n\r\n\t/**\r\n\t * This is the earliest supported serialized UUID.\r\n\t */\r\n\tprivate static readonly BASE_SERIALIZED_UUID: UUID = UUID.fromString(\"E4178468-DF95-44D0-AD87-F22A5D5FB6D3\");\r\n\t/**\r\n\t * This UUID indicates an extension of {@link #ADDED_PRECEDENCE_TRANSITIONS}\r\n\t * for the addition of lexer actions encoded as a sequence of\r\n\t * {@link LexerAction} instances.\r\n\t */\r\n\tprivate static readonly ADDED_LEXER_ACTIONS: UUID = UUID.fromString(\"AB35191A-1603-487E-B75A-479B831EAF6D\");\r\n\t/**\r\n\t * This UUID indicates the serialized ATN contains two sets of\r\n\t * IntervalSets, where the second set's values are encoded as\r\n\t * 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\r\n\t */\r\n\tprivate static readonly ADDED_UNICODE_SMP: UUID = UUID.fromString(\"C23FEA89-0605-4f51-AFB8-058BCAB8C91B\");\r\n\t/**\r\n\t * This list contains all of the currently supported UUIDs, ordered by when\r\n\t * the feature first appeared in this branch.\r\n\t */\r\n\tprivate static readonly SUPPORTED_UUIDS: UUID[] = [\r\n\t\tATNDeserializer.BASE_SERIALIZED_UUID,\r\n\t\tATNDeserializer.ADDED_LEXER_ACTIONS,\r\n\t\tATNDeserializer.ADDED_UNICODE_SMP,\r\n\t];\r\n\r\n\t/**\r\n\t * This is the current serialized UUID.\r\n\t */\r\n\tprivate static readonly SERIALIZED_UUID: UUID = ATNDeserializer.ADDED_UNICODE_SMP;\r\n\r\n\t@NotNull\r\n\tprivate readonly deserializationOptions: ATNDeserializationOptions;\r\n\r\n\tconstructor(deserializationOptions?: ATNDeserializationOptions) {\r\n\t\tif (deserializationOptions === undefined) {\r\n\t\t\tdeserializationOptions = ATNDeserializationOptions.defaultOptions;\r\n\t\t}\r\n\r\n\t\tthis.deserializationOptions = deserializationOptions;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if a particular serialized representation of an ATN supports\r\n\t * a particular feature, identified by the {@link UUID} used for serializing\r\n\t * the ATN at the time the feature was first introduced.\r\n\t *\r\n\t * @param feature The {@link UUID} marking the first time the feature was\r\n\t * supported in the serialized ATN.\r\n\t * @param actualUuid The {@link UUID} of the actual serialized ATN which is\r\n\t * currently being deserialized.\r\n\t * @returns `true` if the `actualUuid` value represents a\r\n\t * serialized ATN at or after the feature identified by `feature` was\r\n\t * introduced; otherwise, `false`.\r\n\t */\r\n\tprotected static isFeatureSupported(feature: UUID, actualUuid: UUID): boolean {\r\n\t\tlet featureIndex: number = ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));\r\n\t\tif (featureIndex < 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;\r\n\t}\r\n\r\n\tprivate static getUnicodeDeserializer(mode: UnicodeDeserializingMode): UnicodeDeserializer {\r\n\t\tif (mode === UnicodeDeserializingMode.UNICODE_BMP) {\r\n\t\t\treturn {\r\n\t\t\t\treadUnicode: (data: Uint16Array, p: number): number => {\r\n\t\t\t\t\treturn ATNDeserializer.toInt(data[p]);\r\n\t\t\t\t},\r\n\t\t\t\tsize: 1,\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\treadUnicode: (data: Uint16Array, p: number): number => {\r\n\t\t\t\t\treturn ATNDeserializer.toInt32(data, p);\r\n\t\t\t\t},\r\n\t\t\t\tsize: 2,\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tpublic deserialize(@NotNull data: Uint16Array): ATN {\r\n\t\tdata = data.slice(0);\r\n\r\n\t\t// Each Uint16 value in data is shifted by +2 at the entry to this method. This is an encoding optimization\r\n\t\t// targeting the serialized values 0 and -1 (serialized to 0xFFFF), each of which are very common in the\r\n\t\t// serialized form of the ATN. In the modified UTF-8 that Java uses for compiled string literals, these two\r\n\t\t// character values have multi-byte forms. By shifting each value by +2, they become characters 2 and 1 prior to\r\n\t\t// writing the string, each of which have single-byte representations. Since the shift occurs in the tool during\r\n\t\t// ATN serialization, each target is responsible for adjusting the values during deserialization.\r\n\t\t//\r\n\t\t// As a special case, note that the first element of data is not adjusted because it contains the major version\r\n\t\t// number of the serialized ATN, which was fixed at 3 at the time the value shifting was implemented.\r\n\t\tfor (let i = 1; i < data.length; i++) {\r\n\t\t\tdata[i] = (data[i] - 2) & 0xFFFF;\r\n\t\t}\r\n\r\n\t\tlet p: number = 0;\r\n\t\tlet version: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tif (version !== ATNDeserializer.SERIALIZED_VERSION) {\r\n\t\t\tlet reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;\r\n\t\t\tthrow new Error(reason);\r\n\t\t}\r\n\r\n\t\tlet uuid: UUID = ATNDeserializer.toUUID(data, p);\r\n\t\tp += 8;\r\n\t\tif (ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {\r\n\t\t\tlet reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;\r\n\t\t\tthrow new Error(reason);\r\n\t\t}\r\n\r\n\t\tlet supportsLexerActions: boolean = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);\r\n\r\n\t\tlet grammarType: ATNType = ATNDeserializer.toInt(data[p++]);\r\n\t\tlet maxTokenType: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tlet atn: ATN = new ATN(grammarType, maxTokenType);\r\n\r\n\t\t//\r\n\t\t// STATES\r\n\t\t//\r\n\t\tlet loopBackStateNumbers: Array<[LoopEndState, number]> = [];\r\n\t\tlet endStateNumbers: Array<[BlockStartState, number]> = [];\r\n\t\tlet nstates: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < nstates; i++) {\r\n\t\t\tlet stype: ATNStateType = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t// ignore bad type of states\r\n\t\t\tif (stype === ATNStateType.INVALID_TYPE) {\r\n\t\t\t\tatn.addState(new InvalidState());\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet ruleIndex: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\tif (ruleIndex === 0xFFFF) {\r\n\t\t\t\truleIndex = -1;\r\n\t\t\t}\r\n\r\n\t\t\tlet s: ATNState = this.stateFactory(stype, ruleIndex);\r\n\t\t\tif (stype === ATNStateType.LOOP_END) { // special case\r\n\t\t\t\tlet loopBackStateNumber: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\tloopBackStateNumbers.push([s as LoopEndState, loopBackStateNumber]);\r\n\t\t\t}\r\n\t\t\telse if (s instanceof BlockStartState) {\r\n\t\t\t\tlet endStateNumber: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\tendStateNumbers.push([s, endStateNumber]);\r\n\t\t\t}\r\n\t\t\tatn.addState(s);\r\n\t\t}\r\n\r\n\t\t// delay the assignment of loop back and end states until we know all the state instances have been initialized\r\n\t\tfor (let pair of loopBackStateNumbers) {\r\n\t\t\tpair[0].loopBackState = atn.states[pair[1]];\r\n\t\t}\r\n\r\n\t\tfor (let pair of endStateNumbers) {\r\n\t\t\tpair[0].endState = atn.states[pair[1]] as BlockEndState;\r\n\t\t}\r\n\r\n\t\tlet numNonGreedyStates: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < numNonGreedyStates; i++) {\r\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t(atn.states[stateNumber] as DecisionState).nonGreedy = true;\r\n\t\t}\r\n\r\n\t\tlet numSllDecisions: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < numSllDecisions; i++) {\r\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t(atn.states[stateNumber] as DecisionState).sll = true;\r\n\t\t}\r\n\r\n\t\tlet numPrecedenceStates: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < numPrecedenceStates; i++) {\r\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t(atn.states[stateNumber] as RuleStartState).isPrecedenceRule = true;\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// RULES\r\n\t\t//\r\n\t\tlet nrules: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tif (atn.grammarType === ATNType.LEXER) {\r\n\t\t\tatn.ruleToTokenType = new Int32Array(nrules);\r\n\t\t}\r\n\r\n\t\tatn.ruleToStartState = new Array<RuleStartState>(nrules);\r\n\t\tfor (let i = 0; i < nrules; i++) {\r\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\tlet startState: RuleStartState = atn.states[s] as RuleStartState;\r\n\t\t\tstartState.leftFactored = ATNDeserializer.toInt(data[p++]) !== 0;\r\n\t\t\tatn.ruleToStartState[i] = startState;\r\n\t\t\tif (atn.grammarType === ATNType.LEXER) {\r\n\t\t\t\tlet tokenType: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\tif (tokenType === 0xFFFF) {\r\n\t\t\t\t\ttokenType = Token.EOF;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tatn.ruleToTokenType[i] = tokenType;\r\n\r\n\t\t\t\tif (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {\r\n\t\t\t\t\t// this piece of unused metadata was serialized prior to the\r\n\t\t\t\t\t// addition of LexerAction\r\n\t\t\t\t\tlet actionIndexIgnored: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\t\tif (actionIndexIgnored === 0xFFFF) {\r\n\t\t\t\t\t\tactionIndexIgnored = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tatn.ruleToStopState = new Array<RuleStopState>(nrules);\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tif (!(state instanceof RuleStopState)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tatn.ruleToStopState[state.ruleIndex] = state;\r\n\t\t\tatn.ruleToStartState[state.ruleIndex].stopState = state;\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// MODES\r\n\t\t//\r\n\t\tlet nmodes: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < nmodes; i++) {\r\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\tatn.modeToStartState.push(atn.states[s] as TokensStartState);\r\n\t\t}\r\n\r\n\t\tatn.modeToDFA = new Array<DFA>(nmodes);\r\n\t\tfor (let i = 0; i < nmodes; i++) {\r\n\t\t\tatn.modeToDFA[i] = new DFA(atn.modeToStartState[i]);\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// SETS\r\n\t\t//\r\n\t\tlet sets: IntervalSet[] = [];\r\n\r\n\t\t// First, read all sets with 16-bit Unicode code points <= U+FFFF.\r\n\t\tp = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_BMP));\r\n\r\n\t\t// Next, if the ATN was serialized with the Unicode SMP feature,\r\n\t\t// deserialize sets with 32-bit arguments <= U+10FFFF.\r\n\t\tif (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {\r\n\t\t\tp = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_SMP));\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// EDGES\r\n\t\t//\r\n\t\tlet nedges: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < nedges; i++) {\r\n\t\t\tlet src: number = ATNDeserializer.toInt(data[p]);\r\n\t\t\tlet trg: number = ATNDeserializer.toInt(data[p + 1]);\r\n\t\t\tlet ttype: number = ATNDeserializer.toInt(data[p + 2]);\r\n\t\t\tlet arg1: number = ATNDeserializer.toInt(data[p + 3]);\r\n\t\t\tlet arg2: number = ATNDeserializer.toInt(data[p + 4]);\r\n\t\t\tlet arg3: number = ATNDeserializer.toInt(data[p + 5]);\r\n\t\t\tlet trans: Transition = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\r\n\t\t\t// console.log(`EDGE ${trans.constructor.name} ${src}->${trg} ${Transition.serializationNames[ttype]} ${arg1},${arg2},${arg3}`);\r\n\t\t\tlet srcState: ATNState = atn.states[src];\r\n\t\t\tsrcState.addTransition(trans);\r\n\t\t\tp += 6;\r\n\t\t}\r\n\r\n\t\t// edges for rule stop states can be derived, so they aren't serialized\r\n\t\tinterface T { stopState: number; returnState: number; outermostPrecedenceReturn: number; }\r\n\t\tlet returnTransitionsSet = new Array2DHashSet<T>({\r\n\t\t\thashCode: (o: T) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,\r\n\r\n\t\t\tequals: (a: T, b: T): boolean => {\r\n\t\t\t\treturn a.stopState === b.stopState\r\n\t\t\t\t\t&& a.returnState === b.returnState\r\n\t\t\t\t\t&& a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;\r\n\t\t\t},\r\n\t\t});\r\n\t\tlet returnTransitions: T[] = [];\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tlet returningToLeftFactored: boolean = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;\r\n\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\r\n\t\t\t\tlet t: Transition = state.transition(i);\r\n\t\t\t\tif (!(t instanceof RuleTransition)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet ruleTransition: RuleTransition = t;\r\n\t\t\t\tlet returningFromLeftFactored: boolean = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;\r\n\t\t\t\tif (!returningFromLeftFactored && returningToLeftFactored) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet outermostPrecedenceReturn: number = -1;\r\n\t\t\t\tif (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {\r\n\t\t\t\t\tif (ruleTransition.precedence === 0) {\r\n\t\t\t\t\t\toutermostPrecedenceReturn = ruleTransition.target.ruleIndex;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };\r\n\t\t\t\tif (returnTransitionsSet.add(current)) {\r\n\t\t\t\t\treturnTransitions.push(current);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add all elements from returnTransitions to the ATN\r\n\t\tfor (let returnTransition of returnTransitions) {\r\n\t\t\tlet transition = new EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);\r\n\t\t\tatn.ruleToStopState[returnTransition.stopState].addTransition(transition);\r\n\t\t}\r\n\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tif (state instanceof BlockStartState) {\r\n\t\t\t\t// we need to know the end state to set its start state\r\n\t\t\t\tif (state.endState === undefined) {\r\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// block end states can only be associated to a single block start state\r\n\t\t\t\tif (state.endState.startState !== undefined) {\r\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.endState.startState = state;\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof PlusLoopbackState) {\r\n\t\t\t\tlet loopbackState: PlusLoopbackState = state;\r\n\t\t\t\tfor (let i = 0; i < loopbackState.numberOfTransitions; i++) {\r\n\t\t\t\t\tlet target: ATNState = loopbackState.transition(i).target;\r\n\t\t\t\t\tif (target instanceof PlusBlockStartState) {\r\n\t\t\t\t\t\ttarget.loopBackState = loopbackState;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (state instanceof StarLoopbackState) {\r\n\t\t\t\tlet loopbackState: StarLoopbackState = state;\r\n\t\t\t\tfor (let i = 0; i < loopbackState.numberOfTransitions; i++) {\r\n\t\t\t\t\tlet target: ATNState = loopbackState.transition(i).target;\r\n\t\t\t\t\tif (target instanceof StarLoopEntryState) {\r\n\t\t\t\t\t\ttarget.loopBackState = loopbackState;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// DECISIONS\r\n\t\t//\r\n\t\tlet ndecisions: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 1; i <= ndecisions; i++) {\r\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\tlet decState: DecisionState = atn.states[s] as DecisionState;\r\n\t\t\tatn.decisionToState.push(decState);\r\n\t\t\tdecState.decision = i - 1;\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// LEXER ACTIONS\r\n\t\t//\r\n\t\tif (atn.grammarType === ATNType.LEXER) {\r\n\t\t\tif (supportsLexerActions) {\r\n\t\t\t\tatn.lexerActions = new Array<LexerAction>(ATNDeserializer.toInt(data[p++]));\r\n\t\t\t\tfor (let i = 0; i < atn.lexerActions.length; i++) {\r\n\t\t\t\t\tlet actionType: LexerActionType = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\t\tlet data1: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\t\tif (data1 === 0xFFFF) {\r\n\t\t\t\t\t\tdata1 = -1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet data2: number = ATNDeserializer.toInt(data[p++]);\r\n\t\t\t\t\tif (data2 === 0xFFFF) {\r\n\t\t\t\t\t\tdata2 = -1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet lexerAction: LexerAction = this.lexerActionFactory(actionType, data1, data2);\r\n\r\n\t\t\t\t\tatn.lexerActions[i] = lexerAction;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// for compatibility with older serialized ATNs, convert the old\r\n\t\t\t\t// serialized action index for action transitions to the new\r\n\t\t\t\t// form, which is the index of a LexerCustomAction\r\n\t\t\t\tlet legacyLexerActions: LexerAction[] = [];\r\n\t\t\t\tfor (let state of atn.states) {\r\n\t\t\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\r\n\t\t\t\t\t\tlet transition: Transition = state.transition(i);\r\n\t\t\t\t\t\tif (!(transition instanceof ActionTransition)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet ruleIndex: number = transition.ruleIndex;\r\n\t\t\t\t\t\tlet actionIndex: number = transition.actionIndex;\r\n\t\t\t\t\t\tlet lexerAction: LexerCustomAction = new LexerCustomAction(ruleIndex, actionIndex);\r\n\t\t\t\t\t\tstate.setTransition(i, new ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));\r\n\t\t\t\t\t\tlegacyLexerActions.push(lexerAction);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tatn.lexerActions = legacyLexerActions;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.markPrecedenceDecisions(atn);\r\n\r\n\t\tatn.decisionToDFA = new Array<DFA>(ndecisions);\r\n\t\tfor (let i = 0; i < ndecisions; i++) {\r\n\t\t\tatn.decisionToDFA[i] = new DFA(atn.decisionToState[i], i);\r\n\t\t}\r\n\r\n\t\tif (this.deserializationOptions.isVerifyATN) {\r\n\t\t\tthis.verifyATN(atn);\r\n\t\t}\r\n\r\n\t\tif (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {\r\n\t\t\tatn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);\r\n\t\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n\t\t\t\tatn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n\t\t\t\tlet bypassStart: BasicBlockStartState = new BasicBlockStartState();\r\n\t\t\t\tbypassStart.ruleIndex = i;\r\n\t\t\t\tatn.addState(bypassStart);\r\n\r\n\t\t\t\tlet bypassStop: BlockEndState = new BlockEndState();\r\n\t\t\t\tbypassStop.ruleIndex = i;\r\n\t\t\t\tatn.addState(bypassStop);\r\n\r\n\t\t\t\tbypassStart.endState = bypassStop;\r\n\t\t\t\tatn.defineDecisionState(bypassStart);\r\n\r\n\t\t\t\tbypassStop.startState = bypassStart;\r\n\r\n\t\t\t\tlet endState: ATNState | undefined;\r\n\t\t\t\tlet excludeTransition: Transition | undefined;\r\n\t\t\t\tif (atn.ruleToStartState[i].isPrecedenceRule) {\r\n\t\t\t\t\t// wrap from the beginning of the rule to the StarLoopEntryState\r\n\t\t\t\t\tendState = undefined;\r\n\t\t\t\t\tfor (let state of atn.states) {\r\n\t\t\t\t\t\tif (state.ruleIndex !== i) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!(state instanceof StarLoopEntryState)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet maybeLoopEndState: ATNState = state.transition(state.numberOfTransitions - 1).target;\r\n\t\t\t\t\t\tif (!(maybeLoopEndState instanceof LoopEndState)) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\r\n\t\t\t\t\t\t\tendState = state;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!endState) {\r\n\t\t\t\t\t\tthrow new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texcludeTransition = (endState as StarLoopEntryState).loopBackState.transition(0);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tendState = atn.ruleToStopState[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// all non-excluded transitions that currently target end state need to target blockEnd instead\r\n\t\t\t\tfor (let state of atn.states) {\r\n\t\t\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\r\n\t\t\t\t\t\tlet transition = state.transition(i);\r\n\t\t\t\t\t\tif (transition === excludeTransition) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (transition.target === endState) {\r\n\t\t\t\t\t\t\ttransition.target = bypassStop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// all transitions leaving the rule start state need to leave blockStart instead\r\n\t\t\t\twhile (atn.ruleToStartState[i].numberOfTransitions > 0) {\r\n\t\t\t\t\tlet transition: Transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);\r\n\t\t\t\t\tbypassStart.addTransition(transition);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// link the new states\r\n\t\t\t\tatn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\r\n\t\t\t\tbypassStop.addTransition(new EpsilonTransition(endState));\r\n\r\n\t\t\t\tlet matchState: ATNState = new BasicState();\r\n\t\t\t\tatn.addState(matchState);\r\n\t\t\t\tmatchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[i]));\r\n\t\t\t\tbypassStart.addTransition(new EpsilonTransition(matchState));\r\n\t\t\t}\r\n\r\n\t\t\tif (this.deserializationOptions.isVerifyATN) {\r\n\t\t\t\t// reverify after modification\r\n\t\t\t\tthis.verifyATN(atn);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.deserializationOptions.isOptimize) {\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet optimizationCount: number = 0;\r\n\t\t\t\toptimizationCount += ATNDeserializer.inlineSetRules(atn);\r\n\t\t\t\toptimizationCount += ATNDeserializer.combineChainedEpsilons(atn);\r\n\t\t\t\tlet preserveOrder: boolean = atn.grammarType === ATNType.LEXER;\r\n\t\t\t\toptimizationCount += ATNDeserializer.optimizeSets(atn, preserveOrder);\r\n\t\t\t\tif (optimizationCount === 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.deserializationOptions.isVerifyATN) {\r\n\t\t\t\t// reverify after modification\r\n\t\t\t\tthis.verifyATN(atn);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tATNDeserializer.identifyTailCalls(atn);\r\n\r\n\t\treturn atn;\r\n\t}\r\n\r\n\tprivate deserializeSets(data: Uint16Array, p: number, sets: IntervalSet[], unicodeDeserializer: UnicodeDeserializer): number {\r\n\t\tlet nsets: number = ATNDeserializer.toInt(data[p++]);\r\n\t\tfor (let i = 0; i < nsets; i++) {\r\n\t\t\tlet nintervals: number = ATNDeserializer.toInt(data[p]);\r\n\t\t\tp++;\r\n\t\t\tlet set: IntervalSet = new IntervalSet();\r\n\t\t\tsets.push(set);\r\n\r\n\t\t\tlet containsEof: boolean = ATNDeserializer.toInt(data[p++]) !== 0;\r\n\t\t\tif (containsEof) {\r\n\t\t\t\tset.add(-1);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let j: number = 0; j < nintervals; j++) {\r\n\t\t\t\tlet a: number = unicodeDeserializer.readUnicode(data, p);\r\n\t\t\t\tp += unicodeDeserializer.size;\r\n\t\t\t\tlet b: number = unicodeDeserializer.readUnicode(data, p);\r\n\t\t\t\tp += unicodeDeserializer.size;\r\n\t\t\t\tset.add(a, b);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/**\r\n\t * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\r\n\t * the {@link StarLoopEntryState#precedenceRuleDecision} field to the\r\n\t * correct value.\r\n\t *\r\n\t * @param atn The ATN.\r\n\t */\r\n\tprotected markPrecedenceDecisions(@NotNull atn: ATN): void {\r\n\t\t// Map rule index -> precedence decision for that rule\r\n\t\tlet rulePrecedenceDecisions = new Map<number, StarLoopEntryState>();\r\n\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tif (!(state instanceof StarLoopEntryState)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t/* We analyze the ATN to determine if this ATN decision state is the\r\n\t\t\t * decision for the closure block that determines whether a\r\n\t\t\t * precedence rule should continue or complete.\r\n\t\t\t */\r\n\t\t\tif (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\r\n\t\t\t\tlet maybeLoopEndState: ATNState = state.transition(state.numberOfTransitions - 1).target;\r\n\t\t\t\tif (maybeLoopEndState instanceof LoopEndState) {\r\n\t\t\t\t\tif (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\r\n\t\t\t\t\t\trulePrecedenceDecisions.set(state.ruleIndex, state);\r\n\t\t\t\t\t\tstate.precedenceRuleDecision = true;\r\n\t\t\t\t\t\tstate.precedenceLoopbackStates = new BitSet(atn.states.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// After marking precedence decisions, we go back through and fill in\r\n\t\t// StarLoopEntryState.precedenceLoopbackStates.\r\n\t\tfor (let precedenceDecision of rulePrecedenceDecisions) {\r\n\t\t\tfor (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {\r\n\t\t\t\tif (transition.serializationType !== TransitionType.EPSILON) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet epsilonTransition = transition as EpsilonTransition;\r\n\t\t\t\tif (epsilonTransition.outermostPrecedenceReturn !== -1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprecedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected verifyATN(atn: ATN): void {\r\n\t\t// verify assumptions\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tthis.checkCondition(state !== undefined, \"ATN states should not be undefined.\");\r\n\t\t\tif (state.stateType === ATNStateType.INVALID_TYPE) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tthis.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);\r\n\r\n\t\t\tif (state instanceof PlusBlockStartState) {\r\n\t\t\t\tthis.checkCondition(state.loopBackState !== undefined);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof StarLoopEntryState) {\r\n\t\t\t\tlet starLoopEntryState: StarLoopEntryState = state;\r\n\t\t\t\tthis.checkCondition(starLoopEntryState.loopBackState !== undefined);\r\n\t\t\t\tthis.checkCondition(starLoopEntryState.numberOfTransitions === 2);\r\n\r\n\t\t\t\tif (starLoopEntryState.transition(0).target instanceof StarBlockStartState) {\r\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState);\r\n\t\t\t\t\tthis.checkCondition(!starLoopEntryState.nonGreedy);\r\n\t\t\t\t}\r\n\t\t\t\telse if (starLoopEntryState.transition(0).target instanceof LoopEndState) {\r\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState);\r\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.nonGreedy);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof StarLoopbackState) {\r\n\t\t\t\tthis.checkCondition(state.numberOfTransitions === 1);\r\n\t\t\t\tthis.checkCondition(state.transition(0).target instanceof StarLoopEntryState);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof LoopEndState) {\r\n\t\t\t\tthis.checkCondition(state.loopBackState !== undefined);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof RuleStartState) {\r\n\t\t\t\tthis.checkCondition(state.stopState !== undefined);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof BlockStartState) {\r\n\t\t\t\tthis.checkCondition(state.endState !== undefined);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof BlockEndState) {\r\n\t\t\t\tthis.checkCondition(state.startState !== undefined);\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof DecisionState) {\r\n\t\t\t\tlet decisionState: DecisionState = state;\r\n\t\t\t\tthis.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected checkCondition(condition: boolean, message?: string): void {\r\n\t\tif (!condition) {\r\n\t\t\tthrow new Error(\"IllegalStateException: \" + message);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate static inlineSetRules(atn: ATN): number {\r\n\t\tlet inlinedCalls: number = 0;\r\n\r\n\t\tlet ruleToInlineTransition = new Array<Transition | undefined>(atn.ruleToStartState.length);\r\n\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\r\n\t\t\tlet startState: RuleStartState = atn.ruleToStartState[i];\r\n\t\t\tlet middleState: ATNState = startState;\r\n\t\t\twhile (middleState.onlyHasEpsilonTransitions\r\n\t\t\t\t&& middleState.numberOfOptimizedTransitions === 1\r\n\t\t\t\t&& middleState.getOptimizedTransition(0).serializationType === TransitionType.EPSILON) {\r\n\t\t\t\tmiddleState = middleState.getOptimizedTransition(0).target;\r\n\t\t\t}\r\n\r\n\t\t\tif (middleState.numberOfOptimizedTransitions !== 1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet matchTransition: Transition = middleState.getOptimizedTransition(0);\r\n\t\t\tlet matchTarget: ATNState = matchTransition.target;\r\n\t\t\tif (matchTransition.isEpsilon\r\n\t\t\t\t|| !matchTarget.onlyHasEpsilonTransitions\r\n\t\t\t\t|| matchTarget.numberOfOptimizedTransitions !== 1\r\n\t\t\t\t|| !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tswitch (matchTransition.serializationType) {\r\n\t\t\tcase TransitionType.ATOM:\r\n\t\t\tcase TransitionType.RANGE:\r\n\t\t\tcase TransitionType.SET:\r\n\t\t\t\truleToInlineTransition[i] = matchTransition;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase TransitionType.NOT_SET:\r\n\t\t\tcase TransitionType.WILDCARD:\r\n\t\t\t\t// not implemented yet\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tif (state.ruleIndex < 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet optimizedTransitions: Transition[] | undefined;\r\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n\t\t\t\tlet transition: Transition = state.getOptimizedTransition(i);\r\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\r\n\t\t\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\t\t\toptimizedTransitions.push(transition);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet ruleTransition: RuleTransition = transition;\r\n\t\t\t\tlet effective: Transition | undefined = ruleToInlineTransition[ruleTransition.target.ruleIndex];\r\n\t\t\t\tif (effective === undefined) {\r\n\t\t\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\t\t\toptimizedTransitions.push(transition);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (optimizedTransitions === undefined) {\r\n\t\t\t\t\toptimizedTransitions = [];\r\n\t\t\t\t\tfor (let j = 0; j < i; j++) {\r\n\t\t\t\t\t\toptimizedTransitions.push(state.getOptimizedTransition(i));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinlinedCalls++;\r\n\t\t\t\tlet target: ATNState = ruleTransition.followState;\r\n\t\t\t\tlet intermediateState: ATNState = new BasicState();\r\n\t\t\t\tintermediateState.setRuleIndex(target.ruleIndex);\r\n\t\t\t\tatn.addState(intermediateState);\r\n\t\t\t\toptimizedTransitions.push(new EpsilonTransition(intermediateState));\r\n\r\n\t\t\t\tswitch (effective.serializationType) {\r\n\t\t\t\tcase TransitionType.ATOM:\r\n\t\t\t\t\tintermediateState.addTransition(new AtomTransition(target, (effective as AtomTransition)._label));\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase TransitionType.RANGE:\r\n\t\t\t\t\tintermediateState.addTransition(new RangeTransition(target, (effective as RangeTransition).from, (effective as RangeTransition).to));\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase TransitionType.SET:\r\n\t\t\t\t\tintermediateState.addTransition(new SetTransition(target, (effective as SetTransition).label));\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"UnsupportedOperationException\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\tif (state.isOptimized) {\r\n\t\t\t\t\twhile (state.numberOfOptimizedTransitions > 0) {\r\n\t\t\t\t\t\tstate.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let transition of optimizedTransitions) {\r\n\t\t\t\t\tstate.addOptimizedTransition(transition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + inlinedCalls + \" rule invocations by inlining sets.\");\r\n\t\t}\r\n\r\n\t\treturn inlinedCalls;\r\n\t}\r\n\r\n\tprivate static combineChainedEpsilons(atn: ATN): number {\r\n\t\tlet removedEdges: number = 0;\r\n\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tif (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet optimizedTransitions: Transition[] | undefined;\r\n\t\t\tnextTransition:\r\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n\t\t\t\tlet transition: Transition = state.getOptimizedTransition(i);\r\n\t\t\t\tlet intermediate: ATNState = transition.target;\r\n\t\t\t\tif (transition.serializationType !== TransitionType.EPSILON\r\n\t\t\t\t\t|| (transition as EpsilonTransition).outermostPrecedenceReturn !== -1\r\n\t\t\t\t\t|| intermediate.stateType !== ATNStateType.BASIC\r\n\t\t\t\t\t|| !intermediate.onlyHasEpsilonTransitions) {\r\n\t\t\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\t\t\toptimizedTransitions.push(transition);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue nextTransition;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\r\n\t\t\t\t\tif (intermediate.getOptimizedTransition(j).serializationType !== TransitionType.EPSILON\r\n\t\t\t\t\t\t|| (intermediate.getOptimizedTransition(j) as EpsilonTransition).outermostPrecedenceReturn !== -1) {\r\n\t\t\t\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\t\t\t\toptimizedTransitions.push(transition);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcontinue nextTransition;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tremovedEdges++;\r\n\t\t\t\tif (optimizedTransitions === undefined) {\r\n\t\t\t\t\toptimizedTransitions = [];\r\n\t\t\t\t\tfor (let j = 0; j < i; j++) {\r\n\t\t\t\t\t\toptimizedTransitions.push(state.getOptimizedTransition(j));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\r\n\t\t\t\t\tlet target: ATNState = intermediate.getOptimizedTransition(j).target;\r\n\t\t\t\t\toptimizedTransitions.push(new EpsilonTransition(target));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (optimizedTransitions !== undefined) {\r\n\t\t\t\tif (state.isOptimized) {\r\n\t\t\t\t\twhile (state.numberOfOptimizedTransitions > 0) {\r\n\t\t\t\t\t\tstate.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let transition of optimizedTransitions) {\r\n\t\t\t\t\tstate.addOptimizedTransition(transition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + removedEdges + \" transitions by combining chained epsilon transitions.\");\r\n\t\t}\r\n\r\n\t\treturn removedEdges;\r\n\t}\r\n\r\n\tprivate static optimizeSets(atn: ATN, preserveOrder: boolean): number {\r\n\t\tif (preserveOrder) {\r\n\t\t\t// this optimization currently doesn't preserve edge order.\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tlet removedPaths: number = 0;\r\n\t\tlet decisions: DecisionState[] = atn.decisionToState;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tlet setTransitions: IntervalSet = new IntervalSet();\r\n\t\t\tfor (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\r\n\t\t\t\tlet epsTransition: Transition = decision.getOptimizedTransition(i);\r\n\t\t\t\tif (!(epsTransition instanceof EpsilonTransition)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (epsTransition.target.numberOfOptimizedTransitions !== 1) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet transition: Transition = epsTransition.target.getOptimizedTransition(0);\r\n\t\t\t\tif (!(transition.target instanceof BlockEndState)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (transition instanceof NotSetTransition) {\r\n\t\t\t\t\t// TODO: not yet implemented\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (transition instanceof AtomTransition\r\n\t\t\t\t\t|| transition instanceof RangeTransition\r\n\t\t\t\t\t|| transition instanceof SetTransition) {\r\n\t\t\t\t\tsetTransitions.add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (setTransitions.size <= 1) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet optimizedTransitions: Transition[] = [];\r\n\t\t\tfor (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\r\n\t\t\t\tif (!setTransitions.contains(i)) {\r\n\t\t\t\t\toptimizedTransitions.push(decision.getOptimizedTransition(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet blockEndState: ATNState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;\r\n\t\t\tlet matchSet: IntervalSet = new IntervalSet();\r\n\t\t\tfor (let interval of setTransitions.intervals) {\r\n\t\t\t\tfor (let j = interval.a; j <= interval.b; j++) {\r\n\t\t\t\t\tlet matchTransition: Transition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);\r\n\t\t\t\t\tif (matchTransition instanceof NotSetTransition) {\r\n\t\t\t\t\t\tthrow new Error(\"Not yet implemented.\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmatchSet.addAll(matchTransition.label as IntervalSet);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet newTransition: Transition;\r\n\t\t\tif (matchSet.intervals.length === 1) {\r\n\t\t\t\tif (matchSet.size === 1) {\r\n\t\t\t\t\tnewTransition = new AtomTransition(blockEndState, matchSet.minElement);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet matchInterval: Interval = matchSet.intervals[0];\r\n\t\t\t\t\tnewTransition = new RangeTransition(blockEndState, matchInterval.a, matchInterval.b);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnewTransition = new SetTransition(blockEndState, matchSet);\r\n\t\t\t}\r\n\r\n\t\t\tlet setOptimizedState: ATNState = new BasicState();\r\n\t\t\tsetOptimizedState.setRuleIndex(decision.ruleIndex);\r\n\t\t\tatn.addState(setOptimizedState);\r\n\r\n\t\t\tsetOptimizedState.addTransition(newTransition);\r\n\t\t\toptimizedTransitions.push(new EpsilonTransition(setOptimizedState));\r\n\r\n\t\t\tremovedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;\r\n\r\n\t\t\tif (decision.isOptimized) {\r\n\t\t\t\twhile (decision.numberOfOptimizedTransitions > 0) {\r\n\t\t\t\t\tdecision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let transition of optimizedTransitions) {\r\n\t\t\t\tdecision.addOptimizedTransition(transition);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (ParserATNSimulator.debug) {\r\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + removedPaths + \" paths by collapsing sets.\");\r\n\t\t}\r\n\r\n\t\treturn removedPaths;\r\n\t}\r\n\r\n\tprivate static identifyTailCalls(atn: ATN): void {\r\n\t\tfor (let state of atn.states) {\r\n\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\r\n\t\t\t\tlet transition = state.transition(i);\r\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransition.tailCall = this.testTailCall(atn, transition, false);\r\n\t\t\t\ttransition.optimizedTailCall = this.testTailCall(atn, transition, true);\r\n\t\t\t}\r\n\r\n\t\t\tif (!state.isOptimized) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\r\n\t\t\t\tlet transition = state.getOptimizedTransition(i);\r\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransition.tailCall = this.testTailCall(atn, transition, false);\r\n\t\t\t\ttransition.optimizedTailCall = this.testTailCall(atn, transition, true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate static testTailCall(atn: ATN, transition: RuleTransition, optimizedPath: boolean): boolean {\r\n\t\tif (!optimizedPath && transition.tailCall) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (optimizedPath && transition.optimizedTailCall) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlet reachable: BitSet = new BitSet(atn.states.length);\r\n\t\tlet worklist: ATNState[] = [];\r\n\t\tworklist.push(transition.followState);\r\n\t\twhile (true) {\r\n\t\t\tlet state = worklist.pop();\r\n\t\t\tif (!state) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (reachable.get(state.stateNumber)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (state instanceof RuleStopState) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (!state.onlyHasEpsilonTransitions) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tlet transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;\r\n\t\t\tfor (let i = 0; i < transitionCount; i++) {\r\n\t\t\t\tlet t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);\r\n\t\t\t\tif (t.serializationType !== TransitionType.EPSILON) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tworklist.push(t.target);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprotected static toInt(c: number): number {\r\n\t\treturn c;\r\n\t}\r\n\r\n\tprotected static toInt32(data: Uint16Array, offset: number): number {\r\n\t\treturn (data[offset] | (data[offset + 1] << 16)) >>> 0;\r\n\t}\r\n\r\n\tprotected static toUUID(data: Uint16Array, offset: number): UUID {\r\n\t\tlet leastSigBits: number = ATNDeserializer.toInt32(data, offset);\r\n\t\tlet lessSigBits: number = ATNDeserializer.toInt32(data, offset + 2);\r\n\t\tlet moreSigBits: number = ATNDeserializer.toInt32(data, offset + 4);\r\n\t\tlet mostSigBits: number = ATNDeserializer.toInt32(data, offset + 6);\r\n\t\treturn new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected edgeFactory(\r\n\t\t@NotNull atn: ATN,\r\n\t\ttype: TransitionType, src: number, trg: number,\r\n\t\targ1: number, arg2: number, arg3: number,\r\n\t\tsets: IntervalSet[]): Transition {\r\n\t\tlet target: ATNState = atn.states[trg];\r\n\t\tswitch (type) {\r\n\t\t\tcase TransitionType.EPSILON: return new EpsilonTransition(target);\r\n\t\t\tcase TransitionType.RANGE:\r\n\t\t\t\tif (arg3 !== 0) {\r\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\r\n\t\t\t\t}\r\n\t\t\tcase TransitionType.RULE:\r\n\t\t\t\tlet rt: RuleTransition = new RuleTransition(atn.states[arg1] as RuleStartState, arg2, arg3, target);\r\n\t\t\t\treturn rt;\r\n\t\t\tcase TransitionType.PREDICATE:\r\n\t\t\t\tlet pt: PredicateTransition = new PredicateTransition(target, arg1, arg2, arg3 !== 0);\r\n\t\t\t\treturn pt;\r\n\t\t\tcase TransitionType.PRECEDENCE:\r\n\t\t\t\treturn new PrecedencePredicateTransition(target, arg1);\r\n\t\t\tcase TransitionType.ATOM:\r\n\t\t\t\tif (arg3 !== 0) {\r\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn new AtomTransition(target, arg1);\r\n\t\t\t\t}\r\n\t\t\tcase TransitionType.ACTION:\r\n\t\t\t\tlet a: ActionTransition = new ActionTransition(target, arg1, arg2, arg3 !== 0);\r\n\t\t\t\treturn a;\r\n\t\t\tcase TransitionType.SET: return new SetTransition(target, sets[arg1]);\r\n\t\t\tcase TransitionType.NOT_SET: return new NotSetTransition(target, sets[arg1]);\r\n\t\t\tcase TransitionType.WILDCARD: return new WildcardTransition(target);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"The specified transition type is not valid.\");\r\n\t}\r\n\r\n\tprotected stateFactory(type: ATNStateType, ruleIndex: number): ATNState {\r\n\t\tlet s: ATNState;\r\n\t\tswitch (type) {\r\n\t\t\tcase ATNStateType.INVALID_TYPE: return new InvalidState();\r\n\t\t\tcase ATNStateType.BASIC: s = new BasicState(); break;\r\n\t\t\tcase ATNStateType.RULE_START: s = new RuleStartState(); break;\r\n\t\t\tcase ATNStateType.BLOCK_START: s = new BasicBlockStartState(); break;\r\n\t\t\tcase ATNStateType.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\r\n\t\t\tcase ATNStateType.STAR_BLOCK_START: s = new StarBlockStartState(); break;\r\n\t\t\tcase ATNStateType.TOKEN_START: s = new TokensStartState(); break;\r\n\t\t\tcase ATNStateType.RULE_STOP: s = new RuleStopState(); break;\r\n\t\t\tcase ATNStateType.BLOCK_END: s = new BlockEndState(); break;\r\n\t\t\tcase ATNStateType.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\r\n\t\t\tcase ATNStateType.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\r\n\t\t\tcase ATNStateType.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\r\n\t\t\tcase ATNStateType.LOOP_END: s = new LoopEndState(); break;\r\n\t\t\tdefault:\r\n\t\t\t\tlet message: string = `The specified state type ${type} is not valid.`;\r\n\t\t\t\tthrow new Error(message);\r\n\t\t}\r\n\r\n\t\ts.ruleIndex = ruleIndex;\r\n\t\treturn s;\r\n\t}\r\n\r\n\tprotected lexerActionFactory(type: LexerActionType, data1: number, data2: number): LexerAction {\r\n\t\tswitch (type) {\r\n\t\tcase LexerActionType.CHANNEL:\r\n\t\t\treturn new LexerChannelAction(data1);\r\n\r\n\t\tcase LexerActionType.CUSTOM:\r\n\t\t\treturn new LexerCustomAction(data1, data2);\r\n\r\n\t\tcase LexerActionType.MODE:\r\n\t\t\treturn new LexerModeAction(data1);\r\n\r\n\t\tcase LexerActionType.MORE:\r\n\t\t\treturn LexerMoreAction.INSTANCE;\r\n\r\n\t\tcase LexerActionType.POP_MODE:\r\n\t\t\treturn LexerPopModeAction.INSTANCE;\r\n\r\n\t\tcase LexerActionType.PUSH_MODE:\r\n\t\t\treturn new LexerPushModeAction(data1);\r\n\r\n\t\tcase LexerActionType.SKIP:\r\n\t\t\treturn LexerSkipAction.INSTANCE;\r\n\r\n\t\tcase LexerActionType.TYPE:\r\n\t\t\treturn new LexerTypeAction(data1);\r\n\r\n\t\tdefault:\r\n\t\t\tlet message: string = `The specified lexer action type ${type} is not valid.`;\r\n\t\t\tthrow new Error(message);\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.5187682-07:00\r\n\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { NotNull } from \"./Decorators\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\n\r\n/** This signifies any kind of mismatched input exceptions such as\r\n *  when the current input does not match the expected token.\r\n */\r\nexport class InputMismatchException extends RecognitionException {\r\n\t//private static serialVersionUID: number =  1532568338707443067L;\r\n\r\n\tconstructor(/*@NotNull*/ recognizer: Parser);\r\n\tconstructor(/*@NotNull*/ recognizer: Parser, state: number, context: ParserRuleContext);\r\n\tconstructor(@NotNull recognizer: Parser, state?: number, context?: ParserRuleContext) {\r\n\t\tif (context === undefined) {\r\n\t\t\tcontext = recognizer.context;\r\n\t\t}\r\n\r\n\t\tsuper(recognizer, recognizer.inputStream, context);\r\n\r\n\t\tif (state !== undefined) {\r\n\t\t\tthis.setOffendingState(state);\r\n\t\t}\r\n\r\n\t\tthis.setOffendingToken(recognizer, recognizer.currentToken);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:50.8290527-07:00\r\n\r\nimport { ANTLRErrorStrategy } from \"./ANTLRErrorStrategy\";\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNState } from \"./atn/ATNState\";\r\nimport { ATNStateType } from \"./atn/ATNStateType\";\r\nimport { FailedPredicateException } from \"./FailedPredicateException\";\r\nimport { InputMismatchException } from \"./InputMismatchException\";\r\nimport { IntervalSet } from \"./misc/IntervalSet\";\r\nimport { NoViableAltException } from \"./NoViableAltException\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { PredictionContext } from \"./atn/PredictionContext\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { RuleTransition } from \"./atn/RuleTransition\";\r\nimport { TokenStream } from \"./TokenStream\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenFactory } from \"./TokenFactory\";\r\nimport { TokenSource } from \"./TokenSource\";\r\nimport { Vocabulary } from \"./Vocabulary\";\r\nimport { Override, NotNull } from \"./Decorators\";\r\n\r\n/**\r\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\r\n * error reporting and recovery in ANTLR parsers.\r\n */\r\nexport class DefaultErrorStrategy implements ANTLRErrorStrategy {\r\n\t/**\r\n\t * Indicates whether the error strategy is currently \"recovering from an\r\n\t * error\". This is used to suppress reporting multiple error messages while\r\n\t * attempting to recover from a detected syntax error.\r\n\t *\r\n\t * @see #inErrorRecoveryMode\r\n\t */\r\n\tprotected errorRecoveryMode: boolean = false;\r\n\r\n\t/** The index into the input stream where the last error occurred.\r\n\t * \tThis is used to prevent infinite loops where an error is found\r\n\t *  but no token is consumed during recovery...another error is found,\r\n\t *  ad nauseum.  This is a failsafe mechanism to guarantee that at least\r\n\t *  one token/tree node is consumed for two errors.\r\n\t */\r\n\tprotected lastErrorIndex: number = -1;\r\n\r\n\tprotected lastErrorStates?: IntervalSet;\r\n\r\n\t/**\r\n\t * This field is used to propagate information about the lookahead following\r\n\t * the previous match. Since prediction prefers completing the current rule\r\n\t * to error recovery efforts, error reporting may occur later than the\r\n\t * original point where it was discoverable. The original context is used to\r\n\t * compute the true expected sets as though the reporting occurred as early\r\n\t * as possible.\r\n\t */\r\n\tprotected nextTokensContext?: ParserRuleContext;\r\n\r\n\t/**\r\n\t * @see #nextTokensContext\r\n\t */\r\n\tprotected nextTokensState: number = ATNState.INVALID_STATE_NUMBER;\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation simply calls {@link #endErrorCondition} to\r\n\t * ensure that the handler is not in error recovery mode.\r\n\t */\r\n\t@Override\r\n\tpublic reset(recognizer: Parser): void {\r\n\t\tthis.endErrorCondition(recognizer);\r\n\t}\r\n\r\n\t/**\r\n\t * This method is called to enter error recovery mode when a recognition\r\n\t * exception is reported.\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t */\r\n\tprotected beginErrorCondition(@NotNull recognizer: Parser): void {\r\n\t\tthis.errorRecoveryMode = true;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tpublic inErrorRecoveryMode(recognizer: Parser): boolean {\r\n\t\treturn this.errorRecoveryMode;\r\n\t}\r\n\r\n\t/**\r\n\t * This method is called to leave error recovery mode after recovering from\r\n\t * a recognition exception.\r\n\t *\r\n\t * @param recognizer\r\n\t */\r\n\tprotected endErrorCondition(@NotNull recognizer: Parser): void {\r\n\t\tthis.errorRecoveryMode = false;\r\n\t\tthis.lastErrorStates = undefined;\r\n\t\tthis.lastErrorIndex = -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation simply calls {@link #endErrorCondition}.\r\n\t */\r\n\t@Override\r\n\tpublic reportMatch(recognizer: Parser): void {\r\n\t\tthis.endErrorCondition(recognizer);\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation returns immediately if the handler is already\r\n\t * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}\r\n\t * and dispatches the reporting task based on the runtime type of `e`\r\n\t * according to the following table.\r\n\t *\r\n\t * * {@link NoViableAltException}: Dispatches the call to\r\n\t *   {@link #reportNoViableAlternative}\r\n\t * * {@link InputMismatchException}: Dispatches the call to\r\n\t *   {@link #reportInputMismatch}\r\n\t * * {@link FailedPredicateException}: Dispatches the call to\r\n\t *   {@link #reportFailedPredicate}\r\n\t * * All other types: calls {@link Parser#notifyErrorListeners} to report\r\n\t *   the exception\r\n\t */\r\n\t@Override\r\n\tpublic reportError(\r\n\t\trecognizer: Parser,\r\n\t\te: RecognitionException): void {\r\n\t\t// if we've already reported an error and have not matched a token\r\n\t\t// yet successfully, don't report any errors.\r\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\r\n//\t\t\tSystem.err.print(\"[SPURIOUS] \");\r\n\t\t\treturn; // don't report spurious errors\r\n\t\t}\r\n\t\tthis.beginErrorCondition(recognizer);\r\n\t\tif (e instanceof NoViableAltException) {\r\n\t\t\tthis.reportNoViableAlternative(recognizer, e);\r\n\t\t}\r\n\t\telse if (e instanceof InputMismatchException) {\r\n\t\t\tthis.reportInputMismatch(recognizer, e);\r\n\t\t}\r\n\t\telse if (e instanceof FailedPredicateException) {\r\n\t\t\tthis.reportFailedPredicate(recognizer, e);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconsole.error(`unknown recognition error type: ${e}`);\r\n\t\t\tthis.notifyErrorListeners(recognizer, e.toString(), e);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected notifyErrorListeners(@NotNull recognizer: Parser, message: string, e: RecognitionException): void {\r\n\t\tlet offendingToken: Token | null | undefined = e.getOffendingToken(recognizer);\r\n\t\tif (offendingToken === undefined) {\r\n\t\t\t// Pass null to notifyErrorListeners so it in turn calls the error listeners with undefined as the offending\r\n\t\t\t// token. If we passed undefined, it would instead call the listeners with currentToken from the parser.\r\n\t\t\toffendingToken = null;\r\n\t\t}\r\n\r\n\t\trecognizer.notifyErrorListeners(message, offendingToken, e);\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation resynchronizes the parser by consuming tokens\r\n\t * until we find one in the resynchronization set--loosely the set of tokens\r\n\t * that can follow the current rule.\r\n\t */\r\n\t@Override\r\n\tpublic recover(recognizer: Parser, e: RecognitionException): void {\r\n//\t\tSystem.out.println(\"recover in \"+recognizer.getRuleInvocationStack()+\r\n//\t\t\t\t\t\t   \" index=\"+recognizer.inputStream.index+\r\n//\t\t\t\t\t\t   \", lastErrorIndex=\"+\r\n//\t\t\t\t\t\t   lastErrorIndex+\r\n//\t\t\t\t\t\t   \", states=\"+lastErrorStates);\r\n\t\tif (this.lastErrorIndex === recognizer.inputStream.index &&\r\n\t\t\tthis.lastErrorStates &&\r\n\t\t\tthis.lastErrorStates.contains(recognizer.state)) {\r\n\t\t\t// uh oh, another error at same token index and previously-visited\r\n\t\t\t// state in ATN; must be a case where LT(1) is in the recovery\r\n\t\t\t// token set so nothing got consumed. Consume a single token\r\n\t\t\t// at least to prevent an infinite loop; this is a failsafe.\r\n//\t\t\tSystem.err.println(\"seen error condition before index=\"+\r\n//\t\t\t\t\t\t\t   lastErrorIndex+\", states=\"+lastErrorStates);\r\n//\t\t\tSystem.err.println(\"FAILSAFE consumes \"+recognizer.getTokenNames()[recognizer.inputStream.LA(1)]);\r\n\t\t\trecognizer.consume();\r\n\t\t}\r\n\t\tthis.lastErrorIndex = recognizer.inputStream.index;\r\n\t\tif (!this.lastErrorStates) {\r\n\t\t\tthis.lastErrorStates = new IntervalSet();\r\n\t\t}\r\n\t\tthis.lastErrorStates.add(recognizer.state);\r\n\t\tlet followSet: IntervalSet = this.getErrorRecoverySet(recognizer);\r\n\t\tthis.consumeUntil(recognizer, followSet);\r\n\t}\r\n\r\n\t/**\r\n\t * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure\r\n\t * that the current lookahead symbol is consistent with what were expecting\r\n\t * at this point in the ATN. You can call this anytime but ANTLR only\r\n\t * generates code to check before subrules/loops and each iteration.\r\n\t *\r\n\t * Implements Jim Idle's magic sync mechanism in closures and optional\r\n\t * subrules. E.g.,\r\n\t *\r\n\t * ```antlr\r\n\t * a : sync ( stuff sync )* ;\r\n\t * sync : {consume to what can follow sync} ;\r\n\t * ```\r\n\t *\r\n\t * At the start of a sub rule upon error, {@link #sync} performs single\r\n\t * token deletion, if possible. If it can't do that, it bails on the current\r\n\t * rule and uses the default error recovery, which consumes until the\r\n\t * resynchronization set of the current rule.\r\n\t *\r\n\t * If the sub rule is optional (`(...)?`, `(...)*`, or block\r\n\t * with an empty alternative), then the expected set includes what follows\r\n\t * the subrule.\r\n\t *\r\n\t * During loop iteration, it consumes until it sees a token that can start a\r\n\t * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\r\n\t * stay in the loop as long as possible.\r\n\t *\r\n\t * **ORIGINS**\r\n\t *\r\n\t * Previous versions of ANTLR did a poor job of their recovery within loops.\r\n\t * A single mismatch token or missing token would force the parser to bail\r\n\t * out of the entire rules surrounding the loop. So, for rule\r\n\t *\r\n\t * ```antlr\r\n\t * classDef : 'class' ID '{' member* '}'\r\n\t * ```\r\n\t *\r\n\t * input with an extra token between members would force the parser to\r\n\t * consume until it found the next class definition rather than the next\r\n\t * member definition of the current class.\r\n\t *\r\n\t * This functionality cost a little bit of effort because the parser has to\r\n\t * compare token set at the start of the loop and at each iteration. If for\r\n\t * some reason speed is suffering for you, you can turn off this\r\n\t * functionality by simply overriding this method as a blank { }.\r\n\t */\r\n\t@Override\r\n\tpublic sync(recognizer: Parser): void {\r\n\t\tlet s: ATNState = recognizer.interpreter.atn.states[recognizer.state];\r\n//\t\tSystem.err.println(\"sync @ \"+s.stateNumber+\"=\"+s.getClass().getSimpleName());\r\n\t\t// If already recovering, don't try to sync\r\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet tokens: TokenStream = recognizer.inputStream;\r\n\t\tlet la: number = tokens.LA(1);\r\n\r\n\t\t// try cheaper subset first; might get lucky. seems to shave a wee bit off\r\n\t\tlet nextTokens: IntervalSet = recognizer.atn.nextTokens(s);\r\n\t\tif (nextTokens.contains(la)) {\r\n\t\t\t// We are sure the token matches\r\n\t\t\tthis.nextTokensContext = undefined;\r\n\t\t\tthis.nextTokensState = ATNState.INVALID_STATE_NUMBER;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (nextTokens.contains(Token.EPSILON)) {\r\n\t\t\tif (this.nextTokensContext === undefined) {\r\n\t\t\t\t// It's possible the next token won't match; information tracked\r\n\t\t\t\t// by sync is restricted for performance.\r\n\t\t\t\tthis.nextTokensContext = recognizer.context;\r\n\t\t\t\tthis.nextTokensState = recognizer.state;\r\n\t\t\t}\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tswitch (s.stateType) {\r\n\t\tcase ATNStateType.BLOCK_START:\r\n\t\tcase ATNStateType.STAR_BLOCK_START:\r\n\t\tcase ATNStateType.PLUS_BLOCK_START:\r\n\t\tcase ATNStateType.STAR_LOOP_ENTRY:\r\n\t\t\t// report error and recover if possible\r\n\t\t\tif (this.singleTokenDeletion(recognizer)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthrow new InputMismatchException(recognizer);\r\n\r\n\t\tcase ATNStateType.PLUS_LOOP_BACK:\r\n\t\tcase ATNStateType.STAR_LOOP_BACK:\r\n//\t\t\tSystem.err.println(\"at loop back: \"+s.getClass().getSimpleName());\r\n\t\t\tthis.reportUnwantedToken(recognizer);\r\n\t\t\tlet expecting: IntervalSet = recognizer.getExpectedTokens();\r\n\t\t\tlet whatFollowsLoopIterationOrRule: IntervalSet =\r\n\t\t\t\texpecting.or(this.getErrorRecoverySet(recognizer));\r\n\t\t\tthis.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\t// do nothing if we can't identify the exact kind of ATN state\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This is called by {@link #reportError} when the exception is a\r\n\t * {@link NoViableAltException}.\r\n\t *\r\n\t * @see #reportError\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t * @param e the recognition exception\r\n\t */\r\n\tprotected reportNoViableAlternative(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull e: NoViableAltException): void {\r\n\t\tlet tokens: TokenStream = recognizer.inputStream;\r\n\t\tlet input: string;\r\n\t\tif (tokens) {\r\n\t\t\tif (e.startToken.type === Token.EOF) {\r\n\t\t\t\tinput = \"<EOF>\";\r\n\t\t\t} else {\r\n\t\t\t\tinput = tokens.getTextFromRange(e.startToken, e.getOffendingToken());\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinput = \"<unknown input>\";\r\n\t\t}\r\n\t\tlet msg: string = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\r\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\r\n\t}\r\n\r\n\t/**\r\n\t * This is called by {@link #reportError} when the exception is an\r\n\t * {@link InputMismatchException}.\r\n\t *\r\n\t * @see #reportError\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t * @param e the recognition exception\r\n\t */\r\n\tprotected reportInputMismatch(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull e: InputMismatchException): void {\r\n\t\tlet expected = e.expectedTokens;\r\n\t\tlet expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : \"\";\r\n\t\tlet msg: string = \"mismatched input \" + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) +\r\n\t\t\t\" expecting \" + expectedString;\r\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\r\n\t}\r\n\r\n\t/**\r\n\t * This is called by {@link #reportError} when the exception is a\r\n\t * {@link FailedPredicateException}.\r\n\t *\r\n\t * @see #reportError\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t * @param e the recognition exception\r\n\t */\r\n\tprotected reportFailedPredicate(\r\n\t\t@NotNull recognizer: Parser,\r\n\t\t@NotNull e: FailedPredicateException): void {\r\n\t\tlet ruleName: string = recognizer.ruleNames[recognizer.context.ruleIndex];\r\n\t\tlet msg: string = \"rule \" + ruleName + \" \" + e.message;\r\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\r\n\t}\r\n\r\n\t/**\r\n\t * This method is called to report a syntax error which requires the removal\r\n\t * of a token from the input stream. At the time this method is called, the\r\n\t * erroneous symbol is current `LT(1)` symbol and has not yet been\r\n\t * removed from the input stream. When this method returns,\r\n\t * `recognizer` is in error recovery mode.\r\n\t *\r\n\t * This method is called when {@link #singleTokenDeletion} identifies\r\n\t * single-token deletion as a viable recovery strategy for a mismatched\r\n\t * input error.\r\n\t *\r\n\t * The default implementation simply returns if the handler is already in\r\n\t * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\r\n\t * enter error recovery mode, followed by calling\r\n\t * {@link Parser#notifyErrorListeners}.\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t */\r\n\tprotected reportUnwantedToken(@NotNull recognizer: Parser): void {\r\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.beginErrorCondition(recognizer);\r\n\r\n\t\tlet t: Token = recognizer.currentToken;\r\n\t\tlet tokenName: string = this.getTokenErrorDisplay(t);\r\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\r\n\t\tlet msg: string = \"extraneous input \" + tokenName + \" expecting \" +\r\n\t\t\texpecting.toStringVocabulary(recognizer.vocabulary);\r\n\t\trecognizer.notifyErrorListeners(msg, t, undefined);\r\n\t}\r\n\r\n\t/**\r\n\t * This method is called to report a syntax error which requires the\r\n\t * insertion of a missing token into the input stream. At the time this\r\n\t * method is called, the missing token has not yet been inserted. When this\r\n\t * method returns, `recognizer` is in error recovery mode.\r\n\t *\r\n\t * This method is called when {@link #singleTokenInsertion} identifies\r\n\t * single-token insertion as a viable recovery strategy for a mismatched\r\n\t * input error.\r\n\t *\r\n\t * The default implementation simply returns if the handler is already in\r\n\t * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\r\n\t * enter error recovery mode, followed by calling\r\n\t * {@link Parser#notifyErrorListeners}.\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t */\r\n\tprotected reportMissingToken(@NotNull recognizer: Parser): void {\r\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.beginErrorCondition(recognizer);\r\n\r\n\t\tlet t: Token = recognizer.currentToken;\r\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\r\n\t\tlet msg: string = \"missing \" + expecting.toStringVocabulary(recognizer.vocabulary) +\r\n\t\t\t\" at \" + this.getTokenErrorDisplay(t);\r\n\r\n\t\trecognizer.notifyErrorListeners(msg, t, undefined);\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The default implementation attempts to recover from the mismatched input\r\n\t * by using single token insertion and deletion as described below. If the\r\n\t * recovery attempt fails, this method\r\n\t * {@link InputMismatchException}.\r\n\t *\r\n\t * **EXTRA TOKEN** (single token deletion)\r\n\t *\r\n\t * `LA(1)` is not what we are looking for. If `LA(2)` has the\r\n\t * right token, however, then assume `LA(1)` is some extra spurious\r\n\t * token and delete it. Then consume and return the next token (which was\r\n\t * the `LA(2)` token) as the successful result of the match operation.\r\n\t *\r\n\t * This recovery strategy is implemented by {@link #singleTokenDeletion}.\r\n\t *\r\n\t * **MISSING TOKEN** (single token insertion)\r\n\t *\r\n\t * If current token (at `LA(1)`) is consistent with what could come\r\n\t * after the expected `LA(1)` token, then assume the token is missing\r\n\t * and use the parser's {@link TokenFactory} to create it on the fly. The\r\n\t * \"insertion\" is performed by returning the created token as the successful\r\n\t * result of the match operation.\r\n\t *\r\n\t * This recovery strategy is implemented by {@link #singleTokenInsertion}.\r\n\t *\r\n\t * **EXAMPLE**\r\n\t *\r\n\t * For example, Input `i=(3;` is clearly missing the `')'`. When\r\n\t * the parser returns from the nested call to `expr`, it will have\r\n\t * call chain:\r\n\t *\r\n\t * ```\r\n\t * stat → expr → atom\r\n\t * ```\r\n\t *\r\n\t * and it will be trying to match the `')'` at this point in the\r\n\t * derivation:\r\n\t *\r\n\t * ```\r\n\t * => ID '=' '(' INT ')' ('+' atom)* ';'\r\n\t *                    ^\r\n\t * ```\r\n\t *\r\n\t * The attempt to match `')'` will fail when it sees `';'` and\r\n\t * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`\r\n\t * is in the set of tokens that can follow the `')'` token reference\r\n\t * in rule `atom`. It can assume that you forgot the `')'`.\r\n\t */\r\n\t@Override\r\n\tpublic recoverInline(recognizer: Parser): Token {\r\n\t\t// SINGLE TOKEN DELETION\r\n\t\tlet matchedSymbol = this.singleTokenDeletion(recognizer);\r\n\t\tif (matchedSymbol) {\r\n\t\t\t// we have deleted the extra token.\r\n\t\t\t// now, move past ttype token as if all were ok\r\n\t\t\trecognizer.consume();\r\n\t\t\treturn matchedSymbol;\r\n\t\t}\r\n\r\n\t\t// SINGLE TOKEN INSERTION\r\n\t\tif (this.singleTokenInsertion(recognizer)) {\r\n\t\t\treturn this.getMissingSymbol(recognizer);\r\n\t\t}\r\n\r\n\t\t// even that didn't work; must throw the exception\r\n\t\tif (this.nextTokensContext === undefined) {\r\n\t\t\tthrow new InputMismatchException(recognizer);\r\n\t\t} else {\r\n\t\t\tthrow new InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method implements the single-token insertion inline error recovery\r\n\t * strategy. It is called by {@link #recoverInline} if the single-token\r\n\t * deletion strategy fails to recover from the mismatched input. If this\r\n\t * method returns `true`, `recognizer` will be in error recovery\r\n\t * mode.\r\n\t *\r\n\t * This method determines whether or not single-token insertion is viable by\r\n\t * checking if the `LA(1)` input symbol could be successfully matched\r\n\t * if it were instead the `LA(2)` symbol. If this method returns\r\n\t * `true`, the caller is responsible for creating and inserting a\r\n\t * token with the correct type to produce this behavior.\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t * @returns `true` if single-token insertion is a viable recovery\r\n\t * strategy for the current mismatched input, otherwise `false`\r\n\t */\r\n\tprotected singleTokenInsertion(@NotNull recognizer: Parser): boolean {\r\n\t\tlet currentSymbolType: number = recognizer.inputStream.LA(1);\r\n\t\t// if current token is consistent with what could come after current\r\n\t\t// ATN state, then we know we're missing a token; error recovery\r\n\t\t// is free to conjure up and insert the missing token\r\n\t\tlet currentState = recognizer.interpreter.atn.states[recognizer.state];\r\n\t\tlet next: ATNState = currentState.transition(0).target;\r\n\t\tlet atn: ATN = recognizer.interpreter.atn;\r\n\t\tlet expectingAtLL2: IntervalSet = atn.nextTokens(next, PredictionContext.fromRuleContext(atn, recognizer.context));\r\n//\t\tconsole.warn(\"LT(2) set=\"+expectingAtLL2.toString(recognizer.getTokenNames()));\r\n\t\tif (expectingAtLL2.contains(currentSymbolType)) {\r\n\t\t\tthis.reportMissingToken(recognizer);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * This method implements the single-token deletion inline error recovery\r\n\t * strategy. It is called by {@link #recoverInline} to attempt to recover\r\n\t * from mismatched input. If this method returns `undefined`, the parser and error\r\n\t * handler state will not have changed. If this method returns non-`undefined`,\r\n\t * `recognizer` will *not* be in error recovery mode since the\r\n\t * returned token was a successful match.\r\n\t *\r\n\t * If the single-token deletion is successful, this method calls\r\n\t * {@link #reportUnwantedToken} to report the error, followed by\r\n\t * {@link Parser#consume} to actually \"delete\" the extraneous token. Then,\r\n\t * before returning {@link #reportMatch} is called to signal a successful\r\n\t * match.\r\n\t *\r\n\t * @param recognizer the parser instance\r\n\t * @returns the successfully matched {@link Token} instance if single-token\r\n\t * deletion successfully recovers from the mismatched input, otherwise\r\n\t * `undefined`\r\n\t */\r\n\tprotected singleTokenDeletion(@NotNull recognizer: Parser): Token | undefined {\r\n\t\tlet nextTokenType: number = recognizer.inputStream.LA(2);\r\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\r\n\t\tif (expecting.contains(nextTokenType)) {\r\n\t\t\tthis.reportUnwantedToken(recognizer);\r\n\t\t\t/*\r\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\r\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.inputStream).LT(1)+\r\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.inputStream).LT(2)+\r\n\t\t\t\t\t\t\t   \" is what we want\");\r\n\t\t\t*/\r\n\t\t\trecognizer.consume(); // simply delete extra token\r\n\t\t\t// we want to return the token we're actually matching\r\n\t\t\tlet matchedSymbol: Token = recognizer.currentToken;\r\n\t\t\tthis.reportMatch(recognizer);  // we know current token is correct\r\n\t\t\treturn matchedSymbol;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/** Conjure up a missing token during error recovery.\r\n\t *\r\n\t *  The recognizer attempts to recover from single missing\r\n\t *  symbols. But, actions might refer to that missing symbol.\r\n\t *  For example, x=ID {f($x);}. The action clearly assumes\r\n\t *  that there has been an identifier matched previously and that\r\n\t *  $x points at that token. If that token is missing, but\r\n\t *  the next token in the stream is what we want we assume that\r\n\t *  this token is missing and we keep going. Because we\r\n\t *  have to return some token to replace the missing token,\r\n\t *  we have to conjure one up. This method gives the user control\r\n\t *  over the tokens returned for missing tokens. Mostly,\r\n\t *  you will want to create something special for identifier\r\n\t *  tokens. For literals such as '{' and ',', the default\r\n\t *  action in the parser or tree parser works. It simply creates\r\n\t *  a CommonToken of the appropriate type. The text will be the token.\r\n\t *  If you change what tokens must be created by the lexer,\r\n\t *  override this method to create the appropriate tokens.\r\n\t */\r\n\t@NotNull\r\n\tprotected getMissingSymbol(@NotNull recognizer: Parser): Token {\r\n\t\tlet currentSymbol: Token = recognizer.currentToken;\r\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\r\n\t\tlet expectedTokenType: number = Token.INVALID_TYPE;\r\n\t\tif (!expecting.isNil) {\r\n\t\t\t// get any element\r\n\t\t\texpectedTokenType = expecting.minElement;\r\n\t\t}\r\n\r\n\t\tlet tokenText: string;\r\n\t\tif (expectedTokenType === Token.EOF) {\r\n\t\t\ttokenText = \"<missing EOF>\";\r\n\t\t} else {\r\n\t\t\ttokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\r\n\t\t}\r\n\t\tlet current: Token = currentSymbol;\r\n\t\tlet lookback = recognizer.inputStream.tryLT(-1);\r\n\t\tif (current.type === Token.EOF && lookback != null) {\r\n\t\t\tcurrent = lookback;\r\n\t\t}\r\n\r\n\t\treturn this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);\r\n\t}\r\n\r\n\tprotected constructToken(\r\n\t\ttokenSource: TokenSource,\r\n\t\texpectedTokenType: number,\r\n\t\ttokenText: string,\r\n\t\tcurrent: Token): Token {\r\n\t\tlet factory: TokenFactory = tokenSource.tokenFactory;\r\n\t\tlet x = current.tokenSource;\r\n\t\tlet stream = x ? x.inputStream : undefined;\r\n\r\n\t\treturn factory.create(\r\n\t\t\t{ source: tokenSource, stream },\r\n\t\t\texpectedTokenType, tokenText,\r\n\t\t\tToken.DEFAULT_CHANNEL,\r\n\t\t\t-1, -1,\r\n\t\t\tcurrent.line, current.charPositionInLine);\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected getExpectedTokens(@NotNull recognizer: Parser): IntervalSet {\r\n\t\treturn recognizer.getExpectedTokens();\r\n\t}\r\n\r\n\t/** How should a token be displayed in an error message? The default\r\n\t *  is to display just the text, but during development you might\r\n\t *  want to have a lot of information spit out.  Override in that case\r\n\t *  to use t.toString() (which, for CommonToken, dumps everything about\r\n\t *  the token). This is better than forcing you to override a method in\r\n\t *  your token objects because you don't have to go modify your lexer\r\n\t *  so that it creates a new Java type.\r\n\t */\r\n\tprotected getTokenErrorDisplay(t: Token | undefined): string {\r\n\t\tif (!t) {\r\n\t\t\treturn \"<no token>\";\r\n\t\t}\r\n\t\tlet s = this.getSymbolText(t);\r\n\t\tif (!s) {\r\n\t\t\tif (this.getSymbolType(t) === Token.EOF) {\r\n\t\t\t\ts = \"<EOF>\";\r\n\t\t\t} else {\r\n\t\t\t\ts = `<${this.getSymbolType(t)}>`;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.escapeWSAndQuote(s);\r\n\t}\r\n\r\n\tprotected getSymbolText(@NotNull symbol: Token): string | undefined {\r\n\t\treturn symbol.text;\r\n\t}\r\n\r\n\tprotected getSymbolType(@NotNull symbol: Token): number {\r\n\t\treturn symbol.type;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected escapeWSAndQuote(@NotNull s: string): string {\r\n//\t\tif ( s==null ) return s;\r\n\t\ts = s.replace(\"\\n\", \"\\\\n\");\r\n\t\ts = s.replace(\"\\r\", \"\\\\r\");\r\n\t\ts = s.replace(\"\\t\", \"\\\\t\");\r\n\t\treturn \"'\" + s + \"'\";\r\n\t}\r\n\r\n\t/*  Compute the error recovery set for the current rule.  During\r\n\t *  rule invocation, the parser pushes the set of tokens that can\r\n\t *  follow that rule reference on the stack; this amounts to\r\n\t *  computing FIRST of what follows the rule reference in the\r\n\t *  enclosing rule. See LinearApproximator.FIRST().\r\n\t *  This local follow set only includes tokens\r\n\t *  from within the rule; i.e., the FIRST computation done by\r\n\t *  ANTLR stops at the end of a rule.\r\n\t *\r\n\t *  EXAMPLE\r\n\t *\r\n\t *  When you find a \"no viable alt exception\", the input is not\r\n\t *  consistent with any of the alternatives for rule r.  The best\r\n\t *  thing to do is to consume tokens until you see something that\r\n\t *  can legally follow a call to r *or* any rule that called r.\r\n\t *  You don't want the exact set of viable next tokens because the\r\n\t *  input might just be missing a token--you might consume the\r\n\t *  rest of the input looking for one of the missing tokens.\r\n\t *\r\n\t *  Consider grammar:\r\n\t *\r\n\t *  a : '[' b ']'\r\n\t *    | '(' b ')'\r\n\t *    ;\r\n\t *  b : c '^' INT ;\r\n\t *  c : ID\r\n\t *    | INT\r\n\t *    ;\r\n\t *\r\n\t *  At each rule invocation, the set of tokens that could follow\r\n\t *  that rule is pushed on a stack.  Here are the various\r\n\t *  context-sensitive follow sets:\r\n\t *\r\n\t *  FOLLOW(b1_in_a) = FIRST(']') = ']'\r\n\t *  FOLLOW(b2_in_a) = FIRST(')') = ')'\r\n\t *  FOLLOW(c_in_b) = FIRST('^') = '^'\r\n\t *\r\n\t *  Upon erroneous input \"[]\", the call chain is\r\n\t *\r\n\t *  a -> b -> c\r\n\t *\r\n\t *  and, hence, the follow context stack is:\r\n\t *\r\n\t *  depth     follow set       start of rule execution\r\n\t *    0         <EOF>                    a (from main())\r\n\t *    1          ']'                     b\r\n\t *    2          '^'                     c\r\n\t *\r\n\t *  Notice that ')' is not included, because b would have to have\r\n\t *  been called from a different context in rule a for ')' to be\r\n\t *  included.\r\n\t *\r\n\t *  For error recovery, we cannot consider FOLLOW(c)\r\n\t *  (context-sensitive or otherwise).  We need the combined set of\r\n\t *  all context-sensitive FOLLOW sets--the set of all tokens that\r\n\t *  could follow any reference in the call chain.  We need to\r\n\t *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if\r\n\t *  we resync'd to that token, we'd consume until EOF.  We need to\r\n\t *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\r\n\t *  In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\r\n\t *  not consume anything. After printing an error, rule c would\r\n\t *  return normally.  Rule b would not find the required '^' though.\r\n\t *  At this point, it gets a mismatched token error and\r\n\t *  exception (since LA(1) is not in the viable following token\r\n\t *  set).  The rule exception handler tries to recover, but finds\r\n\t *  the same recovery set and doesn't consume anything.  Rule b\r\n\t *  exits normally returning to rule a.  Now it finds the ']' (and\r\n\t *  with the successful match exits errorRecovery mode).\r\n\t *\r\n\t *  So, you can see that the parser walks up the call chain looking\r\n\t *  for the token that was a member of the recovery set.\r\n\t *\r\n\t *  Errors are not generated in errorRecovery mode.\r\n\t *\r\n\t *  ANTLR's error recovery mechanism is based upon original ideas:\r\n\t *\r\n\t *  \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\r\n\t *\r\n\t *  and\r\n\t *\r\n\t *  \"A note on error recovery in recursive descent parsers\":\r\n\t *  http://portal.acm.org/citation.cfm?id=947902.947905\r\n\t *\r\n\t *  Later, Josef Grosch had some good ideas:\r\n\t *\r\n\t *  \"Efficient and Comfortable Error Recovery in Recursive Descent\r\n\t *  Parsers\":\r\n\t *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\r\n\t *\r\n\t *  Like Grosch I implement context-sensitive FOLLOW sets that are combined\r\n\t *  at run-time upon error to avoid overhead during parsing.\r\n\t */\r\n\t@NotNull\r\n\tprotected getErrorRecoverySet(@NotNull recognizer: Parser): IntervalSet {\r\n\t\tlet atn: ATN = recognizer.interpreter.atn;\r\n\t\tlet ctx: RuleContext | undefined = recognizer.context;\r\n\t\tlet recoverSet: IntervalSet = new IntervalSet();\r\n\t\twhile (ctx && ctx.invokingState >= 0) {\r\n\t\t\t// compute what follows who invoked us\r\n\t\t\tlet invokingState: ATNState = atn.states[ctx.invokingState];\r\n\t\t\tlet rt = invokingState.transition(0) as RuleTransition;\r\n\t\t\tlet follow: IntervalSet = atn.nextTokens(rt.followState);\r\n\t\t\trecoverSet.addAll(follow);\r\n\t\t\tctx = ctx._parent;\r\n\t\t}\r\n\t\trecoverSet.remove(Token.EPSILON);\r\n//\t\tSystem.out.println(\"recover set \"+recoverSet.toString(recognizer.getTokenNames()));\r\n\t\treturn recoverSet;\r\n\t}\r\n\r\n\t/** Consume tokens until one matches the given token set. */\r\n\tprotected consumeUntil(@NotNull recognizer: Parser, @NotNull set: IntervalSet): void {\r\n//\t\tSystem.err.println(\"consumeUntil(\"+set.toString(recognizer.getTokenNames())+\")\");\r\n\t\tlet ttype: number = recognizer.inputStream.LA(1);\r\n\t\twhile (ttype !== Token.EOF && !set.contains(ttype)) {\r\n\t\t\t//System.out.println(\"consume during recover LA(1)=\"+getTokenNames()[input.LA(1)]);\r\n//\t\t\trecognizer.inputStream.consume();\r\n\t\t\trecognizer.consume();\r\n\t\t\tttype = recognizer.inputStream.LA(1);\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:31.0349605-07:00\r\n\r\nimport { DecisionInfo } from \"./DecisionInfo\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { ProfilingATNSimulator } from \"./ProfilingATNSimulator\";\r\n\r\n/**\r\n * This class provides access to specific and aggregate statistics gathered\r\n * during profiling of a parser.\r\n *\r\n * @since 4.3\r\n */\r\nexport class ParseInfo {\r\n\tprotected atnSimulator: ProfilingATNSimulator;\r\n\r\n\tconstructor(@NotNull atnSimulator: ProfilingATNSimulator) {\r\n\t\tthis.atnSimulator = atnSimulator;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets an array of {@link DecisionInfo} instances containing the profiling\r\n\t * information gathered for each decision in the ATN.\r\n\t *\r\n\t * @returns An array of {@link DecisionInfo} instances, indexed by decision\r\n\t * number.\r\n\t */\r\n\t@NotNull\r\n\tpublic getDecisionInfo(): DecisionInfo[] {\r\n\t\treturn this.atnSimulator.getDecisionInfo();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the decision numbers for decisions that required one or more\r\n\t * full-context predictions during parsing. These are decisions for which\r\n\t * {@link DecisionInfo#LL_Fallback} is non-zero.\r\n\t *\r\n\t * @returns A list of decision numbers which required one or more\r\n\t * full-context predictions during parsing.\r\n\t */\r\n\t@NotNull\r\n\tpublic getLLDecisions(): number[] {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet LL: number[] = [];\r\n\t\tfor (let i = 0; i < decisions.length; i++) {\r\n\t\t\tlet fallBack: number = decisions[i].LL_Fallback;\r\n\t\t\tif (fallBack > 0) {\r\n\t\t\t\tLL.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn LL;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total time spent during prediction across all decisions made\r\n\t * during parsing. This value is the sum of\r\n\t * {@link DecisionInfo#timeInPrediction} for all decisions.\r\n\t */\r\n\tpublic getTotalTimeInPrediction(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet t: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tt += decision.timeInPrediction;\r\n\t\t}\r\n\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of SLL lookahead operations across all decisions\r\n\t * made during parsing. This value is the sum of\r\n\t * {@link DecisionInfo#SLL_TotalLook} for all decisions.\r\n\t */\r\n\tpublic getTotalSLLLookaheadOps(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet k: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tk += decision.SLL_TotalLook;\r\n\t\t}\r\n\r\n\t\treturn k;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of LL lookahead operations across all decisions\r\n\t * made during parsing. This value is the sum of\r\n\t * {@link DecisionInfo#LL_TotalLook} for all decisions.\r\n\t */\r\n\tpublic getTotalLLLookaheadOps(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet k: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tk += decision.LL_TotalLook;\r\n\t\t}\r\n\r\n\t\treturn k;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of ATN lookahead operations for SLL prediction\r\n\t * across all decisions made during parsing.\r\n\t */\r\n\tpublic getTotalSLLATNLookaheadOps(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet k: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tk += decision.SLL_ATNTransitions;\r\n\t\t}\r\n\r\n\t\treturn k;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of ATN lookahead operations for LL prediction\r\n\t * across all decisions made during parsing.\r\n\t */\r\n\tpublic getTotalLLATNLookaheadOps(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet k: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tk += decision.LL_ATNTransitions;\r\n\t\t}\r\n\r\n\t\treturn k;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of ATN lookahead operations for SLL and LL\r\n\t * prediction across all decisions made during parsing.\r\n\t *\r\n\t * This value is the sum of {@link #getTotalSLLATNLookaheadOps} and\r\n\t * {@link #getTotalLLATNLookaheadOps}.\r\n\t */\r\n\tpublic getTotalATNLookaheadOps(): number {\r\n\t\tlet decisions: DecisionInfo[] = this.atnSimulator.getDecisionInfo();\r\n\t\tlet k: number = 0;\r\n\t\tfor (let decision of decisions) {\r\n\t\t\tk += decision.SLL_ATNTransitions;\r\n\t\t\tk += decision.LL_ATNTransitions;\r\n\t\t}\r\n\r\n\t\treturn k;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the total number of DFA states stored in the DFA cache for all\r\n\t * decisions in the ATN.\r\n\t */\r\n\tpublic getDFASize(): number;\r\n\r\n\t/**\r\n\t * Gets the total number of DFA states stored in the DFA cache for a\r\n\t * particular decision.\r\n\t */\r\n\tpublic getDFASize(decision: number): number;\r\n\r\n\tpublic getDFASize(decision?: number): number {\r\n\t\tif (decision) {\r\n\t\t\tlet decisionToDFA: DFA = this.atnSimulator.atn.decisionToDFA[decision];\r\n\t\t\treturn decisionToDFA.states.size;\r\n\t\t} else {\r\n\t\t\tlet n: number = 0;\r\n\t\t\tlet decisionToDFA: DFA[] = this.atnSimulator.atn.decisionToDFA;\r\n\t\t\tfor (let i = 0; i < decisionToDFA.length; i++) {\r\n\t\t\t\tn += this.getDFASize(i);\r\n\t\t\t}\r\n\r\n\t\t\treturn n;\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:56.9812284-07:00\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\r\nimport { BitSet } from \"./misc/BitSet\";\r\nimport { DFA } from \"./dfa/DFA\";\r\nimport { Parser } from \"./Parser\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { ProxyErrorListener } from \"./ProxyErrorListener\";\r\nimport { ParserErrorListener } from \"./ParserErrorListener\";\r\nimport { SimulatorState } from \"./atn/SimulatorState\";\r\nimport { Token } from \"./Token\";\r\nimport { Override } from \"./Decorators\";\r\n\r\n/**\r\n * @author Sam Harwell\r\n */\r\nexport class ProxyParserErrorListener extends ProxyErrorListener<Token, ParserErrorListener>\r\n\timplements ParserErrorListener {\r\n\r\n\tconstructor(delegates: ParserErrorListener[]) {\r\n\t\tsuper(delegates);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportAmbiguity(\r\n\t\trecognizer: Parser,\r\n\t\tdfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\texact: boolean,\r\n\t\tambigAlts: BitSet | undefined,\r\n\t\tconfigs: ATNConfigSet): void {\r\n\t\tthis.getDelegates()\r\n\t\t\t.forEach((listener) => {\r\n\t\t\t\tif (listener.reportAmbiguity) {\r\n\t\t\t\t\tlistener.reportAmbiguity(\r\n\t\t\t\t\t\trecognizer,\r\n\t\t\t\t\t\tdfa,\r\n\t\t\t\t\t\tstartIndex,\r\n\t\t\t\t\t\tstopIndex,\r\n\t\t\t\t\t\texact,\r\n\t\t\t\t\t\tambigAlts,\r\n\t\t\t\t\t\tconfigs);\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportAttemptingFullContext(\r\n\t\trecognizer: Parser,\r\n\t\tdfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tconflictingAlts: BitSet | undefined,\r\n\t\tconflictState: SimulatorState): void {\r\n\t\tthis.getDelegates()\r\n\t\t\t.forEach((listener) => {\r\n\t\t\t\tif (listener.reportAttemptingFullContext) {\r\n\t\t\t\t\tlistener.reportAttemptingFullContext(\r\n\t\t\t\t\t\trecognizer,\r\n\t\t\t\t\t\tdfa,\r\n\t\t\t\t\t\tstartIndex,\r\n\t\t\t\t\t\tstopIndex,\r\n\t\t\t\t\t\tconflictingAlts,\r\n\t\t\t\t\t\tconflictState);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reportContextSensitivity(\r\n\t\trecognizer: Parser,\r\n\t\tdfa: DFA,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tprediction: number,\r\n\t\tacceptState: SimulatorState): void {\r\n\t\tthis.getDelegates()\r\n\t\t\t.forEach((listener) => {\r\n\t\t\t\tif (listener.reportContextSensitivity) {\r\n\t\t\t\t\tlistener.reportContextSensitivity(\r\n\t\t\t\t\t\trecognizer,\r\n\t\t\t\t\t\tdfa,\r\n\t\t\t\t\t\tstartIndex,\r\n\t\t\t\t\t\tstopIndex,\r\n\t\t\t\t\t\tprediction,\r\n\t\t\t\t\t\tacceptState);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:42.5447085-07:00\r\n\r\n/**\r\n * This exception is thrown to cancel a parsing operation. This exception does\r\n * not extend {@link RecognitionException}, allowing it to bypass the standard\r\n * error recovery mechanisms. {@link BailErrorStrategy} throws this exception in\r\n * response to a parse error.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ParseCancellationException extends Error {\r\n\t// private static serialVersionUID: number =  -3529552099366979683L;\r\n\tpublic readonly stack?: string;\r\n\r\n\tconstructor(public cause: Error) {\r\n\t\tsuper(cause.message);\r\n\t\tthis.stack = cause.stack;\r\n\t}\r\n\r\n\tpublic getCause(): Error {\r\n\t\treturn this.cause;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:49.2855056-07:00\r\n\r\nimport { DefaultErrorStrategy } from \"./DefaultErrorStrategy\";\r\nimport { Parser } from \"./Parser\";\r\nimport { InputMismatchException } from \"./InputMismatchException\";\r\nimport { Override } from \"./Decorators\";\r\nimport { ParseCancellationException } from \"./misc/ParseCancellationException\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Token } from \"./Token\";\r\n\r\n/**\r\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\r\n * by immediately canceling the parse operation with a\r\n * {@link ParseCancellationException}. The implementation ensures that the\r\n * {@link ParserRuleContext#exception} field is set for all parse tree nodes\r\n * that were not completed prior to encountering the error.\r\n *\r\n * This error strategy is useful in the following scenarios.\r\n *\r\n * * **Two-stage parsing:** This error strategy allows the first\r\n *   stage of two-stage parsing to immediately terminate if an error is\r\n *   encountered, and immediately fall back to the second stage. In addition to\r\n *   avoiding wasted work by attempting to recover from errors here, the empty\r\n *   implementation of {@link BailErrorStrategy#sync} improves the performance of\r\n *   the first stage.\r\n * * **Silent validation:** When syntax errors are not being\r\n *   reported or logged, and the parse result is simply ignored if errors occur,\r\n *   the {@link BailErrorStrategy} avoids wasting work on recovering from errors\r\n *   when the result will be ignored either way.\r\n *\r\n * ```\r\n * myparser.errorHandler = new BailErrorStrategy();\r\n * ```\r\n *\r\n * @see Parser.errorHandler\r\n */\r\nexport class BailErrorStrategy extends DefaultErrorStrategy {\r\n\t/** Instead of recovering from exception `e`, re-throw it wrapped\r\n\t *  in a {@link ParseCancellationException} so it is not caught by the\r\n\t *  rule function catches.  Use {@link Exception#getCause()} to get the\r\n\t *  original {@link RecognitionException}.\r\n\t */\r\n\t@Override\r\n\tpublic recover(recognizer: Parser, e: RecognitionException): void {\r\n\t\tfor (let context: ParserRuleContext | undefined = recognizer.context; context; context = context.parent) {\r\n\t\t\tcontext.exception = e;\r\n\t\t}\r\n\r\n\t\tthrow new ParseCancellationException(e);\r\n\t}\r\n\r\n\t/** Make sure we don't attempt to recover inline; if the parser\r\n\t *  successfully recovers, it won't throw an exception.\r\n\t */\r\n\t@Override\r\n\tpublic recoverInline(recognizer: Parser): Token {\r\n\t\tlet e = new InputMismatchException(recognizer);\r\n\t\tfor (let context: ParserRuleContext | undefined = recognizer.context; context; context = context.parent) {\r\n\t\t\tcontext.exception = e;\r\n\t\t}\r\n\r\n\t\tthrow new ParseCancellationException(e);\r\n\t}\r\n\r\n\t/** Make sure we don't attempt to recover from problems in subrules. */\r\n\t@Override\r\n\tpublic sync(recognizer: Parser): void {\r\n\t\t// intentionally empty\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nexport function isHighSurrogate(ch: number): boolean {\r\n\treturn ch >= 0xD800 && ch <= 0xDBFF;\r\n}\r\n\r\nexport function isLowSurrogate(ch: number): boolean {\r\n\treturn ch >= 0xDC00 && ch <= 0xDFFF;\r\n}\r\n\r\nexport function isSupplementaryCodePoint(ch: number): boolean {\r\n\treturn ch >= 0x10000;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport * as assert from \"assert\";\r\nimport * as Character from \"./misc/Character\";\r\n\r\n/**\r\n * Wrapper for `Uint8Array` / `Uint16Array` / `Int32Array`.\r\n */\r\nexport class CodePointBuffer {\r\n\tprivate readonly buffer: Uint8Array | Uint16Array | Int32Array;\r\n\tprivate _position: number;\r\n\tprivate _size: number;\r\n\r\n\tconstructor(buffer: Uint8Array | Uint16Array | Int32Array, size: number) {\r\n\t\tthis.buffer = buffer;\r\n\t\tthis._position = 0;\r\n\t\tthis._size = size;\r\n\t}\r\n\r\n\tpublic static withArray(buffer: Uint8Array | Uint16Array | Int32Array): CodePointBuffer {\r\n\t\treturn new CodePointBuffer(buffer, buffer.length);\r\n\t}\r\n\r\n\tpublic get position(): number {\r\n\t\treturn this._position;\r\n\t}\r\n\r\n\tpublic set position(newPosition: number) {\r\n\t\tif (newPosition < 0 || newPosition > this._size) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\tthis._position = newPosition;\r\n\t}\r\n\r\n\tpublic get remaining(): number {\r\n\t\treturn this._size - this.position;\r\n\t}\r\n\r\n\tpublic get(offset: number): number {\r\n\t\treturn this.buffer[offset];\r\n\t}\r\n\r\n\tpublic array(): Uint8Array | Uint16Array | Int32Array {\r\n\t\treturn this.buffer.slice(0, this._size);\r\n\t}\r\n\r\n\tpublic static builder(initialBufferSize: number): CodePointBuffer.Builder {\r\n\t\treturn new CodePointBuffer.Builder(initialBufferSize);\r\n\t}\r\n}\r\n\r\nexport namespace CodePointBuffer {\r\n\tconst enum Type {\r\n\t\tBYTE,\r\n\t\tCHAR,\r\n\t\tINT,\r\n\t}\r\n\r\n\texport class Builder {\r\n\t\tprivate type: Type;\r\n\t\tprivate buffer: Uint8Array | Uint16Array | Int32Array;\r\n\t\tprivate prevHighSurrogate: number;\r\n\t\tprivate position: number;\r\n\r\n\t\tconstructor(initialBufferSize: number) {\r\n\t\t\tthis.type = Type.BYTE;\r\n\t\t\tthis.buffer = new Uint8Array(initialBufferSize);\r\n\t\t\tthis.prevHighSurrogate = -1;\r\n\t\t\tthis.position = 0;\r\n\t\t}\r\n\r\n\t\tpublic build(): CodePointBuffer {\r\n\t\t\treturn new CodePointBuffer(this.buffer, this.position);\r\n\t\t}\r\n\r\n\t\tprivate static roundUpToNextPowerOfTwo(i: number): number {\r\n\t\t\tlet nextPowerOfTwo: number = 32 - Math.clz32(i - 1);\r\n\t\t\treturn Math.pow(2, nextPowerOfTwo);\r\n\t\t}\r\n\r\n\t\tpublic ensureRemaining(remainingNeeded: number): void {\r\n\t\t\tswitch (this.type) {\r\n\t\t\t\tcase Type.BYTE:\r\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\r\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\r\n\t\t\t\t\t\tlet newBuffer: Uint8Array = new Uint8Array(newCapacity);\r\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\t\t\t\t\t\tthis.buffer = newBuffer;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.CHAR:\r\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\r\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\r\n\t\t\t\t\t\tlet newBuffer: Uint16Array = new Uint16Array(newCapacity);\r\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\t\t\t\t\t\tthis.buffer = newBuffer;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.INT:\r\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\r\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\r\n\t\t\t\t\t\tlet newBuffer: Int32Array = new Int32Array(newCapacity);\r\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\t\t\t\t\t\tthis.buffer = newBuffer;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic append(utf16In: Uint16Array): void {\r\n\t\t\tthis.ensureRemaining(utf16In.length);\r\n\t\t\tthis.appendArray(utf16In);\r\n\t\t}\r\n\r\n\t\tprivate appendArray(utf16In: Uint16Array): void {\r\n\t\t\tswitch (this.type) {\r\n\t\t\t\tcase Type.BYTE:\r\n\t\t\t\t\tthis.appendArrayByte(utf16In);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.CHAR:\r\n\t\t\t\t\tthis.appendArrayChar(utf16In);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.INT:\r\n\t\t\t\t\tthis.appendArrayInt(utf16In);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate appendArrayByte(utf16In: Uint16Array): void {\r\n\t\t\tassert(this.prevHighSurrogate === -1);\r\n\r\n\t\t\tlet input: Uint16Array = utf16In;\r\n\t\t\tlet inOffset: number = 0;\r\n\t\t\tlet inLimit: number = utf16In.length;\r\n\r\n\t\t\tlet outByte = this.buffer;\r\n\t\t\tlet outOffset: number = this.position;\r\n\r\n\t\t\twhile (inOffset < inLimit) {\r\n\t\t\t\tlet c: number = input[inOffset];\r\n\t\t\t\tif (c <= 0xFF) {\r\n\t\t\t\t\toutByte[outOffset] = c;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tutf16In = utf16In.subarray(inOffset, inLimit);\r\n\t\t\t\t\tthis.position = outOffset;\r\n\t\t\t\t\tif (!Character.isHighSurrogate(c)) {\r\n\t\t\t\t\t\tthis.byteToCharBuffer(utf16In.length);\r\n\t\t\t\t\t\tthis.appendArrayChar(utf16In);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.byteToIntBuffer(utf16In.length);\r\n\t\t\t\t\t\tthis.appendArrayInt(utf16In);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinOffset++;\r\n\t\t\t\toutOffset++;\r\n\t\t\t}\r\n\r\n\t\t\tthis.position = outOffset;\r\n\t\t}\r\n\r\n\t\tprivate appendArrayChar(utf16In: Uint16Array): void {\r\n\t\t\tassert(this.prevHighSurrogate === -1);\r\n\r\n\t\t\tlet input: Uint16Array = utf16In;\r\n\t\t\tlet inOffset: number = 0;\r\n\t\t\tlet inLimit: number = utf16In.length;\r\n\r\n\t\t\tlet outChar = this.buffer;\r\n\t\t\tlet outOffset: number = this.position;\r\n\r\n\t\t\twhile (inOffset < inLimit) {\r\n\t\t\t\tlet c: number = input[inOffset];\r\n\t\t\t\tif (!Character.isHighSurrogate(c)) {\r\n\t\t\t\t\toutChar[outOffset] = c;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tutf16In = utf16In.subarray(inOffset, inLimit);\r\n\t\t\t\t\tthis.position = outOffset;\r\n\t\t\t\t\tthis.charToIntBuffer(utf16In.length);\r\n\t\t\t\t\tthis.appendArrayInt(utf16In);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinOffset++;\r\n\t\t\t\toutOffset++;\r\n\t\t\t}\r\n\r\n\t\t\tthis.position = outOffset;\r\n\t\t}\r\n\r\n\t\tprivate appendArrayInt(utf16In: Uint16Array): void {\r\n\t\t\tlet input: Uint16Array = utf16In;\r\n\t\t\tlet inOffset: number = 0;\r\n\t\t\tlet inLimit: number = utf16In.length;\r\n\r\n\t\t\tlet outInt = this.buffer;\r\n\t\t\tlet outOffset = this.position;\r\n\r\n\t\t\twhile (inOffset < inLimit) {\r\n\t\t\t\tlet c: number = input[inOffset];\r\n\t\t\t\tinOffset++;\r\n\t\t\t\tif (this.prevHighSurrogate !== -1) {\r\n\t\t\t\t\tif (Character.isLowSurrogate(c)) {\r\n\t\t\t\t\t\toutInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0)!;\r\n\t\t\t\t\t\toutOffset++;\r\n\t\t\t\t\t\tthis.prevHighSurrogate = -1;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Dangling high surrogate\r\n\t\t\t\t\t\toutInt[outOffset] = this.prevHighSurrogate;\r\n\t\t\t\t\t\toutOffset++;\r\n\t\t\t\t\t\tif (Character.isHighSurrogate(c)) {\r\n\t\t\t\t\t\t\tthis.prevHighSurrogate = c;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\toutInt[outOffset] = c;\r\n\t\t\t\t\t\t\toutOffset++;\r\n\t\t\t\t\t\t\tthis.prevHighSurrogate = -1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (Character.isHighSurrogate(c)) {\r\n\t\t\t\t\tthis.prevHighSurrogate = c;\r\n\t\t\t\t} else {\r\n\t\t\t\t\toutInt[outOffset] = c;\r\n\t\t\t\t\toutOffset++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (this.prevHighSurrogate !== -1) {\r\n\t\t\t\t// Dangling high surrogate\r\n\t\t\t\toutInt[outOffset] = this.prevHighSurrogate;\r\n\t\t\t\toutOffset++;\r\n\t\t\t}\r\n\r\n\t\t\tthis.position = outOffset;\r\n\t\t}\r\n\r\n\t\tprivate byteToCharBuffer(toAppend: number): void {\r\n\t\t\t// CharBuffers hold twice as much per unit as ByteBuffers, so start with half the capacity.\r\n\t\t\tlet newBuffer: Uint16Array = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\r\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\r\n\t\t\tthis.type = Type.CHAR;\r\n\t\t\tthis.buffer = newBuffer;\r\n\t\t}\r\n\r\n\t\tprivate byteToIntBuffer(toAppend: number): void {\r\n\t\t\t// IntBuffers hold four times as much per unit as ByteBuffers, so start with one quarter the capacity.\r\n\t\t\tlet newBuffer: Int32Array = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));\r\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\r\n\t\t\tthis.type = Type.INT;\r\n\t\t\tthis.buffer = newBuffer;\r\n\t\t}\r\n\r\n\t\tprivate charToIntBuffer(toAppend: number): void {\r\n\t\t\t// IntBuffers hold two times as much per unit as ByteBuffers, so start with one half the capacity.\r\n\t\t\tlet newBuffer: Int32Array = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\r\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\r\n\r\n\t\t\tthis.type = Type.INT;\r\n\t\t\tthis.buffer = newBuffer;\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport * as assert from \"assert\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { CodePointBuffer } from \"./CodePointBuffer\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Override } from \"./Decorators\";\r\n\r\n/**\r\n * Alternative to {@link ANTLRInputStream} which treats the input\r\n * as a series of Unicode code points, instead of a series of UTF-16\r\n * code units.\r\n *\r\n * Use this if you need to parse input which potentially contains\r\n * Unicode values > U+FFFF.\r\n */\r\nexport class CodePointCharStream implements CharStream {\r\n\tprivate readonly _array: Uint8Array | Uint16Array | Int32Array;\r\n\tprivate readonly _size: number;\r\n\tprivate readonly _name: string;\r\n\r\n\tprivate _position: number;\r\n\r\n\t// Use the factory method {@link #fromBuffer(CodePointBuffer)} to\r\n\t// construct instances of this type.\r\n\tprotected constructor(array: Uint8Array | Uint16Array | Int32Array, position: number, remaining: number, name: string) {\r\n\t\t// TODO\r\n\t\tassert(position === 0);\r\n\t\tthis._array = array;\r\n\t\tthis._size = remaining;\r\n\t\tthis._name = name;\r\n\t\tthis._position = 0;\r\n\t}\r\n\r\n\tpublic get internalStorage(): Uint8Array | Uint16Array | Int32Array {\r\n\t\treturn this._array;\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a {@link CodePointCharStream} which provides access\r\n\t * to the Unicode code points stored in {@code codePointBuffer}.\r\n\t */\r\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer): CodePointCharStream;\r\n\r\n\t/**\r\n\t * Constructs a named {@link CodePointCharStream} which provides access\r\n\t * to the Unicode code points stored in {@code codePointBuffer}.\r\n\t */\r\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer, name: string): CodePointCharStream;\r\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer, name?: string): CodePointCharStream {\r\n\t\tif (name === undefined || name.length === 0) {\r\n\t\t\tname = IntStream.UNKNOWN_SOURCE_NAME;\r\n\t\t}\r\n\r\n\t\t// Java lacks generics on primitive types.\r\n\t\t//\r\n\t\t// To avoid lots of calls to virtual methods in the\r\n\t\t// very hot codepath of LA() below, we construct one\r\n\t\t// of three concrete subclasses.\r\n\t\t//\r\n\t\t// The concrete subclasses directly access the code\r\n\t\t// points stored in the underlying array (byte[],\r\n\t\t// char[], or int[]), so we can avoid lots of virtual\r\n\t\t// method calls to ByteBuffer.get(offset).\r\n\t\treturn new CodePointCharStream(\r\n\t\t\tcodePointBuffer.array(),\r\n\t\t\tcodePointBuffer.position,\r\n\t\t\tcodePointBuffer.remaining,\r\n\t\t\tname);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic consume(): void {\r\n\t\tif (this._size - this._position === 0) {\r\n\t\t\tassert(this.LA(1) === IntStream.EOF);\r\n\t\t\tthrow new RangeError(\"cannot consume EOF\");\r\n\t\t}\r\n\r\n\t\tthis._position++;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic get index(): number {\r\n\t\treturn this._position;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic get size(): number {\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\t/** mark/release do nothing; we have entire buffer */\r\n\t@Override\r\n\tpublic mark(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic release(marker: number): void {\r\n\t\t// No default implementation since this stream buffers the entire input\r\n\t}\r\n\r\n\t@Override\r\n\tpublic seek(index: number): void {\r\n\t\tthis._position = index;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic get sourceName(): string {\r\n\t\treturn this._name;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this.getText(Interval.of(0, this.size - 1));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic LA(i: number): number {\r\n\t\tlet offset: number;\r\n\t\tswitch (Math.sign(i)) {\r\n\t\t\tcase -1:\r\n\t\t\t\toffset = this.index + i;\r\n\t\t\t\tif (offset < 0) {\r\n\t\t\t\t\treturn IntStream.EOF;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this._array[offset];\r\n\r\n\t\t\tcase 0:\r\n\t\t\t\t// Undefined\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\toffset = this.index + i - 1;\r\n\t\t\t\tif (offset >= this.size) {\r\n\t\t\t\t\treturn IntStream.EOF;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this._array[offset];\r\n\t\t}\r\n\r\n\t\tthrow new RangeError(\"Not reached\");\r\n\t}\r\n\r\n\t/** Return the UTF-16 encoded string for the given interval */\r\n\t@Override\r\n\tpublic getText(interval: Interval): string {\r\n\t\tconst startIdx: number = Math.min(interval.a, this.size);\r\n\t\tconst len: number = Math.min(interval.b - interval.a + 1, this.size - startIdx);\r\n\r\n\t\tif (this._array instanceof Int32Array) {\r\n\t\t\treturn String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));\r\n\t\t} else {\r\n\t\t\treturn String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport { CodePointBuffer } from \"./CodePointBuffer\";\r\nimport { CodePointCharStream } from \"./CodePointCharStream\";\r\nimport { IntStream } from \"./IntStream\";\r\n\r\n// const DEFAULT_BUFFER_SIZE: number = 4096;\r\n\r\n/** This class represents the primary interface for creating {@link CharStream}s\r\n *  from a variety of sources as of 4.7.  The motivation was to support\r\n *  Unicode code points > U+FFFF.  {@link ANTLRInputStream} and\r\n *  {@link ANTLRFileStream} are now deprecated in favor of the streams created\r\n *  by this interface.\r\n *\r\n *  DEPRECATED: {@code new ANTLRFileStream(\"myinputfile\")}\r\n *  NEW:        {@code CharStreams.fromFileName(\"myinputfile\")}\r\n *\r\n *  WARNING: If you use both the deprecated and the new streams, you will see\r\n *  a nontrivial performance degradation. This speed hit is because the\r\n *  {@link Lexer}'s internal code goes from a monomorphic to megamorphic\r\n *  dynamic dispatch to get characters from the input stream. Java's\r\n *  on-the-fly compiler (JIT) is unable to perform the same optimizations\r\n *  so stick with either the old or the new streams, if performance is\r\n *  a primary concern. See the extreme debugging and spelunking\r\n *  needed to identify this issue in our timing rig:\r\n *\r\n *      https://github.com/antlr/antlr4/pull/1781\r\n *\r\n *  The ANTLR character streams still buffer all the input when you create\r\n *  the stream, as they have done for ~20 years. If you need unbuffered\r\n *  access, please note that it becomes challenging to create\r\n *  parse trees. The parse tree has to point to tokens which will either\r\n *  point into a stale location in an unbuffered stream or you have to copy\r\n *  the characters out of the buffer into the token. That defeats the purpose\r\n *  of unbuffered input. Per the ANTLR book, unbuffered streams are primarily\r\n *  useful for processing infinite streams *during the parse.*\r\n *\r\n *  The new streams also use 8-bit buffers when possible so this new\r\n *  interface supports character streams that use half as much memory\r\n *  as the old {@link ANTLRFileStream}, which assumed 16-bit characters.\r\n *\r\n *  A big shout out to Ben Hamilton (github bhamiltoncx) for his superhuman\r\n *  efforts across all targets to get true Unicode 3.1 support for U+10FFFF.\r\n *\r\n *  @since 4.7\r\n */\r\nexport namespace CharStreams {\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given a path to a UTF-8\r\n\t//  * encoded file on disk.\r\n\t//  *\r\n\t//  * Reads the entire contents of the file into the result before returning.\r\n\t//  */\r\n\t// export function fromFile(file: File): CharStream;\r\n\t// export function fromFile(file: File, charset: Charset): CharStream;\r\n\t// export function fromFile(file: File, charset?: Charset): CharStream {\r\n\t// \tif (charset === undefined) {\r\n\t// \t\tcharset = Charset.forName(\"UTF-8\");\r\n\t// \t}\r\n\r\n\t// \tlet size: number = file.length();\r\n\t// \treturn fromStream(new FileInputStream(file), charset, file.toString(), size);\r\n\t// }\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given a string containing a\r\n\t//  * path to a UTF-8 file on disk.\r\n\t//  *\r\n\t//  * Reads the entire contents of the file into the result before returning.\r\n\t//  */\r\n\t// export function fromFileName(fileName: string): CharStream;\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given a string containing a\r\n\t//  * path to a file on disk and the charset of the bytes\r\n\t//  * contained in the file.\r\n\t//  *\r\n\t//  * Reads the entire contents of the file into the result before returning.\r\n\t//  */\r\n\t// export function fromFileName(fileName: string, charset: Charset): CharStream;\r\n\t// export function fromFileName(fileName: string, charset?: Charset): CharStream {\r\n\t// \tif (charset === undefined) {\r\n\t// \t\tcharset = Charset.forName(\"UTF-8\");\r\n\t// \t}\r\n\r\n\t// \treturn fromFile(new File(fileName), charset);\r\n\t// }\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given an opened {@link InputStream}\r\n\t//  * containing UTF-8 bytes.\r\n\t//  *\r\n\t//  * Reads the entire contents of the {@code InputStream} into\r\n\t//  * the result before returning, then closes the {@code InputStream}.\r\n\t//  */\r\n\t// export function fromStream(is: InputStream): CharStream;\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given an opened {@link InputStream} and the\r\n\t//  * charset of the bytes contained in the stream.\r\n\t//  *\r\n\t//  * Reads the entire contents of the {@code InputStream} into\r\n\t//  * the result before returning, then closes the {@code InputStream}.\r\n\t//  */\r\n\t// export function fromStream(is: InputStream, charset: Charset): CharStream;\r\n\r\n\t// export function fromStream(is: InputStream, charset: Charset, sourceName: string, inputSize: number): CharStream;\r\n\t// export function fromStream(is: InputStream, charset?: Charset, sourceName?: string, inputSize?: number): CharStream {\r\n\t// \tif (charset === undefined) {\r\n\t// \t\tcharset = Charset.forName(\"UTF-8\");\r\n\t// \t}\r\n\r\n\t// \tif (sourceName === undefined) {\r\n\t// \t\tsourceName = IntStream.UNKNOWN_SOURCE_NAME;\r\n\t// \t}\r\n\r\n\t// \tif (inputSize === undefined) {\r\n\t// \t\tinputSize = -1;\r\n\t// \t}\r\n\r\n\t// \treturn fromChannel(\r\n\t// \t\tChannels.newChannel(is),\r\n\t// \t\tcharset,\r\n\t// \t\tDEFAULT_BUFFER_SIZE,\r\n\t// \t\tCodingErrorAction.REPLACE,\r\n\t// \t\tsourceName,\r\n\t// \t\tinputSize);\r\n\t// }\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given an opened {@link ReadableByteChannel}\r\n\t//  * containing UTF-8 bytes.\r\n\t//  *\r\n\t//  * Reads the entire contents of the {@code channel} into\r\n\t//  * the result before returning, then closes the {@code channel}.\r\n\t//  */\r\n\t// export function fromChannel(channel: ReadableByteChannel): CharStream;\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given an opened {@link ReadableByteChannel} and the\r\n\t//  * charset of the bytes contained in the channel.\r\n\t//  *\r\n\t//  * Reads the entire contents of the {@code channel} into\r\n\t//  * the result before returning, then closes the {@code channel}.\r\n\t//  */\r\n\t// export function fromChannel(channel: ReadableByteChannel, charset: Charset): CharStream;\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given an opened {@link ReadableByteChannel}\r\n\t//  * containing UTF-8 bytes.\r\n\t//  *\r\n\t//  * Reads the entire contents of the {@code channel} into\r\n\t//  * the result before returning, then closes the {@code channel}.\r\n\t//  */\r\n\t// export function fromChannel(\r\n\t// \tchannel: ReadableByteChannel,\r\n\t// \tcharset: Charset,\r\n\t// \tbufferSize: number,\r\n\t// \tdecodingErrorAction: CodingErrorAction,\r\n\t// \tsourceName: string): CodePointCharStream;\r\n\r\n\t// export function fromChannel(\r\n\t// \tchannel: ReadableByteChannel,\r\n\t// \tcharset: Charset,\r\n\t// \tbufferSize: number,\r\n\t// \tdecodingErrorAction: CodingErrorAction,\r\n\t// \tsourceName: string,\r\n\t// \tinputSize: number): CodePointCharStream;\r\n\t// export function fromChannel(\r\n\t// \tchannel: ReadableByteChannel,\r\n\t// \tcharset?: Charset,\r\n\t// \tbufferSize?: number,\r\n\t// \tdecodingErrorAction?: CodingErrorAction,\r\n\t// \tsourceName?: string,\r\n\t// \tinputSize?: number): CodePointCharStream\r\n\t// {\r\n\t// \tif (charset === undefined) {\r\n\t// \t\tcharset = Charset.forName(\"UTF-8\");\r\n\t// \t}\r\n\r\n\t// \tif (bufferSize === undefined) {\r\n\t// \t\tbufferSize = DEFAULT_BUFFER_SIZE;\r\n\t// \t}\r\n\r\n\t// \tif (decodingErrorAction === undefined) {\r\n\t// \t\tdecodingErrorAction = CodingErrorAction.REPLACE;\r\n\t// \t}\r\n\r\n\t// \tif (sourceName === undefined || sourceName.length === 0) {\r\n\t// \t\tsourceName = IntStream.UNKNOWN_SOURCE_NAME;\r\n\t// \t}\r\n\r\n\t// \tif (inputSize === undefined) {\r\n\t// \t\tinputSize = -1;\r\n\t// \t}\r\n\r\n\t// \tlet codePointBuffer: CodePointBuffer = bufferFromChannel(channel, charset, bufferSize, decodingErrorAction, inputSize);\r\n\t// \treturn CodePointCharStream.fromBuffer(codePointBuffer, sourceName);\r\n\t// }\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given a {@link Reader}. Closes\r\n\t//  * the reader before returning.\r\n\t//  */\r\n\t// export function fromReader(r: Reader): CodePointCharStream;\r\n\r\n\t// /**\r\n\t//  * Creates a {@link CharStream} given a {@link Reader} and its\r\n\t//  * source name. Closes the reader before returning.\r\n\t//  */\r\n\t// export function fromReader(r: Reader, sourceName: string): CodePointCharStream;\r\n\t// export function fromReader(r: Reader, sourceName?: string): CodePointCharStream {\r\n\t// \tif (sourceName === undefined) {\r\n\t// \t\tsourceName = IntStream.UNKNOWN_SOURCE_NAME;\r\n\t// \t}\r\n\r\n\t// \ttry {\r\n\t// \t\tlet codePointBufferBuilder: CodePointBuffer.Builder = CodePointBuffer.builder(DEFAULT_BUFFER_SIZE);\r\n\t// \t\tlet charBuffer: CharBuffer = CharBuffer.allocate(DEFAULT_BUFFER_SIZE);\r\n\t// \t\twhile ((r.read(charBuffer)) !== -1) {\r\n\t// \t\t\tcharBuffer.flip();\r\n\t// \t\t\tcodePointBufferBuilder.append(charBuffer);\r\n\t// \t\t\tcharBuffer.compact();\r\n\t// \t\t}\r\n\r\n\t// \t\treturn CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);\r\n\t// \t} finally {\r\n\t// \t\tr.close();\r\n\t// \t}\r\n\t// }\r\n\r\n\t/**\r\n\t * Creates a {@link CharStream} given a {@link String}.\r\n\t */\r\n\texport function fromString(s: string): CodePointCharStream;\r\n\r\n\t/**\r\n\t * Creates a {@link CharStream} given a {@link String} and the {@code sourceName}\r\n\t * from which it came.\r\n\t */\r\n\texport function fromString(s: string, sourceName: string): CodePointCharStream;\r\n\texport function fromString(s: string, sourceName?: string): CodePointCharStream {\r\n\t\tif (sourceName === undefined || sourceName.length === 0) {\r\n\t\t\tsourceName = IntStream.UNKNOWN_SOURCE_NAME;\r\n\t\t}\r\n\r\n\t\t// Initial guess assumes no code points > U+FFFF: one code\r\n\t\t// point for each code unit in the string\r\n\t\tlet codePointBufferBuilder: CodePointBuffer.Builder = CodePointBuffer.builder(s.length);\r\n\r\n\t\t// TODO: CharBuffer.wrap(String) rightfully returns a read-only buffer\r\n\t\t// which doesn't expose its array, so we make a copy.\r\n\t\tlet cb: Uint16Array = new Uint16Array(s.length);\r\n\t\tfor (let i = 0; i < s.length; i++) {\r\n\t\t\tcb[i] = s.charCodeAt(i);\r\n\t\t}\r\n\r\n\t\tcodePointBufferBuilder.append(cb);\r\n\t\treturn CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);\r\n\t}\r\n\r\n\t// export function bufferFromChannel(\r\n\t// \tchannel: ReadableByteChannel,\r\n\t// \tcharset: Charset,\r\n\t// \tbufferSize: number,\r\n\t// \tdecodingErrorAction: CodingErrorAction,\r\n\t// \tinputSize: number): CodePointBuffer {\r\n\t// \ttry {\r\n\t// \t\tlet utf8BytesIn: Uint8Array = new Uint8Array(bufferSize);\r\n\t// \t\tlet utf16CodeUnitsOut: Uint16Array = new Uint16Array(bufferSize);\r\n\t// \t\tif (inputSize === -1) {\r\n\t// \t\t\tinputSize = bufferSize;\r\n\t// \t\t} else if (inputSize > Integer.MAX_VALUE) {\r\n\t// \t\t\t// ByteBuffer et al don't support long sizes\r\n\t// \t\t\tthrow new RangeError(`inputSize ${inputSize} larger than max ${Integer.MAX_VALUE}`);\r\n\t// \t\t}\r\n\r\n\t// \t\tlet codePointBufferBuilder: CodePointBuffer.Builder = CodePointBuffer.builder(inputSize);\r\n\t// \t\tlet decoder: CharsetDecoder = charset\r\n\t// \t\t\t\t.newDecoder()\r\n\t// \t\t\t\t.onMalformedInput(decodingErrorAction)\r\n\t// \t\t\t\t.onUnmappableCharacter(decodingErrorAction);\r\n\r\n\t// \t\tlet endOfInput: boolean = false;\r\n\t// \t\twhile (!endOfInput) {\r\n\t// \t\t\tlet bytesRead: number = channel.read(utf8BytesIn);\r\n\t// \t\t\tendOfInput = (bytesRead === -1);\r\n\t// \t\t\tutf8BytesIn.flip();\r\n\t// \t\t\tlet result: CoderResult = decoder.decode(\r\n\t// \t\t\t\tutf8BytesIn,\r\n\t// \t\t\t\tutf16CodeUnitsOut,\r\n\t// \t\t\t\tendOfInput);\r\n\t// \t\t\tif (result.isError() && decodingErrorAction === CodingErrorAction.REPORT) {\r\n\t// \t\t\t\tresult.throwException();\r\n\t// \t\t\t}\r\n\r\n\t// \t\t\tutf16CodeUnitsOut.flip();\r\n\t// \t\t\tcodePointBufferBuilder.append(utf16CodeUnitsOut);\r\n\t// \t\t\tutf8BytesIn.compact();\r\n\t// \t\t\tutf16CodeUnitsOut.compact();\r\n\t// \t\t}\r\n\t// \t\t// Handle any bytes at the end of the file which need to\r\n\t// \t\t// be represented as errors or substitution characters.\r\n\t// \t\tlet flushResult: CoderResult = decoder.flush(utf16CodeUnitsOut);\r\n\t// \t\tif (flushResult.isError() && decodingErrorAction === CodingErrorAction.REPORT) {\r\n\t// \t\t\tflushResult.throwException();\r\n\t// \t\t}\r\n\r\n\t// \t\tutf16CodeUnitsOut.flip();\r\n\t// \t\tcodePointBufferBuilder.append(utf16CodeUnitsOut);\r\n\r\n\t// \t\treturn codePointBufferBuilder.build();\r\n\t// \t}\r\n\t// \tfinally {\r\n\t// \t\tchannel.close();\r\n\t// \t}\r\n\t// }\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:49.6074365-07:00\r\n\r\nimport * as assert from \"assert\";\r\nimport { CommonToken } from \"./CommonToken\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Lexer } from \"./Lexer\";\r\nimport { NotNull, Override } from \"./Decorators\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenSource } from \"./TokenSource\";\r\nimport { TokenStream } from \"./TokenStream\";\r\nimport { WritableToken } from \"./WritableToken\";\r\n\r\n/**\r\n * This implementation of {@link TokenStream} loads tokens from a\r\n * {@link TokenSource} on-demand, and places the tokens in a buffer to provide\r\n * access to any previous token by index.\r\n *\r\n * This token stream ignores the value of {@link Token#getChannel}. If your\r\n * parser requires the token stream filter tokens to only those on a particular\r\n * channel, such as {@link Token#DEFAULT_CHANNEL} or\r\n * {@link Token#HIDDEN_CHANNEL}, use a filtering token stream such a\r\n * {@link CommonTokenStream}.\r\n */\r\nexport class BufferedTokenStream implements TokenStream {\r\n\t/**\r\n\t * The {@link TokenSource} from which tokens for this stream are fetched.\r\n\t */\r\n\t@NotNull\r\n\tprivate _tokenSource: TokenSource;\r\n\r\n\t/**\r\n\t * A collection of all tokens fetched from the token source. The list is\r\n\t * considered a complete view of the input once {@link #fetchedEOF} is set\r\n\t * to `true`.\r\n\t */\r\n\tprotected tokens: Token[] = [];\r\n\r\n\t/**\r\n\t * The index into {@link #tokens} of the current token (next token to\r\n\t * {@link #consume}). {@link #tokens}`[`{@link #p}`]` should be\r\n\t * {@link #LT LT(1)}.\r\n\t *\r\n\t * This field is set to -1 when the stream is first constructed or when\r\n\t * {@link #setTokenSource} is called, indicating that the first token has\r\n\t * not yet been fetched from the token source. For additional information,\r\n\t * see the documentation of {@link IntStream} for a description of\r\n\t * Initializing Methods.\r\n\t */\r\n\tprotected p: number = -1;\r\n\r\n\t/**\r\n\t * Indicates whether the {@link Token#EOF} token has been fetched from\r\n\t * {@link #tokenSource} and added to {@link #tokens}. This field improves\r\n\t * performance for the following cases:\r\n\t *\r\n\t * * {@link #consume}: The lookahead check in {@link #consume} to prevent\r\n\t *   consuming the EOF symbol is optimized by checking the values of\r\n\t *   {@link #fetchedEOF} and {@link #p} instead of calling {@link #LA}.\r\n\t * * {@link #fetch}: The check to prevent adding multiple EOF symbols into\r\n\t *   {@link #tokens} is trivial with this field.\r\n\t */\r\n\tprotected fetchedEOF: boolean = false;\r\n\r\n\tconstructor(@NotNull tokenSource: TokenSource) {\r\n\t\tif (tokenSource == null) {\r\n\t\t\tthrow new Error(\"tokenSource cannot be null\");\r\n\t\t}\r\n\r\n\t\tthis._tokenSource = tokenSource;\r\n\t}\r\n\r\n\t@Override\r\n\tget tokenSource(): TokenSource {\r\n\t\treturn this._tokenSource;\r\n\t}\r\n\r\n\t/** Reset this token stream by setting its token source. */\r\n\tset tokenSource(tokenSource: TokenSource) {\r\n\t\tthis._tokenSource = tokenSource;\r\n\t\tthis.tokens.length = 0;\r\n\t\tthis.p = -1;\r\n\t\tthis.fetchedEOF = false;\r\n\t}\r\n\r\n\t@Override\r\n\tget index(): number {\r\n\t\treturn this.p;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic mark(): number {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic release(marker: number): void {\r\n\t\t// no resources to release\r\n\t}\r\n\r\n\t@Override\r\n\tpublic seek(index: number): void {\r\n\t\tthis.lazyInit();\r\n\t\tthis.p = this.adjustSeekIndex(index);\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn this.tokens.length;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic consume(): void {\r\n\t\tlet skipEofCheck: boolean;\r\n\t\tif (this.p >= 0) {\r\n\t\t\tif (this.fetchedEOF) {\r\n\t\t\t\t// the last token in tokens is EOF. skip check if p indexes any\r\n\t\t\t\t// fetched token except the last.\r\n\t\t\t\tskipEofCheck = this.p < this.tokens.length - 1;\r\n\t\t\t} else {\r\n\t\t\t\t// no EOF token in tokens. skip check if p indexes a fetched token.\r\n\t\t\t\tskipEofCheck = this.p < this.tokens.length;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// not yet initialized\r\n\t\t\tskipEofCheck = false;\r\n\t\t}\r\n\r\n\t\tif (!skipEofCheck && this.LA(1) === Token.EOF) {\r\n\t\t\tthrow new Error(\"cannot consume EOF\");\r\n\t\t}\r\n\r\n\t\tif (this.sync(this.p + 1)) {\r\n\t\t\tthis.p = this.adjustSeekIndex(this.p + 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Make sure index `i` in tokens has a token.\r\n\t *\r\n\t * @returns `true` if a token is located at index `i`, otherwise\r\n\t *    `false`.\r\n\t * @see #get(int i)\r\n\t */\r\n\tprotected sync(i: number): boolean {\r\n\t\tassert(i >= 0);\r\n\t\tlet n: number = i - this.tokens.length + 1; // how many more elements we need?\r\n\t\t//System.out.println(\"sync(\"+i+\") needs \"+n);\r\n\t\tif (n > 0) {\r\n\t\t\tlet fetched: number = this.fetch(n);\r\n\t\t\treturn fetched >= n;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/** Add `n` elements to buffer.\r\n\t *\r\n\t * @returns The actual number of elements added to the buffer.\r\n\t */\r\n\tprotected fetch(n: number): number {\r\n\t\tif (this.fetchedEOF) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet t: Token = this.tokenSource.nextToken();\r\n\t\t\tif (this.isWritableToken(t)) {\r\n\t\t\t\tt.tokenIndex = this.tokens.length;\r\n\t\t\t}\r\n\r\n\t\t\tthis.tokens.push(t);\r\n\t\t\tif (t.type === Token.EOF) {\r\n\t\t\t\tthis.fetchedEOF = true;\r\n\t\t\t\treturn i + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn n;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic get(i: number): Token {\r\n\t\tif (i < 0 || i >= this.tokens.length) {\r\n\t\t\tthrow new RangeError(\"token index \" + i + \" out of range 0..\" + (this.tokens.length - 1));\r\n\t\t}\r\n\r\n\t\treturn this.tokens[i];\r\n\t}\r\n\r\n\t/** Get all tokens from start..stop inclusively. */\r\n\tpublic getRange(start: number, stop: number): Token[] {\r\n\t\tif (start < 0 || stop < 0) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tthis.lazyInit();\r\n\t\tlet subset: Token[] = new Array<Token>();\r\n\t\tif (stop >= this.tokens.length) {\r\n\t\t\tstop = this.tokens.length - 1;\r\n\t\t}\r\n\r\n\t\tfor (let i = start; i <= stop; i++) {\r\n\t\t\tlet t: Token = this.tokens[i];\r\n\t\t\tif (t.type === Token.EOF) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tsubset.push(t);\r\n\t\t}\r\n\r\n\t\treturn subset;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic LA(i: number): number {\r\n\t\tlet token = this.LT(i);\r\n\t\tif (!token) {\r\n\t\t\treturn Token.INVALID_TYPE;\r\n\t\t}\r\n\r\n\t\treturn token.type;\r\n\t}\r\n\r\n\tprotected tryLB(k: number): Token | undefined {\r\n\t\tif ((this.p - k) < 0) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this.tokens[this.p - k];\r\n\t}\r\n\r\n\t@NotNull\r\n\t@Override\r\n\tpublic LT(k: number): Token {\r\n\t\tlet result = this.tryLT(k);\r\n\t\tif (result === undefined) {\r\n\t\t\tthrow new RangeError(\"requested lookback index out of range\");\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic tryLT(k: number): Token | undefined {\r\n\t\tthis.lazyInit();\r\n\t\tif (k === 0) {\r\n\t\t\tthrow new RangeError(\"0 is not a valid lookahead index\");\r\n\t\t}\r\n\r\n\t\tif (k < 0) {\r\n\t\t\treturn this.tryLB(-k);\r\n\t\t}\r\n\r\n\t\tlet i: number = this.p + k - 1;\r\n\t\tthis.sync(i);\r\n\t\tif (i >= this.tokens.length) {\r\n\t\t\t// return EOF token\r\n\t\t\t// EOF must be last token\r\n\t\t\treturn this.tokens[this.tokens.length - 1];\r\n\t\t}\r\n\r\n\t\t//\t\tif ( i>range ) range = i;\r\n\t\treturn this.tokens[i];\r\n\t}\r\n\r\n\t/**\r\n\t * Allowed derived classes to modify the behavior of operations which change\r\n\t * the current stream position by adjusting the target token index of a seek\r\n\t * operation. The default implementation simply returns `i`. If an\r\n\t * exception is thrown in this method, the current stream index should not be\r\n\t * changed.\r\n\t *\r\n\t * For example, {@link CommonTokenStream} overrides this method to ensure that\r\n\t * the seek target is always an on-channel token.\r\n\t *\r\n\t * @param i The target token index.\r\n\t * @returns The adjusted target token index.\r\n\t */\r\n\tprotected adjustSeekIndex(i: number): number {\r\n\t\treturn i;\r\n\t}\r\n\r\n\tprotected lazyInit(): void {\r\n\t\tif (this.p === -1) {\r\n\t\t\tthis.setup();\r\n\t\t}\r\n\t}\r\n\r\n\tprotected setup(): void {\r\n\t\tthis.sync(0);\r\n\t\tthis.p = this.adjustSeekIndex(0);\r\n\t}\r\n\r\n\tpublic getTokens(): Token[];\r\n\r\n\tpublic getTokens(start: number, stop: number): Token[];\r\n\r\n\tpublic getTokens(start: number, stop: number, types: Set<number>): Token[];\r\n\r\n\tpublic getTokens(start: number, stop: number, ttype: number): Token[];\r\n\r\n\t/** Given a start and stop index, return a `List` of all tokens in\r\n\t *  the token type `BitSet`.  Return an empty array if no tokens were found.  This\r\n\t *  method looks at both on and off channel tokens.\r\n\t */\r\n\tpublic getTokens(start?: number, stop?: number, types?: Set<number> | number): Token[] {\r\n\t\tthis.lazyInit();\r\n\r\n\t\tif (start === undefined) {\r\n\t\t\tassert(stop === undefined && types === undefined);\r\n\t\t\treturn this.tokens;\r\n\t\t} else if (stop === undefined) {\r\n\t\t\tstop = this.tokens.length - 1;\r\n\t\t}\r\n\r\n\t\tif (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {\r\n\t\t\tthrow new RangeError(\"start \" + start + \" or stop \" + stop + \" not in 0..\" + (this.tokens.length - 1));\r\n\t\t}\r\n\r\n\t\tif (start > stop) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tif (types === undefined) {\r\n\t\t\treturn this.tokens.slice(start, stop + 1);\r\n\t\t} else if (typeof types === \"number\") {\r\n\t\t\ttypes = new Set<number>().add(types);\r\n\t\t}\r\n\r\n\t\tlet typesSet = types;\r\n\r\n\t\t// list = tokens[start:stop]:{T t, t.type in types}\r\n\t\tlet filteredTokens: Token[] = this.tokens.slice(start, stop + 1);\r\n\t\tfilteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));\r\n\r\n\t\treturn filteredTokens;\r\n\t}\r\n\r\n\t/**\r\n\t * Given a starting index, return the index of the next token on channel.\r\n\t * Return `i` if `tokens[i]` is on channel. Return the index of\r\n\t * the EOF token if there are no tokens on channel between `i` and\r\n\t * EOF.\r\n\t */\r\n\tprotected nextTokenOnChannel(i: number, channel: number): number {\r\n\t\tthis.sync(i);\r\n\t\tif (i >= this.size) {\r\n\t\t\treturn this.size - 1;\r\n\t\t}\r\n\r\n\t\tlet token: Token = this.tokens[i];\r\n\t\twhile (token.channel !== channel) {\r\n\t\t\tif (token.type === Token.EOF) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\r\n\t\t\ti++;\r\n\t\t\tthis.sync(i);\r\n\t\t\ttoken = this.tokens[i];\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/**\r\n\t * Given a starting index, return the index of the previous token on\r\n\t * channel. Return `i` if `tokens[i]` is on channel. Return -1\r\n\t * if there are no tokens on channel between `i` and 0.\r\n\t *\r\n\t * If `i` specifies an index at or after the EOF token, the EOF token\r\n\t * index is returned. This is due to the fact that the EOF token is treated\r\n\t * as though it were on every channel.\r\n\t */\r\n\tprotected previousTokenOnChannel(i: number, channel: number): number {\r\n\t\tthis.sync(i);\r\n\t\tif (i >= this.size) {\r\n\t\t\t// the EOF token is on every channel\r\n\t\t\treturn this.size - 1;\r\n\t\t}\r\n\r\n\t\twhile (i >= 0) {\r\n\t\t\tlet token: Token = this.tokens[i];\r\n\t\t\tif (token.type === Token.EOF || token.channel === channel) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\r\n\t\t\ti--;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/** Collect all tokens on specified channel to the right of\r\n\t *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL} or\r\n\t *  EOF. If `channel` is `-1`, find any non default channel token.\r\n\t */\r\n\tpublic getHiddenTokensToRight(tokenIndex: number, channel: number = -1): Token[] {\r\n\t\tthis.lazyInit();\r\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\r\n\t\t\tthrow new RangeError(tokenIndex + \" not in 0..\" + (this.tokens.length - 1));\r\n\t\t}\r\n\r\n\t\tlet nextOnChannel: number = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);\r\n\t\tlet to: number;\r\n\t\tlet from: number = tokenIndex + 1;\r\n\t\t// if none onchannel to right, nextOnChannel=-1 so set to = last token\r\n\t\tif (nextOnChannel === -1) {\r\n\t\t\tto = this.size - 1;\r\n\t\t} else {\r\n\t\t\tto = nextOnChannel;\r\n\t\t}\r\n\r\n\t\treturn this.filterForChannel(from, to, channel);\r\n\t}\r\n\r\n\t/** Collect all tokens on specified channel to the left of\r\n\t *  the current token up until we see a token on {@link Lexer#DEFAULT_TOKEN_CHANNEL}.\r\n\t *  If `channel` is `-1`, find any non default channel token.\r\n\t */\r\n\tpublic getHiddenTokensToLeft(tokenIndex: number, channel: number = -1): Token[] {\r\n\t\tthis.lazyInit();\r\n\t\tif (tokenIndex < 0 || tokenIndex >= this.tokens.length) {\r\n\t\t\tthrow new RangeError(tokenIndex + \" not in 0..\" + (this.tokens.length - 1));\r\n\t\t}\r\n\r\n\t\tif (tokenIndex === 0) {\r\n\t\t\t// obviously no tokens can appear before the first token\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\tlet prevOnChannel: number = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);\r\n\t\tif (prevOnChannel === tokenIndex - 1) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\t// if none onchannel to left, prevOnChannel=-1 then from=0\r\n\t\tlet from: number = prevOnChannel + 1;\r\n\t\tlet to: number = tokenIndex - 1;\r\n\r\n\t\treturn this.filterForChannel(from, to, channel);\r\n\t}\r\n\r\n\tprotected filterForChannel(from: number, to: number, channel: number): Token[] {\r\n\t\tlet hidden: Token[] = new Array<Token>();\r\n\t\tfor (let i = from; i <= to; i++) {\r\n\t\t\tlet t: Token = this.tokens[i];\r\n\t\t\tif (channel === -1) {\r\n\t\t\t\tif (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {\r\n\t\t\t\t\thidden.push(t);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (t.channel === channel) {\r\n\t\t\t\t\thidden.push(t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn hidden;\r\n\t}\r\n\r\n\t@Override\r\n\tget sourceName(): string {\r\n\t\treturn this.tokenSource.sourceName;\r\n\t}\r\n\r\n\t/** Get the text of all tokens in this buffer. */\r\n\tpublic getText(): string;\r\n\tpublic getText(interval: Interval): string;\r\n\tpublic getText(context: RuleContext): string;\r\n\t@NotNull\r\n\t@Override\r\n\tpublic getText(interval?: Interval | RuleContext): string {\r\n\t\tif (interval === undefined) {\r\n\t\t\tinterval = Interval.of(0, this.size - 1);\r\n\t\t} else if (!(interval instanceof Interval)) {\r\n\t\t\t// Note: the more obvious check for 'instanceof RuleContext' results in a circular dependency problem\r\n\t\t\tinterval = interval.sourceInterval;\r\n\t\t}\r\n\r\n\t\tlet start: number = interval.a;\r\n\t\tlet stop: number = interval.b;\r\n\t\tif (start < 0 || stop < 0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tthis.fill();\r\n\t\tif (stop >= this.tokens.length) {\r\n\t\t\tstop = this.tokens.length - 1;\r\n\t\t}\r\n\r\n\t\tlet buf: string = \"\";\r\n\t\tfor (let i = start; i <= stop; i++) {\r\n\t\t\tlet t: Token = this.tokens[i];\r\n\t\t\tif (t.type === Token.EOF) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tbuf += t.text;\r\n\t\t}\r\n\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\t@NotNull\r\n\t@Override\r\n\tpublic getTextFromRange(start: any, stop: any): string {\r\n\t\tif (this.isToken(start) && this.isToken(stop)) {\r\n\t\t\treturn this.getText(Interval.of(start.tokenIndex, stop.tokenIndex));\r\n\t\t}\r\n\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\t/** Get all tokens from lexer until EOF. */\r\n\tpublic fill(): void {\r\n\t\tthis.lazyInit();\r\n\t\tconst blockSize: number = 1000;\r\n\t\twhile (true) {\r\n\t\t\tlet fetched: number = this.fetch(blockSize);\r\n\t\t\tif (fetched < blockSize) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// TODO: Figure out a way to make this more flexible?\r\n\tprivate isWritableToken(t: Token): t is WritableToken {\r\n\t\treturn t instanceof CommonToken;\r\n\t}\r\n\r\n\t// TODO: Figure out a way to make this more flexible?\r\n\tprivate isToken(t: any): t is Token {\r\n\t\treturn t instanceof CommonToken;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:50.3953157-07:00\r\n\r\nimport { BufferedTokenStream } from \"./BufferedTokenStream\";\r\nimport { NotNull, Override } from \"./Decorators\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenSource } from \"./TokenSource\";\r\n\r\n/**\r\n * This class extends {@link BufferedTokenStream} with functionality to filter\r\n * token streams to tokens on a particular channel (tokens where\r\n * {@link Token#getChannel} returns a particular value).\r\n *\r\n * This token stream provides access to all tokens by index or when calling\r\n * methods like {@link #getText}. The channel filtering is only used for code\r\n * accessing tokens via the lookahead methods {@link #LA}, {@link #LT}, and\r\n * {@link #LB}.\r\n *\r\n * By default, tokens are placed on the default channel\r\n * ({@link Token#DEFAULT_CHANNEL}), but may be reassigned by using the\r\n * `->channel(HIDDEN)` lexer command, or by using an embedded action to\r\n * call {@link Lexer#setChannel}.\r\n *\r\n * Note: lexer rules which use the `->skip` lexer command or call\r\n * {@link Lexer#skip} do not produce tokens at all, so input text matched by\r\n * such a rule will not be available as part of the token stream, regardless of\r\n * channel.\r\n */\r\nexport class CommonTokenStream extends BufferedTokenStream {\r\n\t/**\r\n\t * Specifies the channel to use for filtering tokens.\r\n\t *\r\n\t * The default value is {@link Token#DEFAULT_CHANNEL}, which matches the\r\n\t * default channel assigned to tokens created by the lexer.\r\n\t */\r\n\tprotected channel: number;\r\n\r\n\t/**\r\n\t * Constructs a new {@link CommonTokenStream} using the specified token\r\n\t * source and filtering tokens to the specified channel. Only tokens whose\r\n\t * {@link Token#getChannel} matches `channel` or have the\r\n\t * `Token.type` equal to {@link Token#EOF} will be returned by the\r\n\t * token stream lookahead methods.\r\n\t *\r\n\t * @param tokenSource The token source.\r\n\t * @param channel The channel to use for filtering tokens.\r\n\t */\r\n\tconstructor(@NotNull tokenSource: TokenSource, channel: number = Token.DEFAULT_CHANNEL) {\r\n\t\tsuper(tokenSource);\r\n\t\tthis.channel = channel;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected adjustSeekIndex(i: number): number {\r\n\t\treturn this.nextTokenOnChannel(i, this.channel);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected tryLB(k: number): Token | undefined {\r\n\t\tif ((this.p - k) < 0) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet i: number = this.p;\r\n\t\tlet n: number = 1;\r\n\t\t// find k good tokens looking backwards\r\n\t\twhile (n <= k && i > 0) {\r\n\t\t\t// skip off-channel tokens\r\n\t\t\ti = this.previousTokenOnChannel(i - 1, this.channel);\r\n\t\t\tn++;\r\n\t\t}\r\n\r\n\t\tif (i < 0) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this.tokens[i];\r\n\t}\r\n\r\n\t@Override\r\n\tpublic tryLT(k: number): Token | undefined {\r\n\t\t//System.out.println(\"enter LT(\"+k+\")\");\r\n\t\tthis.lazyInit();\r\n\t\tif (k === 0) {\r\n\t\t\tthrow new RangeError(\"0 is not a valid lookahead index\");\r\n\t\t}\r\n\r\n\t\tif (k < 0) {\r\n\t\t\treturn this.tryLB(-k);\r\n\t\t}\r\n\r\n\t\tlet i: number = this.p;\r\n\t\tlet n: number = 1; // we know tokens[p] is a good one\r\n\t\t// find k good tokens\r\n\t\twhile (n < k) {\r\n\t\t\t// skip off-channel tokens, but make sure to not look past EOF\r\n\t\t\tif (this.sync(i + 1)) {\r\n\t\t\t\ti = this.nextTokenOnChannel(i + 1, this.channel);\r\n\t\t\t}\r\n\t\t\tn++;\r\n\t\t}\r\n\r\n\t\t//\t\tif ( i>range ) range = i;\r\n\t\treturn this.tokens[i];\r\n\t}\r\n\r\n\t/** Count EOF just once. */\r\n\tpublic getNumberOfOnChannelTokens(): number {\r\n\t\tlet n: number = 0;\r\n\t\tthis.fill();\r\n\t\tfor (let t of this.tokens) {\r\n\t\t\tif (t.channel === this.channel) {\r\n\t\t\t\tn++;\r\n\t\t\t}\r\n\r\n\t\t\tif (t.type === Token.EOF) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn n;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:52.1916955-07:00\r\n\r\nimport { CharStream } from \"./CharStream\";\r\nimport { CommonTokenFactory } from \"./CommonTokenFactory\";\r\nimport { NotNull, Override } from \"./Decorators\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenFactory } from \"./TokenFactory\";\r\nimport { TokenSource } from \"./TokenSource\";\r\n\r\n/**\r\n * Provides an implementation of {@link TokenSource} as a wrapper around a list\r\n * of {@link Token} objects.\r\n *\r\n * If the final token in the list is an {@link Token#EOF} token, it will be used\r\n * as the EOF token for every call to {@link #nextToken} after the end of the\r\n * list is reached. Otherwise, an EOF token will be created.\r\n */\r\nexport class ListTokenSource implements TokenSource {\r\n\t/**\r\n\t * The wrapped collection of {@link Token} objects to return.\r\n\t */\r\n\tprotected tokens: Token[];\r\n\r\n\t/**\r\n\t * The name of the input source. If this value is `undefined`, a call to\r\n\t * {@link #getSourceName} should return the source name used to create the\r\n\t * the next token in {@link #tokens} (or the previous token if the end of\r\n\t * the input has been reached).\r\n\t */\r\n\tprivate _sourceName?: string;\r\n\r\n\t/**\r\n\t * The index into {@link #tokens} of token to return by the next call to\r\n\t * {@link #nextToken}. The end of the input is indicated by this value\r\n\t * being greater than or equal to the number of items in {@link #tokens}.\r\n\t */\r\n\tprotected i: number = 0;\r\n\r\n\t/**\r\n\t * This field caches the EOF token for the token source.\r\n\t */\r\n\tprotected eofToken?: Token;\r\n\r\n\t/**\r\n\t * This is the backing field for {@link #getTokenFactory} and\r\n\t * {@link setTokenFactory}.\r\n\t */\r\n\tprivate _factory: TokenFactory = CommonTokenFactory.DEFAULT;\r\n\r\n\t/**\r\n\t * Constructs a new {@link ListTokenSource} instance from the specified\r\n\t * collection of {@link Token} objects and source name.\r\n\t *\r\n\t * @param tokens The collection of {@link Token} objects to provide as a\r\n\t * {@link TokenSource}.\r\n\t * @param sourceName The name of the {@link TokenSource}. If this value is\r\n\t * `undefined`, {@link #getSourceName} will attempt to infer the name from\r\n\t * the next {@link Token} (or the previous token if the end of the input has\r\n\t * been reached).\r\n\t *\r\n\t * @exception NullPointerException if `tokens` is `undefined`\r\n\t */\r\n\tconstructor(@NotNull tokens: Token[], sourceName?: string) {\r\n\t\tif (tokens == null) {\r\n\t\t\tthrow new Error(\"tokens cannot be null\");\r\n\t\t}\r\n\r\n\t\tthis.tokens = tokens;\r\n\t\tthis._sourceName = sourceName;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tget charPositionInLine(): number {\r\n\t\tif (this.i < this.tokens.length) {\r\n\t\t\treturn this.tokens[this.i].charPositionInLine;\r\n\t\t} else if (this.eofToken != null) {\r\n\t\t\treturn this.eofToken.charPositionInLine;\r\n\t\t} else if (this.tokens.length > 0) {\r\n\t\t\t// have to calculate the result from the line/column of the previous\r\n\t\t\t// token, along with the text of the token.\r\n\t\t\tlet lastToken: Token = this.tokens[this.tokens.length - 1];\r\n\t\t\tlet tokenText: string | undefined = lastToken.text;\r\n\t\t\tif (tokenText != null) {\r\n\t\t\t\tlet lastNewLine: number = tokenText.lastIndexOf(\"\\n\");\r\n\t\t\t\tif (lastNewLine >= 0) {\r\n\t\t\t\t\treturn tokenText.length - lastNewLine - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;\r\n\t\t}\r\n\r\n\t\t// only reach this if tokens is empty, meaning EOF occurs at the first\r\n\t\t// position in the input\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tpublic nextToken(): Token {\r\n\t\tif (this.i >= this.tokens.length) {\r\n\t\t\tif (this.eofToken == null) {\r\n\t\t\t\tlet start: number = -1;\r\n\t\t\t\tif (this.tokens.length > 0) {\r\n\t\t\t\t\tlet previousStop: number = this.tokens[this.tokens.length - 1].stopIndex;\r\n\t\t\t\t\tif (previousStop !== -1) {\r\n\t\t\t\t\t\tstart = previousStop + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet stop: number = Math.max(-1, start - 1);\r\n\t\t\t\tthis.eofToken = this._factory.create({ source: this, stream: this.inputStream }, Token.EOF, \"EOF\", Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.eofToken;\r\n\t\t}\r\n\r\n\t\tlet t: Token = this.tokens[this.i];\r\n\t\tif (this.i === this.tokens.length - 1 && t.type === Token.EOF) {\r\n\t\t\tthis.eofToken = t;\r\n\t\t}\r\n\r\n\t\tthis.i++;\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tget line(): number {\r\n\t\tif (this.i < this.tokens.length) {\r\n\t\t\treturn this.tokens[this.i].line;\r\n\t\t} else if (this.eofToken != null) {\r\n\t\t\treturn this.eofToken.line;\r\n\t\t} else if (this.tokens.length > 0) {\r\n\t\t\t// have to calculate the result from the line/column of the previous\r\n\t\t\t// token, along with the text of the token.\r\n\t\t\tlet lastToken: Token = this.tokens[this.tokens.length - 1];\r\n\t\t\tlet line: number = lastToken.line;\r\n\r\n\t\t\tlet tokenText: string | undefined = lastToken.text;\r\n\t\t\tif (tokenText != null) {\r\n\t\t\t\tfor (let i = 0; i < tokenText.length; i++) {\r\n\t\t\t\t\tif (tokenText.charAt(i) === \"\\n\") {\r\n\t\t\t\t\t\tline++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if no text is available, assume the token did not contain any newline characters.\r\n\t\t\treturn line;\r\n\t\t}\r\n\r\n\t\t// only reach this if tokens is empty, meaning EOF occurs at the first\r\n\t\t// position in the input\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tget inputStream(): CharStream | undefined {\r\n\t\tif (this.i < this.tokens.length) {\r\n\t\t\treturn this.tokens[this.i].inputStream;\r\n\t\t} else if (this.eofToken != null) {\r\n\t\t\treturn this.eofToken.inputStream;\r\n\t\t} else if (this.tokens.length > 0) {\r\n\t\t\treturn this.tokens[this.tokens.length - 1].inputStream;\r\n\t\t}\r\n\r\n\t\t// no input stream information is available\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tget sourceName(): string {\r\n\t\tif (this._sourceName) {\r\n\t\t\treturn this._sourceName;\r\n\t\t}\r\n\r\n\t\tlet inputStream: CharStream | undefined = this.inputStream;\r\n\t\tif (inputStream != null) {\r\n\t\t\treturn inputStream.sourceName;\r\n\t\t}\r\n\r\n\t\treturn \"List\";\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t// @Override\r\n\tset tokenFactory(@NotNull factory: TokenFactory) {\r\n\t\tthis._factory = factory;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\t@NotNull\r\n\tget tokenFactory(): TokenFactory {\r\n\t\treturn this._factory;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:42.1346951-07:00\r\n\r\nexport class MultiMap<K, V> extends Map<K, V[]> {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\tpublic map(key: K, value: V): void {\r\n\t\tlet elementsForKey = super.get(key);\r\n\t\tif (!elementsForKey) {\r\n\t\t\telementsForKey = [] as V[];\r\n\t\t\tsuper.set(key, elementsForKey);\r\n\t\t}\r\n\t\telementsForKey.push(value);\r\n\t}\r\n\r\n\tpublic getPairs(): Array<[K, V]> {\r\n\t\tlet pairs: Array<[K, V]> = [];\r\n\t\tthis.forEach((values: V[], key: K) => {\r\n\t\t\tvalues.forEach((v) => {\r\n\t\t\t\tpairs.push([key, v]);\r\n\t\t\t});\r\n\t\t});\r\n\t\treturn pairs;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.5898546-07:00\r\n\r\nimport { Override } from \"./Decorators\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\n\r\n/**\r\n * This class extends {@link ParserRuleContext} by allowing the value of\r\n * {@link #getRuleIndex} to be explicitly set for the context.\r\n *\r\n * {@link ParserRuleContext} does not include field storage for the rule index\r\n * since the context classes created by the code generator override the\r\n * {@link #getRuleIndex} method to return the correct value for that context.\r\n * Since the parser interpreter does not use the context classes generated for a\r\n * parser, this class (with slightly more memory overhead per node) is used to\r\n * provide equivalent functionality.\r\n */\r\nexport class InterpreterRuleContext extends ParserRuleContext {\r\n\t/**\r\n\t * This is the backing field for {@link #getRuleIndex}.\r\n\t */\r\n\tprivate _ruleIndex: number;\r\n\r\n\tconstructor(ruleIndex: number);\r\n\r\n\t/**\r\n\t * Constructs a new {@link InterpreterRuleContext} with the specified\r\n\t * parent, invoking state, and rule index.\r\n\t *\r\n\t * @param ruleIndex The rule index for the current context.\r\n\t * @param parent The parent context.\r\n\t * @param invokingStateNumber The invoking state number.\r\n\t */\r\n\tconstructor(ruleIndex: number, parent: ParserRuleContext | undefined, invokingStateNumber: number);\r\n\r\n\tconstructor(ruleIndex: number, parent?: ParserRuleContext, invokingStateNumber?: number) {\r\n\t\tif (invokingStateNumber !== undefined) {\r\n\t\t\tsuper(parent, invokingStateNumber);\r\n\t\t} else {\r\n\t\t\tsuper();\r\n\t\t}\r\n\r\n\t\tthis._ruleIndex = ruleIndex;\r\n\t}\r\n\r\n\t@Override\r\n\tget ruleIndex(): number {\r\n\t\treturn this._ruleIndex;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:53.1043451-07:00\r\n\r\nimport { ActionTransition } from \"./atn/ActionTransition\";\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNState } from \"./atn/ATNState\";\r\nimport { ATNStateType } from \"./atn/ATNStateType\";\r\nimport { AtomTransition } from \"./atn/AtomTransition\";\r\nimport { BitSet } from \"./misc/BitSet\";\r\nimport { DecisionState } from \"./atn/DecisionState\";\r\nimport { FailedPredicateException } from \"./FailedPredicateException\";\r\nimport { InputMismatchException } from \"./InputMismatchException\";\r\nimport { InterpreterRuleContext } from \"./InterpreterRuleContext\";\r\nimport { LoopEndState } from \"./atn/LoopEndState\";\r\nimport { NotNull } from \"./Decorators\";\r\nimport { Override } from \"./Decorators\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParserATNSimulator } from \"./atn/ParserATNSimulator\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { PrecedencePredicateTransition } from \"./atn/PrecedencePredicateTransition\";\r\nimport { PredicateTransition } from \"./atn/PredicateTransition\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { RuleStartState } from \"./atn/RuleStartState\";\r\nimport { RuleTransition } from \"./atn/RuleTransition\";\r\nimport { StarLoopEntryState } from \"./atn/StarLoopEntryState\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenStream } from \"./TokenStream\";\r\nimport { Transition } from \"./atn/Transition\";\r\nimport { TransitionType } from \"./atn/TransitionType\";\r\nimport { Vocabulary } from \"./Vocabulary\";\r\n\r\n/** A parser simulator that mimics what ANTLR's generated\r\n *  parser code does. A ParserATNSimulator is used to make\r\n *  predictions via adaptivePredict but this class moves a pointer through the\r\n *  ATN to simulate parsing. ParserATNSimulator just\r\n *  makes us efficient rather than having to backtrack, for example.\r\n *\r\n *  This properly creates parse trees even for left recursive rules.\r\n *\r\n *  We rely on the left recursive rule invocation and special predicate\r\n *  transitions to make left recursive rules work.\r\n *\r\n *  See TestParserInterpreter for examples.\r\n */\r\nexport class ParserInterpreter extends Parser {\r\n\tprotected _grammarFileName: string;\r\n\tprotected _atn: ATN;\r\n\t/** This identifies StarLoopEntryState's that begin the (...)*\r\n\t *  precedence loops of left recursive rules.\r\n\t */\r\n\tprotected pushRecursionContextStates: BitSet;\r\n\r\n\tprotected _ruleNames: string[];\r\n\t@NotNull\r\n\tprivate _vocabulary: Vocabulary;\r\n\r\n\t/** This stack corresponds to the _parentctx, _parentState pair of locals\r\n\t *  that would exist on call stack frames with a recursive descent parser;\r\n\t *  in the generated function for a left-recursive rule you'd see:\r\n\t *\r\n\t *  private EContext e(int _p) {\r\n\t *      ParserRuleContext _parentctx = _ctx;    // Pair.a\r\n\t *      int _parentState = state;          // Pair.b\r\n\t *      ...\r\n\t *  }\r\n\t *\r\n\t *  Those values are used to create new recursive rule invocation contexts\r\n\t *  associated with left operand of an alt like \"expr '*' expr\".\r\n\t */\r\n\tprotected readonly _parentContextStack: Array<[ParserRuleContext, number]> = [];\r\n\r\n\t/** We need a map from (decision,inputIndex)->forced alt for computing ambiguous\r\n\t *  parse trees. For now, we allow exactly one override.\r\n\t */\r\n\tprotected overrideDecision: number = -1;\r\n\tprotected overrideDecisionInputIndex: number = -1;\r\n\tprotected overrideDecisionAlt: number = -1;\r\n\tprotected overrideDecisionReached: boolean = false; // latch and only override once; error might trigger infinite loop\r\n\r\n\t/** What is the current context when we override a decisions?  This tells\r\n\t *  us what the root of the parse tree is when using override\r\n\t *  for an ambiguity/lookahead check.\r\n\t */\r\n\tprotected _overrideDecisionRoot?: InterpreterRuleContext = undefined;\r\n\r\n\tprotected _rootContext!: InterpreterRuleContext;\r\n\r\n\t/** A copy constructor that creates a new parser interpreter by reusing\r\n\t *  the fields of a previous interpreter.\r\n\t *\r\n\t *  @param old The interpreter to copy\r\n\t *\r\n\t *  @since 4.5\r\n\t */\r\n\tconstructor(/*@NotNull*/ old: ParserInterpreter);\r\n\tconstructor(\r\n\t\tgrammarFileName: string, /*@NotNull*/ vocabulary: Vocabulary,\r\n\t\truleNames: string[], atn: ATN, input: TokenStream);\r\n\tconstructor(\r\n\t\tgrammarFileName: ParserInterpreter | string, @NotNull vocabulary?: Vocabulary,\r\n\t\truleNames?: string[], atn?: ATN, input?: TokenStream) {\r\n\t\tsuper(grammarFileName instanceof ParserInterpreter ? grammarFileName.inputStream : input!);\r\n\t\tif (grammarFileName instanceof ParserInterpreter) {\r\n\t\t\tlet old: ParserInterpreter = grammarFileName;\r\n\t\t\tthis._grammarFileName = old._grammarFileName;\r\n\t\t\tthis._atn = old._atn;\r\n\t\t\tthis.pushRecursionContextStates = old.pushRecursionContextStates;\r\n\t\t\tthis._ruleNames = old._ruleNames;\r\n\t\t\tthis._vocabulary = old._vocabulary;\r\n\t\t\tthis.interpreter = new ParserATNSimulator(this._atn, this);\r\n\t\t} else {\r\n\t\t\t// The second constructor requires non-null arguments\r\n\t\t\tvocabulary = vocabulary!;\r\n\t\t\truleNames = ruleNames!;\r\n\t\t\tatn = atn!;\r\n\r\n\t\t\tthis._grammarFileName = grammarFileName;\r\n\t\t\tthis._atn = atn;\r\n\t\t\tthis._ruleNames = ruleNames.slice(0);\r\n\t\t\tthis._vocabulary = vocabulary;\r\n\r\n\t\t\t// identify the ATN states where pushNewRecursionContext() must be called\r\n\t\t\tthis.pushRecursionContextStates = new BitSet(atn.states.length);\r\n\t\t\tfor (let state of atn.states) {\r\n\t\t\t\tif (!(state instanceof StarLoopEntryState)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (state.precedenceRuleDecision) {\r\n\t\t\t\t\tthis.pushRecursionContextStates.set(state.stateNumber);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// get atn simulator that knows how to do predictions\r\n\t\t\tthis.interpreter = new ParserATNSimulator(atn, this);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reset(resetInput?: boolean): void {\r\n\t\tif (resetInput === undefined) {\r\n\t\t\tsuper.reset();\r\n\t\t} else {\r\n\t\t\tsuper.reset(resetInput);\r\n\t\t}\r\n\r\n\t\tthis.overrideDecisionReached = false;\r\n\t\tthis._overrideDecisionRoot = undefined;\r\n\t}\r\n\r\n\t@Override\r\n\tget atn(): ATN {\r\n\t\treturn this._atn;\r\n\t}\r\n\r\n\t@Override\r\n\tget vocabulary(): Vocabulary {\r\n\t\treturn this._vocabulary;\r\n\t}\r\n\r\n\t@Override\r\n\tget ruleNames(): string[] {\r\n\t\treturn this._ruleNames;\r\n\t}\r\n\r\n\t@Override\r\n\tget grammarFileName(): string {\r\n\t\treturn this._grammarFileName;\r\n\t}\r\n\r\n\t/** Begin parsing at startRuleIndex */\r\n\tpublic parse(startRuleIndex: number): ParserRuleContext {\r\n\t\tlet startRuleStartState: RuleStartState = this._atn.ruleToStartState[startRuleIndex];\r\n\r\n\t\tthis._rootContext = this.createInterpreterRuleContext(undefined, ATNState.INVALID_STATE_NUMBER, startRuleIndex);\r\n\t\tif (startRuleStartState.isPrecedenceRule) {\r\n\t\t\tthis.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);\r\n\t\t}\r\n\r\n\t\twhile (true) {\r\n\t\t\tlet p: ATNState = this.atnState;\r\n\t\t\tswitch (p.stateType) {\r\n\t\t\tcase ATNStateType.RULE_STOP:\r\n\t\t\t\t// pop; return from rule\r\n\t\t\t\tif (this._ctx.isEmpty) {\r\n\t\t\t\t\tif (startRuleStartState.isPrecedenceRule) {\r\n\t\t\t\t\t\tlet result: ParserRuleContext = this._ctx;\r\n\t\t\t\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop() !;\r\n\t\t\t\t\t\tthis.unrollRecursionContexts(parentContext[0]);\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.exitRule();\r\n\t\t\t\t\t\treturn this._rootContext;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.visitRuleStopState(p);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\ttry {\r\n\t\t\t\t\tthis.visitState(p);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tif (e instanceof RecognitionException) {\r\n\t\t\t\t\t\tthis.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\r\n\t\t\t\t\t\tthis.context.exception = e;\r\n\t\t\t\t\t\tthis.errorHandler.reportError(this, e);\r\n\t\t\t\t\t\tthis.recover(e);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic enterRecursionRule(localctx: ParserRuleContext, state: number, ruleIndex: number, precedence: number): void {\r\n\t\tthis._parentContextStack.push([this._ctx, localctx.invokingState]);\r\n\t\tsuper.enterRecursionRule(localctx, state, ruleIndex, precedence);\r\n\t}\r\n\r\n\tprotected get atnState(): ATNState {\r\n\t\treturn this._atn.states[this.state];\r\n\t}\r\n\r\n\tprotected visitState(p: ATNState): void {\r\n\t\tlet predictedAlt: number = 1;\r\n\t\tif (p.numberOfTransitions > 1) {\r\n\t\t\tpredictedAlt = this.visitDecisionState(p as DecisionState);\r\n\t\t}\r\n\r\n\t\tlet transition: Transition = p.transition(predictedAlt - 1);\r\n\t\tswitch (transition.serializationType) {\r\n\t\tcase TransitionType.EPSILON:\r\n\t\t\tif (this.pushRecursionContextStates.get(p.stateNumber) &&\r\n\t\t\t\t!(transition.target instanceof LoopEndState)) {\r\n\t\t\t\t// We are at the start of a left recursive rule's (...)* loop\r\n\t\t\t\t// and we're not taking the exit branch of loop.\r\n\t\t\t\tlet parentContext = this._parentContextStack[this._parentContextStack.length - 1];\r\n\t\t\t\tlet localctx: InterpreterRuleContext =\r\n\t\t\t\t\tthis.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);\r\n\t\t\t\tthis.pushNewRecursionContext(localctx,\r\n\t\t\t\t\tthis._atn.ruleToStartState[p.ruleIndex].stateNumber,\r\n\t\t\t\t\tthis._ctx.ruleIndex);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.ATOM:\r\n\t\t\tthis.match((transition as AtomTransition)._label);\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.RANGE:\r\n\t\tcase TransitionType.SET:\r\n\t\tcase TransitionType.NOT_SET:\r\n\t\t\tif (!transition.matches(this._input.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {\r\n\t\t\t\tthis.recoverInline();\r\n\t\t\t}\r\n\t\t\tthis.matchWildcard();\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.WILDCARD:\r\n\t\t\tthis.matchWildcard();\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.RULE:\r\n\t\t\tlet ruleStartState: RuleStartState = transition.target as RuleStartState;\r\n\t\t\tlet ruleIndex: number = ruleStartState.ruleIndex;\r\n\t\t\tlet newctx: InterpreterRuleContext = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);\r\n\t\t\tif (ruleStartState.isPrecedenceRule) {\r\n\t\t\t\tthis.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, (transition as RuleTransition).precedence);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.enterRule(newctx, transition.target.stateNumber, ruleIndex);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.PREDICATE:\r\n\t\t\tlet predicateTransition: PredicateTransition = transition as PredicateTransition;\r\n\t\t\tif (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\r\n\t\t\t\tthrow new FailedPredicateException(this);\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.ACTION:\r\n\t\t\tlet actionTransition: ActionTransition = transition as ActionTransition;\r\n\t\t\tthis.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.PRECEDENCE:\r\n\t\t\tif (!this.precpred(this._ctx, (transition as PrecedencePredicateTransition).precedence)) {\r\n\t\t\t\tlet precedence = (transition as PrecedencePredicateTransition).precedence;\r\n\t\t\t\tthrow new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\r\n\t\t}\r\n\r\n\t\tthis.state = transition.target.stateNumber;\r\n\t}\r\n\r\n\t/** Method visitDecisionState() is called when the interpreter reaches\r\n\t *  a decision state (instance of DecisionState). It gives an opportunity\r\n\t *  for subclasses to track interesting things.\r\n\t */\r\n\tprotected visitDecisionState(p: DecisionState): number {\r\n\t\tlet predictedAlt: number;\r\n\t\tthis.errorHandler.sync(this);\r\n\t\tlet decision: number = p.decision;\r\n\t\tif (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {\r\n\t\t\tpredictedAlt = this.overrideDecisionAlt;\r\n\t\t\tthis.overrideDecisionReached = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpredictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);\r\n\t\t}\r\n\t\treturn predictedAlt;\r\n\t}\r\n\r\n\t/** Provide simple \"factory\" for InterpreterRuleContext's.\r\n\t *  @since 4.5.1\r\n\t */\r\n\tprotected createInterpreterRuleContext(\r\n\t\tparent: ParserRuleContext | undefined,\r\n\t\tinvokingStateNumber: number,\r\n\t\truleIndex: number): InterpreterRuleContext {\r\n\t\treturn new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\r\n\t}\r\n\r\n\tprotected visitRuleStopState(p: ATNState): void {\r\n\t\tlet ruleStartState: RuleStartState = this._atn.ruleToStartState[p.ruleIndex];\r\n\t\tif (ruleStartState.isPrecedenceRule) {\r\n\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop()!;\r\n\t\t\tthis.unrollRecursionContexts(parentContext[0]);\r\n\t\t\tthis.state = parentContext[1];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.exitRule();\r\n\t\t}\r\n\r\n\t\tlet ruleTransition: RuleTransition = this._atn.states[this.state].transition(0) as RuleTransition;\r\n\t\tthis.state = ruleTransition.followState.stateNumber;\r\n\t}\r\n\r\n\t/** Override this parser interpreters normal decision-making process\r\n\t *  at a particular decision and input token index. Instead of\r\n\t *  allowing the adaptive prediction mechanism to choose the\r\n\t *  first alternative within a block that leads to a successful parse,\r\n\t *  force it to take the alternative, 1..n for n alternatives.\r\n\t *\r\n\t *  As an implementation limitation right now, you can only specify one\r\n\t *  override. This is sufficient to allow construction of different\r\n\t *  parse trees for ambiguous input. It means re-parsing the entire input\r\n\t *  in general because you're never sure where an ambiguous sequence would\r\n\t *  live in the various parse trees. For example, in one interpretation,\r\n\t *  an ambiguous input sequence would be matched completely in expression\r\n\t *  but in another it could match all the way back to the root.\r\n\t *\r\n\t *  s : e '!'? ;\r\n\t *  e : ID\r\n\t *    | ID '!'\r\n\t *    ;\r\n\t *\r\n\t *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first\r\n\t *  case, the ambiguous sequence is fully contained only by the root.\r\n\t *  In the second case, the ambiguous sequences fully contained within just\r\n\t *  e, as in: (e ID !).\r\n\t *\r\n\t *  Rather than trying to optimize this and make\r\n\t *  some intelligent decisions for optimization purposes, I settled on\r\n\t *  just re-parsing the whole input and then using\r\n\t *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal\r\n\t *  subtree that contains the ambiguous sequence. I originally tried to\r\n\t *  record the call stack at the point the parser detected and ambiguity but\r\n\t *  left recursive rules create a parse tree stack that does not reflect\r\n\t *  the actual call stack. That impedance mismatch was enough to make\r\n\t *  it it challenging to restart the parser at a deeply nested rule\r\n\t *  invocation.\r\n\t *\r\n\t *  Only parser interpreters can override decisions so as to avoid inserting\r\n\t *  override checking code in the critical ALL(*) prediction execution path.\r\n\t *\r\n\t *  @since 4.5\r\n\t */\r\n\tpublic addDecisionOverride(decision: number, tokenIndex: number, forcedAlt: number): void {\r\n\t\tthis.overrideDecision = decision;\r\n\t\tthis.overrideDecisionInputIndex = tokenIndex;\r\n\t\tthis.overrideDecisionAlt = forcedAlt;\r\n\t}\r\n\r\n\tget overrideDecisionRoot(): InterpreterRuleContext | undefined {\r\n\t\treturn this._overrideDecisionRoot;\r\n\t}\r\n\r\n\t/** Rely on the error handler for this parser but, if no tokens are consumed\r\n\t *  to recover, add an error node. Otherwise, nothing is seen in the parse\r\n\t *  tree.\r\n\t */\r\n\tprotected recover(e: RecognitionException): void {\r\n\t\tlet i: number = this._input.index;\r\n\t\tthis.errorHandler.recover(this, e);\r\n\t\tif (this._input.index === i) {\r\n\t\t\t// no input consumed, better add an error node\r\n\t\t\tlet tok: Token | undefined = e.getOffendingToken();\r\n\t\t\tif (!tok) {\r\n\t\t\t\tthrow new Error(\"Expected exception to have an offending token\");\r\n\t\t\t}\r\n\r\n\t\t\tlet source = tok.tokenSource;\r\n\t\t\tlet stream = source !== undefined ? source.inputStream : undefined;\r\n\t\t\tlet sourcePair = { source, stream };\r\n\r\n\t\t\tif (e instanceof InputMismatchException) {\r\n\t\t\t\tlet expectedTokens = e.expectedTokens;\r\n\t\t\t\tif (expectedTokens === undefined) {\r\n\t\t\t\t\tthrow new Error(\"Expected the exception to provide expected tokens\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet expectedTokenType: number = Token.INVALID_TYPE;\r\n\t\t\t\tif (!expectedTokens.isNil) {\r\n\t\t\t\t\t// get any element\r\n\t\t\t\t\texpectedTokenType = expectedTokens.minElement;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet errToken: Token =\r\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\r\n\t\t\t\t\t\texpectedTokenType, tok.text,\r\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\r\n\t\t\t\t\t\t-1, -1, // invalid start/stop\r\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\r\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\r\n\t\t\t}\r\n\t\t\telse { // NoViableAlt\r\n\t\t\t\tlet source = tok.tokenSource;\r\n\t\t\t\tlet errToken: Token =\r\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\r\n\t\t\t\t\t\tToken.INVALID_TYPE, tok.text,\r\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\r\n\t\t\t\t\t\t-1, -1, // invalid start/stop\r\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\r\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected recoverInline(): Token {\r\n\t\treturn this._errHandler.recoverInline(this);\r\n\t}\r\n\r\n\t/** Return the root of the parse, which can be useful if the parser\r\n\t *  bails out. You still can access the top node. Note that,\r\n\t *  because of the way left recursive rules add children, it's possible\r\n\t *  that the root will not have any children if the start rule immediately\r\n\t *  called and left recursive rule that fails.\r\n\t *\r\n\t * @since 4.5.1\r\n\t */\r\n\tget rootContext(): InterpreterRuleContext {\r\n\t\treturn this._rootContext;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { MultiMap } from \"../../misc/MultiMap\";\r\nimport { NotNull, Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { ParseTreePattern } from \"./ParseTreePattern\";\r\n\r\n/**\r\n * Represents the result of matching a {@link ParseTree} against a tree pattern.\r\n */\r\nexport class ParseTreeMatch {\r\n\t/**\r\n\t * This is the backing field for `tree`.\r\n\t */\r\n\tprivate _tree: ParseTree;\r\n\r\n\t/**\r\n\t * This is the backing field for `pattern`.\r\n\t */\r\n\tprivate _pattern: ParseTreePattern;\r\n\r\n\t/**\r\n\t * This is the backing field for `labels`.\r\n\t */\r\n\tprivate _labels: MultiMap<string, ParseTree>;\r\n\r\n\t/**\r\n\t * This is the backing field for `mismatchedNode`.\r\n\t */\r\n\tprivate _mismatchedNode?: ParseTree;\r\n\r\n\t/**\r\n\t * Constructs a new instance of {@link ParseTreeMatch} from the specified\r\n\t * parse tree and pattern.\r\n\t *\r\n\t * @param tree The parse tree to match against the pattern.\r\n\t * @param pattern The parse tree pattern.\r\n\t * @param labels A mapping from label names to collections of\r\n\t * {@link ParseTree} objects located by the tree pattern matching process.\r\n\t * @param mismatchedNode The first node which failed to match the tree\r\n\t * pattern during the matching process.\r\n\t *\r\n\t * @throws {@link Error} if `tree` is not defined\r\n\t * @throws {@link Error} if `pattern` is not defined\r\n\t * @throws {@link Error} if `labels` is not defined\r\n\t */\r\n\tconstructor(\r\n\t\t@NotNull tree: ParseTree,\r\n\t\t@NotNull pattern: ParseTreePattern,\r\n\t\t@NotNull labels: MultiMap<string, ParseTree>,\r\n\t\tmismatchedNode: ParseTree | undefined) {\r\n\t\tif (!tree) {\r\n\t\t\tthrow new Error(\"tree cannot be null\");\r\n\t\t}\r\n\r\n\t\tif (!pattern) {\r\n\t\t\tthrow new Error(\"pattern cannot be null\");\r\n\t\t}\r\n\r\n\t\tif (!labels) {\r\n\t\t\tthrow new Error(\"labels cannot be null\");\r\n\t\t}\r\n\r\n\t\tthis._tree = tree;\r\n\t\tthis._pattern = pattern;\r\n\t\tthis._labels = labels;\r\n\t\tthis._mismatchedNode = mismatchedNode;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the last node associated with a specific `label`.\r\n\t *\r\n\t * For example, for pattern `<id:ID>`, `get(\"id\")` returns the\r\n\t * node matched for that `ID`. If more than one node\r\n\t * matched the specified label, only the last is returned. If there is\r\n\t * no node associated with the label, this returns `undefined`.\r\n\t *\r\n\t * Pattern tags like `<ID>` and `<expr>` without labels are\r\n\t * considered to be labeled with `ID` and `expr`, respectively.\r\n\t *\r\n\t * @param label The label to check.\r\n\t *\r\n\t * @returns The last {@link ParseTree} to match a tag with the specified\r\n\t * label, or `undefined` if no parse tree matched a tag with the label.\r\n\t */\r\n\tpublic get(label: string): ParseTree | undefined {\r\n\t\tlet parseTrees = this._labels.get(label);\r\n\t\tif (!parseTrees || parseTrees.length === 0) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn parseTrees[parseTrees.length - 1]; // return last if multiple\r\n\t}\r\n\r\n\t/**\r\n\t * Return all nodes matching a rule or token tag with the specified label.\r\n\t *\r\n\t * If the `label` is the name of a parser rule or token in the\r\n\t * grammar, the resulting list will contain both the parse trees matching\r\n\t * rule or tags explicitly labeled with the label and the complete set of\r\n\t * parse trees matching the labeled and unlabeled tags in the pattern for\r\n\t * the parser rule or token. For example, if `label` is `\"foo\"`,\r\n\t * the result will contain *all* of the following.\r\n\t *\r\n\t * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and\r\n\t *   `<foo:AnyTokenName>`.\r\n\t * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.\r\n\t * * Parse tree nodes matching tags of the form `<foo>`.\r\n\t *\r\n\t * @param label The label.\r\n\t *\r\n\t * @returns A collection of all {@link ParseTree} nodes matching tags with\r\n\t * the specified `label`. If no nodes matched the label, an empty list\r\n\t * is returned.\r\n\t */\r\n\t@NotNull\r\n\tpublic getAll(@NotNull label: string): ParseTree[] {\r\n\t\tconst nodes = this._labels.get(label);\r\n\t\tif (!nodes) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}\r\n\r\n\t/**\r\n\t * Return a mapping from label &rarr; [list of nodes].\r\n\t *\r\n\t * The map includes special entries corresponding to the names of rules and\r\n\t * tokens referenced in tags in the original pattern. For additional\r\n\t * information, see the description of {@link #getAll(String)}.\r\n\t *\r\n\t * @returns A mapping from labels to parse tree nodes. If the parse tree\r\n\t * pattern did not contain any rule or token tags, this map will be empty.\r\n\t */\r\n\t@NotNull\r\n\tget labels(): MultiMap<string, ParseTree> {\r\n\t\treturn this._labels;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the node at which we first detected a mismatch.\r\n\t *\r\n\t * @returns the node at which we first detected a mismatch, or `undefined`\r\n\t * if the match was successful.\r\n\t */\r\n\tget mismatchedNode(): ParseTree | undefined {\r\n\t\treturn this._mismatchedNode;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets a value indicating whether the match operation succeeded.\r\n\t *\r\n\t * @returns `true` if the match operation succeeded; otherwise,\r\n\t * `false`.\r\n\t */\r\n\tget succeeded(): boolean {\r\n\t\treturn !this._mismatchedNode;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the tree pattern we are matching against.\r\n\t *\r\n\t * @returns The tree pattern we are matching against.\r\n\t */\r\n\t@NotNull\r\n\tget pattern(): ParseTreePattern {\r\n\t\treturn this._pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the parse tree we are trying to match to a pattern.\r\n\t *\r\n\t * @returns The {@link ParseTree} we are trying to match to a pattern.\r\n\t */\r\n\t@NotNull\r\n\tget tree(): ParseTree {\r\n\t\treturn this._tree;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn `Match ${\r\n\t\t\tthis.succeeded ? \"succeeded\" : \"failed\"}; found ${\r\n\t\t\tthis.labels.size} labels`;\r\n\t}\r\n}\r\n", "// Generated from XPathLexer.g4 by ANTLR 4.9.0-SNAPSHOT\r\n\r\n\r\nimport { ATN } from \"../../atn/ATN\";\r\nimport { ATNDeserializer } from \"../../atn/ATNDeserializer\";\r\nimport { CharStream } from \"../../CharStream\";\r\nimport { Lexer } from \"../../Lexer\";\r\nimport { LexerATNSimulator } from \"../../atn/LexerATNSimulator\";\r\nimport { NotNull } from \"../../Decorators\";\r\nimport { Override } from \"../../Decorators\";\r\nimport { RuleContext } from \"../../RuleContext\";\r\nimport { Vocabulary } from \"../../Vocabulary\";\r\nimport { VocabularyImpl } from \"../../VocabularyImpl\";\r\n\r\nimport * as Utils from \"../../misc/Utils\";\r\n\r\n\r\nexport class XPathLexer extends Lexer {\r\n\tpublic static readonly TOKEN_REF = 1;\r\n\tpublic static readonly RULE_REF = 2;\r\n\tpublic static readonly ANYWHERE = 3;\r\n\tpublic static readonly ROOT = 4;\r\n\tpublic static readonly WILDCARD = 5;\r\n\tpublic static readonly BANG = 6;\r\n\tpublic static readonly ID = 7;\r\n\tpublic static readonly STRING = 8;\r\n\r\n\t// tslint:disable:no-trailing-whitespace\r\n\tpublic static readonly channelNames: string[] = [\r\n\t\t\"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\",\r\n\t];\r\n\r\n\t// tslint:disable:no-trailing-whitespace\r\n\tpublic static readonly modeNames: string[] = [\r\n\t\t\"DEFAULT_MODE\",\r\n\t];\r\n\r\n\tpublic static readonly ruleNames: string[] = [\r\n\t\t\"ANYWHERE\", \"ROOT\", \"WILDCARD\", \"BANG\", \"ID\", \"NameChar\", \"NameStartChar\", \r\n\t\t\"STRING\",\r\n\t];\r\n\r\n\tprivate static readonly _LITERAL_NAMES: Array<string | undefined> = [\r\n\t\tundefined, undefined, undefined, \"'//'\", \"'/'\", \"'*'\", \"'!'\",\r\n\t];\r\n\tprivate static readonly _SYMBOLIC_NAMES: Array<string | undefined> = [\r\n\t\tundefined, \"TOKEN_REF\", \"RULE_REF\", \"ANYWHERE\", \"ROOT\", \"WILDCARD\", \"BANG\", \r\n\t\t\"ID\", \"STRING\",\r\n\t];\r\n\tpublic static readonly VOCABULARY: Vocabulary = new VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);\r\n\r\n\t// @Override\r\n\t// @NotNull\r\n\tpublic get vocabulary(): Vocabulary {\r\n\t\treturn XPathLexer.VOCABULARY;\r\n\t}\r\n\t// tslint:enable:no-trailing-whitespace\r\n\r\n\r\n\tconstructor(input: CharStream) {\r\n\t\tsuper(input);\r\n\t\tthis._interp = new LexerATNSimulator(XPathLexer._ATN, this);\r\n\t}\r\n\r\n\t// @Override\r\n\tpublic get grammarFileName(): string { return \"XPathLexer.g4\"; }\r\n\r\n\t// @Override\r\n\tpublic get ruleNames(): string[] { return XPathLexer.ruleNames; }\r\n\r\n\t// @Override\r\n\tpublic get serializedATN(): string { return XPathLexer._serializedATN; }\r\n\r\n\t// @Override\r\n\tpublic get channelNames(): string[] { return XPathLexer.channelNames; }\r\n\r\n\t// @Override\r\n\tpublic get modeNames(): string[] { return XPathLexer.modeNames; }\r\n\r\n\t// @Override\r\n\tpublic action(_localctx: RuleContext, ruleIndex: number, actionIndex: number): void {\r\n\t\tswitch (ruleIndex) {\r\n\t\tcase 4:\r\n\t\t\tthis.ID_action(_localctx, actionIndex);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tprivate ID_action(_localctx: RuleContext, actionIndex: number): void {\r\n\t\tswitch (actionIndex) {\r\n\t\tcase 0:\r\n\r\n\t\t\tlet text = this.text;\r\n\t\t\tif (text.charAt(0) === text.charAt(0).toUpperCase()) {\r\n\t\t\t\tthis.type = XPathLexer.TOKEN_REF;\r\n\t\t\t} else {\r\n\t\t\t\tthis.type = XPathLexer.RULE_REF;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tprivate static readonly _serializedATNSegments: number = 2;\r\n\tprivate static readonly _serializedATNSegment0: string =\r\n\t\t\"\\x03\\uC91D\\uCABA\\u058D\\uAFBA\\u4F53\\u0607\\uEA8B\\uC241\\x02\\n2\\b\\x01\\x04\" +\r\n\t\t\"\\x02\\t\\x02\\x04\\x03\\t\\x03\\x04\\x04\\t\\x04\\x04\\x05\\t\\x05\\x04\\x06\\t\\x06\\x04\" +\r\n\t\t\"\\x07\\t\\x07\\x04\\b\\t\\b\\x04\\t\\t\\t\\x03\\x02\\x03\\x02\\x03\\x02\\x03\\x03\\x03\\x03\" +\r\n\t\t\"\\x03\\x04\\x03\\x04\\x03\\x05\\x03\\x05\\x03\\x06\\x03\\x06\\x07\\x06\\x1F\\n\\x06\\f\\x06\" +\r\n\t\t\"\\x0E\\x06\\\"\\v\\x06\\x03\\x06\\x03\\x06\\x03\\x07\\x03\\x07\\x03\\b\\x03\\b\\x03\\t\\x03\" +\r\n\t\t\"\\t\\x07\\t,\\n\\t\\f\\t\\x0E\\t/\\v\\t\\x03\\t\\x03\\t\\x03-\\x02\\x02\\n\\x03\\x02\\x05\\x05\" +\r\n\t\t\"\\x02\\x06\\x07\\x02\\x07\\t\\x02\\b\\v\\x02\\t\\r\\x02\\x02\\x0F\\x02\\x02\\x11\\x02\\n\\x03\" +\r\n\t\t\"\\x02\\x02\\x04\\u02B6\\x02\\x02\\x02\\n\\x02\\x10\\x02\\x1D\\x022\\x02;\\x02C\\x02\\\\\" +\r\n\t\t\"\\x02a\\x02a\\x02c\\x02|\\x02\\x81\\x02\\xA1\\x02\\xAC\\x02\\xAC\\x02\\xAF\\x02\\xAF\\x02\" +\r\n\t\t\"\\xB7\\x02\\xB7\\x02\\xBC\\x02\\xBC\\x02\\xC2\\x02\\xD8\\x02\\xDA\\x02\\xF8\\x02\\xFA\\x02\" +\r\n\t\t\"\\u02C3\\x02\\u02C8\\x02\\u02D3\\x02\\u02E2\\x02\\u02E6\\x02\\u02EE\\x02\\u02EE\\x02\" +\r\n\t\t\"\\u02F0\\x02\\u02F0\\x02\\u0302\\x02\\u0376\\x02\\u0378\\x02\\u0379\\x02\\u037C\\x02\" +\r\n\t\t\"\\u037F\\x02\\u0381\\x02\\u0381\\x02\\u0388\\x02\\u0388\\x02\\u038A\\x02\\u038C\\x02\" +\r\n\t\t\"\\u038E\\x02\\u038E\\x02\\u0390\\x02\\u03A3\\x02\\u03A5\\x02\\u03F7\\x02\\u03F9\\x02\" +\r\n\t\t\"\\u0483\\x02\\u0485\\x02\\u0489\\x02\\u048C\\x02\\u0531\\x02\\u0533\\x02\\u0558\\x02\" +\r\n\t\t\"\\u055B\\x02\\u055B\\x02\\u0563\\x02\\u0589\\x02\\u0593\\x02\\u05BF\\x02\\u05C1\\x02\" +\r\n\t\t\"\\u05C1\\x02\\u05C3\\x02\\u05C4\\x02\\u05C6\\x02\\u05C7\\x02\\u05C9\\x02\\u05C9\\x02\" +\r\n\t\t\"\\u05D2\\x02\\u05EC\\x02\\u05F2\\x02\\u05F4\\x02\\u0602\\x02\\u0607\\x02\\u0612\\x02\" +\r\n\t\t\"\\u061C\\x02\\u061E\\x02\\u061E\\x02\\u0622\\x02\\u066B\\x02\\u0670\\x02\\u06D5\\x02\" +\r\n\t\t\"\\u06D7\\x02\\u06DF\\x02\\u06E1\\x02\\u06EA\\x02\\u06EC\\x02\\u06FE\\x02\\u0701\\x02\" +\r\n\t\t\"\\u0701\\x02\\u0711\\x02\\u074C\\x02\\u074F\\x02\\u07B3\\x02\\u07C2\\x02\\u07F7\\x02\" +\r\n\t\t\"\\u07FC\\x02\\u07FC\\x02\\u0802\\x02\\u082F\\x02\\u0842\\x02\\u085D\\x02\\u08A2\\x02\" +\r\n\t\t\"\\u08B6\\x02\\u08B8\\x02\\u08BF\\x02\\u08D6\\x02\\u0965\\x02\\u0968\\x02\\u0971\\x02\" +\r\n\t\t\"\\u0973\\x02\\u0985\\x02\\u0987\\x02\\u098E\\x02\\u0991\\x02\\u0992\\x02\\u0995\\x02\" +\r\n\t\t\"\\u09AA\\x02\\u09AC\\x02\\u09B2\\x02\\u09B4\\x02\\u09B4\\x02\\u09B8\\x02\\u09BB\\x02\" +\r\n\t\t\"\\u09BE\\x02\\u09C6\\x02\\u09C9\\x02\\u09CA\\x02\\u09CD\\x02\\u09D0\\x02\\u09D9\\x02\" +\r\n\t\t\"\\u09D9\\x02\\u09DE\\x02\\u09DF\\x02\\u09E1\\x02\\u09E5\\x02\\u09E8\\x02\\u09F3\\x02\" +\r\n\t\t\"\\u0A03\\x02\\u0A05\\x02\\u0A07\\x02\\u0A0C\\x02\\u0A11\\x02\\u0A12\\x02\\u0A15\\x02\" +\r\n\t\t\"\\u0A2A\\x02\\u0A2C\\x02\\u0A32\\x02\\u0A34\\x02\\u0A35\\x02\\u0A37\\x02\\u0A38\\x02\" +\r\n\t\t\"\\u0A3A\\x02\\u0A3B\\x02\\u0A3E\\x02\\u0A3E\\x02\\u0A40\\x02\\u0A44\\x02\\u0A49\\x02\" +\r\n\t\t\"\\u0A4A\\x02\\u0A4D\\x02\\u0A4F\\x02\\u0A53\\x02\\u0A53\\x02\\u0A5B\\x02\\u0A5E\\x02\" +\r\n\t\t\"\\u0A60\\x02\\u0A60\\x02\\u0A68\\x02\\u0A77\\x02\\u0A83\\x02\\u0A85\\x02\\u0A87\\x02\" +\r\n\t\t\"\\u0A8F\\x02\\u0A91\\x02\\u0A93\\x02\\u0A95\\x02\\u0AAA\\x02\\u0AAC\\x02\\u0AB2\\x02\" +\r\n\t\t\"\\u0AB4\\x02\\u0AB5\\x02\\u0AB7\\x02\\u0ABB\\x02\\u0ABE\\x02\\u0AC7\\x02\\u0AC9\\x02\" +\r\n\t\t\"\\u0ACB\\x02\\u0ACD\\x02\\u0ACF\\x02\\u0AD2\\x02\\u0AD2\\x02\\u0AE2\\x02\\u0AE5\\x02\" +\r\n\t\t\"\\u0AE8\\x02\\u0AF1\\x02\\u0AFB\\x02\\u0AFB\\x02\\u0B03\\x02\\u0B05\\x02\\u0B07\\x02\" +\r\n\t\t\"\\u0B0E\\x02\\u0B11\\x02\\u0B12\\x02\\u0B15\\x02\\u0B2A\\x02\\u0B2C\\x02\\u0B32\\x02\" +\r\n\t\t\"\\u0B34\\x02\\u0B35\\x02\\u0B37\\x02\\u0B3B\\x02\\u0B3E\\x02\\u0B46\\x02\\u0B49\\x02\" +\r\n\t\t\"\\u0B4A\\x02\\u0B4D\\x02\\u0B4F\\x02\\u0B58\\x02\\u0B59\\x02\\u0B5E\\x02\\u0B5F\\x02\" +\r\n\t\t\"\\u0B61\\x02\\u0B65\\x02\\u0B68\\x02\\u0B71\\x02\\u0B73\\x02\\u0B73\\x02\\u0B84\\x02\" +\r\n\t\t\"\\u0B85\\x02\\u0B87\\x02\\u0B8C\\x02\\u0B90\\x02\\u0B92\\x02\\u0B94\\x02\\u0B97\\x02\" +\r\n\t\t\"\\u0B9B\\x02\\u0B9C\\x02\\u0B9E\\x02\\u0B9E\\x02\\u0BA0\\x02\\u0BA1\\x02\\u0BA5\\x02\" +\r\n\t\t\"\\u0BA6\\x02\\u0BAA\\x02\\u0BAC\\x02\\u0BB0\\x02\\u0BBB\\x02\\u0BC0\\x02\\u0BC4\\x02\" +\r\n\t\t\"\\u0BC8\\x02\\u0BCA\\x02\\u0BCC\\x02\\u0BCF\\x02\\u0BD2\\x02\\u0BD2\\x02\\u0BD9\\x02\" +\r\n\t\t\"\\u0BD9\\x02\\u0BE8\\x02\\u0BF1\\x02\\u0C02\\x02\\u0C05\\x02\\u0C07\\x02\\u0C0E\\x02\" +\r\n\t\t\"\\u0C10\\x02\\u0C12\\x02\\u0C14\\x02\\u0C2A\\x02\\u0C2C\\x02\\u0C3B\\x02\\u0C3F\\x02\" +\r\n\t\t\"\\u0C46\\x02\\u0C48\\x02\\u0C4A\\x02\\u0C4C\\x02\\u0C4F\\x02\\u0C57\\x02\\u0C58\\x02\" +\r\n\t\t\"\\u0C5A\\x02\\u0C5C\\x02\\u0C62\\x02\\u0C65\\x02\\u0C68\\x02\\u0C71\\x02\\u0C82\\x02\" +\r\n\t\t\"\\u0C85\\x02\\u0C87\\x02\\u0C8E\\x02\\u0C90\\x02\\u0C92\\x02\\u0C94\\x02\\u0CAA\\x02\" +\r\n\t\t\"\\u0CAC\\x02\\u0CB5\\x02\\u0CB7\\x02\\u0CBB\\x02\\u0CBE\\x02\\u0CC6\\x02\\u0CC8\\x02\" +\r\n\t\t\"\\u0CCA\\x02\\u0CCC\\x02\\u0CCF\\x02\\u0CD7\\x02\\u0CD8\\x02\\u0CE0\\x02\\u0CE0\\x02\" +\r\n\t\t\"\\u0CE2\\x02\\u0CE5\\x02\\u0CE8\\x02\\u0CF1\\x02\\u0CF3\\x02\\u0CF4\\x02\\u0D03\\x02\" +\r\n\t\t\"\\u0D05\\x02\\u0D07\\x02\\u0D0E\\x02\\u0D10\\x02\\u0D12\\x02\\u0D14\\x02\\u0D3C\\x02\" +\r\n\t\t\"\\u0D3F\\x02\\u0D46\\x02\\u0D48\\x02\\u0D4A\\x02\\u0D4C\\x02\\u0D50\\x02\\u0D56\\x02\" +\r\n\t\t\"\\u0D59\\x02\\u0D61\\x02\\u0D65\\x02\\u0D68\\x02\\u0D71\\x02\\u0D7C\\x02\\u0D81\\x02\" +\r\n\t\t\"\\u0D84\\x02\\u0D85\\x02\\u0D87\\x02\\u0D98\\x02\\u0D9C\\x02\\u0DB3\\x02\\u0DB5\\x02\" +\r\n\t\t\"\\u0DBD\\x02\\u0DBF\\x02\\u0DBF\\x02\\u0DC2\\x02\\u0DC8\\x02\\u0DCC\\x02\\u0DCC\\x02\" +\r\n\t\t\"\\u0DD1\\x02\\u0DD6\\x02\\u0DD8\\x02\\u0DD8\\x02\\u0DDA\\x02\\u0DE1\\x02\\u0DE8\\x02\" +\r\n\t\t\"\\u0DF1\\x02\\u0DF4\\x02\\u0DF5\\x02\\u0E03\\x02\\u0E3C\\x02\\u0E42\\x02\\u0E50\\x02\" +\r\n\t\t\"\\u0E52\\x02\\u0E5B\\x02\\u0E83\\x02\\u0E84\\x02\\u0E86\\x02\\u0E86\\x02\\u0E89\\x02\" +\r\n\t\t\"\\u0E8A\\x02\\u0E8C\\x02\\u0E8C\\x02\\u0E8F\\x02\\u0E8F\\x02\\u0E96\\x02\\u0E99\\x02\" +\r\n\t\t\"\\u0E9B\\x02\\u0EA1\\x02\\u0EA3\\x02\\u0EA5\\x02\\u0EA7\\x02\\u0EA7\\x02\\u0EA9\\x02\" +\r\n\t\t\"\\u0EA9\\x02\\u0EAC\\x02\\u0EAD\\x02\\u0EAF\\x02\\u0EBB\\x02\\u0EBD\\x02\\u0EBF\\x02\" +\r\n\t\t\"\\u0EC2\\x02\\u0EC6\\x02\\u0EC8\\x02\\u0EC8\\x02\\u0ECA\\x02\\u0ECF\\x02\\u0ED2\\x02\" +\r\n\t\t\"\\u0EDB\\x02\\u0EDE\\x02\\u0EE1\\x02\\u0F02\\x02\\u0F02\\x02\\u0F1A\\x02\\u0F1B\\x02\" +\r\n\t\t\"\\u0F22\\x02\\u0F2B\\x02\\u0F37\\x02\\u0F37\\x02\\u0F39\\x02\\u0F39\\x02\\u0F3B\\x02\" +\r\n\t\t\"\\u0F3B\\x02\\u0F40\\x02\\u0F49\\x02\\u0F4B\\x02\\u0F6E\\x02\\u0F73\\x02\\u0F86\\x02\" +\r\n\t\t\"\\u0F88\\x02\\u0F99\\x02\\u0F9B\\x02\\u0FBE\\x02\\u0FC8\\x02\\u0FC8\\x02\\u1002\\x02\" +\r\n\t\t\"\\u104B\\x02\\u1052\\x02\\u109F\\x02\\u10A2\\x02\\u10C7\\x02\\u10C9\\x02\\u10C9\\x02\" +\r\n\t\t\"\\u10CF\\x02\\u10CF\\x02\\u10D2\\x02\\u10FC\\x02\\u10FE\\x02\\u124A\\x02\\u124C\\x02\" +\r\n\t\t\"\\u124F\\x02\\u1252\\x02\\u1258\\x02\\u125A\\x02\\u125A\\x02\\u125C\\x02\\u125F\\x02\" +\r\n\t\t\"\\u1262\\x02\\u128A\\x02\\u128C\\x02\\u128F\\x02\\u1292\\x02\\u12B2\\x02\\u12B4\\x02\" +\r\n\t\t\"\\u12B7\\x02\\u12BA\\x02\\u12C0\\x02\\u12C2\\x02\\u12C2\\x02\\u12C4\\x02\\u12C7\\x02\" +\r\n\t\t\"\\u12CA\\x02\\u12D8\\x02\\u12DA\\x02\\u1312\\x02\\u1314\\x02\\u1317\\x02\\u131A\\x02\" +\r\n\t\t\"\\u135C\\x02\\u135F\\x02\\u1361\\x02\\u1382\\x02\\u1391\\x02\\u13A2\\x02\\u13F7\\x02\" +\r\n\t\t\"\\u13FA\\x02\\u13FF\\x02\\u1403\\x02\\u166E\\x02\\u1671\\x02\\u1681\\x02\\u1683\\x02\" +\r\n\t\t\"\\u169C\\x02\\u16A2\\x02\\u16EC\\x02\\u16F0\\x02\\u16FA\\x02\\u1702\\x02\\u170E\\x02\" +\r\n\t\t\"\\u1710\\x02\\u1716\\x02\\u1722\\x02\\u1736\\x02\\u1742\\x02\\u1755\\x02\\u1762\\x02\" +\r\n\t\t\"\\u176E\\x02\\u1770\\x02\\u1772\\x02\\u1774\\x02\\u1775\\x02\\u1782\\x02\\u17D5\\x02\" +\r\n\t\t\"\\u17D9\\x02\\u17D9\\x02\\u17DE\\x02\\u17DF\\x02\\u17E2\\x02\\u17EB\\x02\\u180D\\x02\" +\r\n\t\t\"\\u1810\\x02\\u1812\\x02\\u181B\\x02\\u1822\\x02\\u1879\\x02\\u1882\\x02\\u18AC\\x02\" +\r\n\t\t\"\\u18B2\\x02\\u18F7\\x02\\u1902\\x02\\u1920\\x02\\u1922\\x02\\u192D\\x02\\u1932\\x02\" +\r\n\t\t\"\\u193D\\x02\\u1948\\x02\\u196F\\x02\\u1972\\x02\\u1976\\x02\\u1982\\x02\\u19AD\\x02\" +\r\n\t\t\"\\u19B2\\x02\\u19CB\\x02\\u19D2\\x02\\u19DB\\x02\\u1A02\\x02\\u1A1D\\x02\\u1A22\\x02\" +\r\n\t\t\"\\u1A60\\x02\\u1A62\\x02\\u1A7E\\x02\\u1A81\\x02\\u1A8B\\x02\\u1A92\\x02\\u1A9B\\x02\" +\r\n\t\t\"\\u1AA9\\x02\\u1AA9\\x02\\u1AB2\\x02\\u1ABF\\x02\\u1B02\\x02\\u1B4D\\x02\\u1B52\\x02\" +\r\n\t\t\"\\u1B5B\\x02\\u1B6D\\x02\\u1B75\\x02\\u1B82\\x02\\u1BF5\\x02\\u1C02\\x02\\u1C39\\x02\" +\r\n\t\t\"\\u1C42\\x02\\u1C4B\\x02\\u1C4F\\x02\\u1C7F\\x02\\u1C82\\x02\\u1C8A\\x02\\u1CD2\\x02\" +\r\n\t\t\"\\u1CD4\\x02\\u1CD6\\x02\\u1CF8\\x02\\u1CFA\\x02\\u1CFB\\x02\\u1D02\\x02\\u1DF7\\x02\" +\r\n\t\t\"\\u1DFD\\x02\\u1F17\\x02\\u1F1A\\x02\\u1F1F\\x02\\u1F22\\x02\\u1F47\\x02\\u1F4A\\x02\" +\r\n\t\t\"\\u1F4F\\x02\\u1F52\\x02\\u1F59\\x02\\u1F5B\\x02\\u1F5B\\x02\\u1F5D\\x02\\u1F5D\\x02\" +\r\n\t\t\"\\u1F5F\\x02\\u1F5F\\x02\\u1F61\\x02\\u1F7F\\x02\\u1F82\\x02\\u1FB6\\x02\\u1FB8\\x02\" +\r\n\t\t\"\\u1FBE\\x02\\u1FC0\\x02\\u1FC0\\x02\\u1FC4\\x02\\u1FC6\\x02\\u1FC8\\x02\\u1FCE\\x02\" +\r\n\t\t\"\\u1FD2\\x02\\u1FD5\\x02\\u1FD8\\x02\\u1FDD\\x02\\u1FE2\\x02\\u1FEE\\x02\\u1FF4\\x02\" +\r\n\t\t\"\\u1FF6\\x02\\u1FF8\\x02\\u1FFE\\x02\\u200D\\x02\\u2011\\x02\\u202C\\x02\\u2030\\x02\" +\r\n\t\t\"\\u2041\\x02\\u2042\\x02\\u2056\\x02\\u2056\\x02\\u2062\\x02\\u2066\\x02\\u2068\\x02\" +\r\n\t\t\"\\u2071\\x02\\u2073\\x02\\u2073\\x02\\u2081\\x02\\u2081\\x02\\u2092\\x02\\u209E\\x02\" +\r\n\t\t\"\\u20D2\\x02\\u20DE\\x02\\u20E3\\x02\\u20E3\\x02\\u20E7\\x02\\u20F2\\x02\\u2104\\x02\" +\r\n\t\t\"\\u2104\\x02\\u2109\\x02\\u2109\\x02\\u210C\\x02\\u2115\\x02\\u2117\\x02\\u2117\\x02\" +\r\n\t\t\"\\u211B\\x02\\u211F\\x02\\u2126\\x02\\u2126\\x02\\u2128\\x02\\u2128\\x02\\u212A\\x02\" +\r\n\t\t\"\\u212A\\x02\\u212C\\x02\\u212F\\x02\\u2131\\x02\\u213B\\x02\\u213E\\x02\\u2141\\x02\" +\r\n\t\t\"\\u2147\\x02\\u214B\\x02\\u2150\\x02\\u2150\\x02\\u2162\\x02\\u218A\\x02\\u2C02\\x02\" +\r\n\t\t\"\\u2C30\\x02\\u2C32\\x02\\u2C60\\x02\\u2C62\\x02\\u2CE6\\x02\\u2CED\\x02\\u2CF5\\x02\" +\r\n\t\t\"\\u2D02\\x02\\u2D27\\x02\\u2D29\\x02\\u2D29\\x02\\u2D2F\\x02\\u2D2F\\x02\\u2D32\\x02\" +\r\n\t\t\"\\u2D69\\x02\\u2D71\\x02\\u2D71\\x02\\u2D81\\x02\\u2D98\\x02\\u2DA2\\x02\\u2DA8\\x02\" +\r\n\t\t\"\\u2DAA\\x02\\u2DB0\\x02\\u2DB2\\x02\\u2DB8\\x02\\u2DBA\\x02\\u2DC0\\x02\\u2DC2\\x02\" +\r\n\t\t\"\\u2DC8\\x02\\u2DCA\\x02\\u2DD0\\x02\\u2DD2\\x02\\u2DD8\\x02\\u2DDA\\x02\\u2DE0\\x02\" +\r\n\t\t\"\\u2DE2\\x02\\u2E01\\x02\\u2E31\\x02\\u2E31\\x02\\u3007\\x02\\u3009\\x02\\u3023\\x02\" +\r\n\t\t\"\\u3031\\x02\\u3033\\x02\\u3037\\x02\\u303A\\x02\\u303E\\x02\\u3043\\x02\\u3098\\x02\" +\r\n\t\t\"\\u309B\\x02\\u309C\\x02\\u309F\\x02\\u30A1\\x02\\u30A3\\x02\\u30FC\\x02\\u30FE\\x02\" +\r\n\t\t\"\\u3101\\x02\\u3107\\x02\\u312F\\x02\\u3133\\x02\\u3190\\x02\\u31A2\\x02\\u31BC\\x02\" +\r\n\t\t\"\\u31F2\\x02\\u3201\\x02\\u3402\\x02\\u4DB7\\x02\\u4E02\\x02\\u9FD7\\x02\\uA002\\x02\" +\r\n\t\t\"\\uA48E\\x02\\uA4D2\\x02\\uA4FF\\x02\\uA502\\x02\\uA60E\\x02\\uA612\\x02\\uA62D\\x02\" +\r\n\t\t\"\\uA642\\x02\\uA671\\x02\\uA676\\x02\\uA67F\\x02\\uA681\\x02\\uA6F3\\x02\\uA719\\x02\" +\r\n\t\t\"\\uA721\\x02\\uA724\\x02\\uA78A\\x02\\uA78D\\x02\\uA7B0\\x02\\uA7B2\\x02\\uA7B9\\x02\" +\r\n\t\t\"\\uA7F9\\x02\\uA829\\x02\\uA842\\x02\\uA875\\x02\\uA882\\x02\\uA8C7\\x02\\uA8D2\\x02\" +\r\n\t\t\"\\uA8DB\\x02\\uA8E2\\x02\\uA8F9\\x02\\uA8FD\\x02\\uA8FD\\x02\\uA8FF\\x02\\uA8FF\\x02\" +\r\n\t\t\"\\uA902\\x02\\uA92F\\x02\\uA932\\x02\\uA955\\x02\\uA962\\x02\\uA97E\\x02\\uA982\\x02\" +\r\n\t\t\"\\uA9C2\\x02\\uA9D1\\x02\\uA9DB\\x02\\uA9E2\\x02\\uAA00\\x02\\uAA02\\x02\\uAA38\\x02\" +\r\n\t\t\"\\uAA42\\x02\\uAA4F\\x02\\uAA52\\x02\\uAA5B\\x02\\uAA62\\x02\\uAA78\\x02\\uAA7C\\x02\" +\r\n\t\t\"\\uAAC4\\x02\\uAADD\\x02\\uAADF\\x02\\uAAE2\\x02\\uAAF1\\x02\\uAAF4\\x02\\uAAF8\\x02\" +\r\n\t\t\"\\uAB03\\x02\\uAB08\\x02\\uAB0B\\x02\\uAB10\\x02\\uAB13\\x02\\uAB18\\x02\\uAB22\\x02\" +\r\n\t\t\"\\uAB28\\x02\\uAB2A\\x02\\uAB30\\x02\\uAB32\\x02\\uAB5C\\x02\\uAB5E\\x02\\uAB67\\x02\" +\r\n\t\t\"\\uAB72\\x02\\uABEC\\x02\\uABEE\\x02\\uABEF\\x02\\uABF2\\x02\\uABFB\\x02\\uAC02\\x02\" +\r\n\t\t\"\\uD7A5\\x02\\uD7B2\\x02\\uD7C8\\x02\\uD7CD\\x02\\uD7FD\\x02\\uF902\\x02\\uFA6F\\x02\" +\r\n\t\t\"\\uFA72\\x02\\uFADB\\x02\\uFB02\\x02\\uFB08\\x02\\uFB15\\x02\\uFB19\\x02\\uFB1F\\x02\" +\r\n\t\t\"\\uFB2A\\x02\\uFB2C\\x02\\uFB38\\x02\\uFB3A\\x02\\uFB3E\\x02\\uFB40\\x02\\uFB40\\x02\" +\r\n\t\t\"\\uFB42\\x02\\uFB43\\x02\\uFB45\\x02\\uFB46\\x02\\uFB48\\x02\\uFBB3\\x02\\uFBD5\\x02\" +\r\n\t\t\"\\uFD3F\\x02\\uFD52\\x02\\uFD91\\x02\\uFD94\\x02\\uFDC9\\x02\\uFDF2\\x02\\uFDFD\\x02\" +\r\n\t\t\"\\uFE02\\x02\\uFE11\\x02\\uFE22\\x02\\uFE31\\x02\\uFE35\\x02\\uFE36\\x02\\uFE4F\\x02\" +\r\n\t\t\"\\uFE51\\x02\\uFE72\\x02\\uFE76\\x02\\uFE78\\x02\\uFEFE\\x02\\uFF01\\x02\\uFF01\\x02\" +\r\n\t\t\"\\uFF12\\x02\\uFF1B\\x02\\uFF23\\x02\\uFF3C\\x02\\uFF41\\x02\\uFF41\\x02\\uFF43\\x02\" +\r\n\t\t\"\\uFF5C\\x02\\uFF68\\x02\\uFFC0\\x02\\uFFC4\\x02\\uFFC9\\x02\\uFFCC\\x02\\uFFD1\\x02\" +\r\n\t\t\"\\uFFD4\\x02\\uFFD9\\x02\\uFFDC\\x02\\uFFDE\\x02\\uFFFB\\x02\\uFFFD\\x02\\x02\\x03\\r\" +\r\n\t\t\"\\x03\\x0F\\x03(\\x03*\\x03<\\x03>\\x03?\\x03A\\x03O\\x03R\\x03_\\x03\\x82\\x03\\xFC\" +\r\n\t\t\"\\x03\\u0142\\x03\\u0176\\x03\\u01FF\\x03\\u01FF\\x03\\u0282\\x03\\u029E\\x03\\u02A2\" +\r\n\t\t\"\\x03\\u02D2\\x03\\u02E2\\x03\\u02E2\\x03\\u0302\\x03\\u0321\\x03\\u0332\\x03\\u034C\" +\r\n\t\t\"\\x03\\u0352\\x03\\u037C\\x03\\u0382\\x03\\u039F\\x03\\u03A2\\x03\\u03C5\\x03\\u03CA\" +\r\n\t\t\"\\x03\\u03D1\\x03\\u03D3\\x03\\u03D7\\x03\\u0402\\x03\\u049F\\x03\\u04A2\\x03\\u04AB\" +\r\n\t\t\"\\x03\\u04B2\\x03\\u04D5\\x03\\u04DA\\x03\\u04FD\\x03\\u0502\\x03\\u0529\\x03\\u0532\" +\r\n\t\t\"\\x03\\u0565\\x03\\u0602\\x03\\u0738\\x03\\u0742\\x03\\u0757\\x03\\u0762\\x03\\u0769\" +\r\n\t\t\"\\x03\\u0802\\x03\\u0807\\x03\\u080A\\x03\\u080A\\x03\\u080C\\x03\\u0837\\x03\\u0839\" +\r\n\t\t\"\\x03\\u083A\\x03\\u083E\\x03\\u083E\\x03\\u0841\\x03\\u0857\\x03\\u0862\\x03\\u0878\" +\r\n\t\t\"\\x03\\u0882\\x03\\u08A0\\x03\\u08E2\\x03\\u08F4\\x03\\u08F6\\x03\\u08F7\\x03\\u0902\" +\r\n\t\t\"\\x03\\u0917\\x03\\u0922\\x03\\u093B\\x03\\u0982\\x03\\u09B9\\x03\\u09C0\\x03\\u09C1\" +\r\n\t\t\"\\x03\\u0A02\\x03\\u0A05\\x03\\u0A07\\x03\\u0A08\\x03\\u0A0E\\x03\\u0A15\\x03\\u0A17\" +\r\n\t\t\"\\x03\\u0A19\\x03\\u0A1B\\x03\\u0A35\\x03\\u0A3A\\x03\\u0A3C\\x03\\u0A41\\x03\\u0A41\" +\r\n\t\t\"\\x03\\u0A62\\x03\\u0A7E\\x03\\u0A82\\x03\\u0A9E\\x03\\u0AC2\\x03\\u0AC9\\x03\\u0ACB\" +\r\n\t\t\"\\x03\\u0AE8\\x03\\u0B02\\x03\\u0B37\\x03\\u0B42\\x03\\u0B57\\x03\\u0B62\\x03\\u0B74\" +\r\n\t\t\"\\x03\\u0B82\\x03\\u0B93\\x03\\u0C02\\x03\\u0C4A\\x03\\u0C82\\x03\\u0CB4\\x03\\u0CC2\" +\r\n\t\t\"\\x03\\u0CF4\\x03\\u1002\\x03\\u1048\\x03\\u1068\\x03\\u1071\\x03\\u1081\\x03\\u10BC\" +\r\n\t\t\"\\x03\\u10BF\\x03\\u10BF\\x03\\u10D2\\x03\\u10EA\\x03\\u10F2\\x03\\u10FB\\x03\\u1102\" +\r\n\t\t\"\\x03\\u1136\\x03\\u1138\\x03\\u1141\\x03\\u1152\\x03\\u1175\\x03\\u1178\\x03\\u1178\" +\r\n\t\t\"\\x03\\u1182\\x03\\u11C6\\x03\\u11CC\\x03\\u11CE\\x03\\u11D2\\x03\\u11DC\\x03\\u11DE\" +\r\n\t\t\"\\x03\\u11DE\\x03\\u1202\\x03\\u1213\\x03\\u1215\\x03\\u1239\\x03\\u1240\\x03\\u1240\" +\r\n\t\t\"\\x03\\u1282\\x03\\u1288\\x03\\u128A\\x03\\u128A\\x03\\u128C\\x03\\u128F\\x03\\u1291\" +\r\n\t\t\"\\x03\\u129F\\x03\\u12A1\\x03\\u12AA\\x03\\u12B2\\x03\\u12EC\\x03\\u12F2\\x03\\u12FB\" +\r\n\t\t\"\\x03\\u1302\\x03\\u1305\\x03\\u1307\\x03\\u130E\\x03\\u1311\\x03\\u1312\\x03\\u1315\" +\r\n\t\t\"\\x03\\u132A\\x03\\u132C\\x03\\u1332\\x03\\u1334\\x03\\u1335\\x03\\u1337\\x03\\u133B\" +\r\n\t\t\"\\x03\\u133E\\x03\\u1346\\x03\\u1349\\x03\\u134A\\x03\\u134D\\x03\\u134F\\x03\\u1352\" +\r\n\t\t\"\\x03\\u1352\\x03\\u1359\\x03\\u1359\\x03\\u135F\\x03\\u1365\\x03\\u1368\\x03\\u136E\" +\r\n\t\t\"\\x03\\u1372\\x03\\u1376\\x03\\u1402\\x03\\u144C\\x03\\u1452\\x03\\u145B\\x03\\u1482\" +\r\n\t\t\"\\x03\\u14C7\\x03\\u14C9\\x03\\u14C9\\x03\\u14D2\\x03\\u14DB\\x03\\u1582\\x03\\u15B7\" +\r\n\t\t\"\\x03\\u15BA\\x03\\u15C2\\x03\\u15DA\\x03\\u15DF\\x03\\u1602\\x03\\u1642\\x03\\u1646\" +\r\n\t\t\"\\x03\\u1646\\x03\\u1652\\x03\\u165B\\x03\\u1682\\x03\\u16B9\\x03\\u16C2\\x03\\u16CB\" +\r\n\t\t\"\\x03\\u1702\\x03\\u171B\\x03\\u171F\\x03\\u172D\\x03\\u1732\\x03\\u173B\\x03\\u18A2\" +\r\n\t\t\"\\x03\\u18EB\\x03\\u1901\\x03\\u1901\\x03\\u1AC2\\x03\\u1AFA\\x03\\u1C02\\x03\\u1C0A\" +\r\n\t\t\"\\x03\\u1C0C\\x03\\u1C38\\x03\\u1C3A\\x03\\u1C42\\x03\\u1C52\\x03\\u1C5B\\x03\\u1C74\" +\r\n\t\t\"\\x03\\u1C91\\x03\\u1C94\\x03\\u1CA9\\x03\\u1CAB\\x03\\u1CB8\\x03\\u2002\\x03\\u239B\" +\r\n\t\t\"\\x03\\u2402\\x03\\u2470\\x03\\u2482\\x03\\u2545\\x03\\u3002\\x03\\u3430\\x03\\u4402\" +\r\n\t\t\"\\x03\\u4648\\x03\\u6802\\x03\\u6A3A\\x03\\u6A42\\x03\\u6A60\\x03\\u6A62\\x03\\u6A6B\" +\r\n\t\t\"\\x03\\u6AD2\\x03\\u6AEF\\x03\\u6AF2\\x03\\u6AF6\\x03\\u6B02\\x03\\u6B38\\x03\\u6B42\" +\r\n\t\t\"\\x03\\u6B45\\x03\\u6B52\\x03\\u6B5B\\x03\\u6B65\\x03\\u6B79\\x03\\u6B7F\\x03\\u6B91\" +\r\n\t\t\"\\x03\\u6F02\\x03\\u6F46\\x03\\u6F52\\x03\\u6F80\\x03\\u6F91\\x03\\u6FA1\\x03\\u6FE2\" +\r\n\t\t\"\\x03\\u6FE2\\x03\\u7002\\x03\\u87EE\\x03\\u8802\\x03\\u8AF4\\x03\\uB002\\x03\\uB003\" +\r\n\t\t\"\\x03\\uBC02\\x03\\uBC6C\\x03\\uBC72\\x03\\uBC7E\\x03\\uBC82\\x03\\uBC8A\\x03\\uBC92\" +\r\n\t\t\"\\x03\\uBC9B\\x03\\uBC9F\\x03\\uBCA0\\x03\\uBCA2\\x03\\uBCA5\\x03\\uD167\\x03\\uD16B\" +\r\n\t\t\"\\x03\\uD16F\\x03\\uD184\\x03\\uD187\\x03\\uD18D\\x03\\uD1AC\\x03\\uD1AF\\x03\\uD244\" +\r\n\t\t\"\\x03\\uD246\\x03\\uD402\\x03\\uD456\\x03\\uD458\\x03\\uD49E\\x03\\uD4A0\\x03\\uD4A1\" +\r\n\t\t\"\\x03\\uD4A4\\x03\\uD4A4\\x03\\uD4A7\\x03\\uD4A8\\x03\\uD4AB\\x03\\uD4AE\\x03\\uD4B0\" +\r\n\t\t\"\\x03\\uD4BB\\x03\\uD4BD\\x03\\uD4BD\\x03\\uD4BF\\x03\\uD4C5\\x03\\uD4C7\\x03\\uD507\" +\r\n\t\t\"\\x03\\uD509\\x03\\uD50C\\x03\\uD50F\\x03\\uD516\\x03\\uD518\\x03\\uD51E\\x03\\uD520\" +\r\n\t\t\"\\x03\\uD53B\\x03\\uD53D\\x03\\uD540\\x03\\uD542\\x03\\uD546\\x03\\uD548\\x03\\uD548\" +\r\n\t\t\"\\x03\\uD54C\\x03\\uD552\\x03\\uD554\\x03\\uD6A7\\x03\\uD6AA\\x03\\uD6C2\\x03\\uD6C4\" +\r\n\t\t\"\\x03\\uD6DC\\x03\\uD6DE\\x03\\uD6FC\\x03\\uD6FE\\x03\\uD716\\x03\\uD718\\x03\\uD736\" +\r\n\t\t\"\\x03\\uD738\\x03\\uD750\\x03\\uD752\\x03\\uD770\\x03\\uD772\\x03\\uD78A\\x03\\uD78C\" +\r\n\t\t\"\\x03\\uD7AA\\x03\\uD7AC\\x03\\uD7C4\\x03\\uD7C6\\x03\\uD7CD\\x03\\uD7D0\\x03\\uD801\" +\r\n\t\t\"\\x03\\uDA02\\x03\\uDA38\\x03\\uDA3D\\x03\\uDA6E\\x03\\uDA77\\x03\\uDA77\\x03\\uDA86\" +\r\n\t\t\"\\x03\\uDA86\\x03\\uDA9D\\x03\\uDAA1\\x03\\uDAA3\\x03\\uDAB1\\x03\\uE002\\x03\\uE008\" +\r\n\t\t\"\\x03\\uE00A\\x03\\uE01A\\x03\\uE01D\\x03\\uE023\\x03\\uE025\\x03\\uE026\\x03\\uE028\" +\r\n\t\t\"\\x03\\uE02C\\x03\\uE802\\x03\\uE8C6\\x03\\uE8D2\\x03\\uE8D8\\x03\\uE902\\x03\\uE94C\" +\r\n\t\t\"\\x03\\uE952\\x03\\uE95B\\x03\\uEE02\\x03\\uEE05\\x03\\uEE07\\x03\\uEE21\\x03\\uEE23\" +\r\n\t\t\"\\x03\\uEE24\\x03\\uEE26\\x03\\uEE26\\x03\\uEE29\\x03\\uEE29\\x03\\uEE2B\\x03\\uEE34\" +\r\n\t\t\"\\x03\\uEE36\\x03\\uEE39\\x03\\uEE3B\\x03\\uEE3B\\x03\\uEE3D\\x03\\uEE3D\\x03\\uEE44\" +\r\n\t\t\"\\x03\\uEE44\\x03\\uEE49\\x03\\uEE49\\x03\\uEE4B\\x03\\uEE4B\\x03\\uEE4D\\x03\\uEE4D\" +\r\n\t\t\"\\x03\\uEE4F\\x03\\uEE51\\x03\\uEE53\\x03\\uEE54\\x03\\uEE56\\x03\\uEE56\\x03\\uEE59\" +\r\n\t\t\"\\x03\\uEE59\\x03\\uEE5B\\x03\\uEE5B\\x03\\uEE5D\\x03\\uEE5D\\x03\\uEE5F\\x03\\uEE5F\" +\r\n\t\t\"\\x03\\uEE61\\x03\\uEE61\\x03\\uEE63\\x03\\uEE64\\x03\\uEE66\\x03\\uEE66\\x03\\uEE69\" +\r\n\t\t\"\\x03\\uEE6C\\x03\\uEE6E\\x03\\uEE74\\x03\\uEE76\\x03\\uEE79\\x03\\uEE7B\\x03\\uEE7E\" +\r\n\t\t\"\\x03\\uEE80\\x03\\uEE80\\x03\\uEE82\\x03\\uEE8B\\x03\\uEE8D\\x03\\uEE9D\\x03\\uEEA3\" +\r\n\t\t\"\\x03\\uEEA5\\x03\\uEEA7\\x03\\uEEAB\\x03\\uEEAD\\x03\\uEEBD\\x03\\x02\\x04\\uA6D8\\x04\" +\r\n\t\t\"\\uA702\\x04\\uB736\\x04\\uB742\\x04\\uB81F\\x04\\uB822\\x04\\uCEA3\\x04\\uF802\\x04\" +\r\n\t\t\"\\uFA1F\\x04\\x03\\x10\\x03\\x10\\\"\\x10\\x81\\x10\\u0102\\x10\\u01F1\\x10\\u0240\\x02\" +\r\n\t\t\"C\\x02\\\\\\x02c\\x02|\\x02\\xAC\\x02\\xAC\\x02\\xB7\\x02\\xB7\\x02\\xBC\\x02\\xBC\\x02\" +\r\n\t\t\"\\xC2\\x02\\xD8\\x02\\xDA\\x02\\xF8\\x02\\xFA\\x02\\u02C3\\x02\\u02C8\\x02\\u02D3\\x02\" +\r\n\t\t\"\\u02E2\\x02\\u02E6\\x02\\u02EE\\x02\\u02EE\\x02\\u02F0\\x02\\u02F0\\x02\\u0372\\x02\" +\r\n\t\t\"\\u0376\\x02\\u0378\\x02\\u0379\\x02\\u037C\\x02\\u037F\\x02\\u0381\\x02\\u0381\\x02\" +\r\n\t\t\"\\u0388\\x02\\u0388\\x02\\u038A\\x02\\u038C\\x02\\u038E\\x02\\u038E\\x02\\u0390\\x02\" +\r\n\t\t\"\\u03A3\\x02\\u03A5\\x02\\u03F7\\x02\\u03F9\\x02\\u0483\\x02\\u048C\\x02\\u0531\\x02\" +\r\n\t\t\"\\u0533\\x02\\u0558\\x02\\u055B\\x02\\u055B\\x02\\u0563\\x02\\u0589\\x02\\u05D2\\x02\" +\r\n\t\t\"\\u05EC\\x02\\u05F2\\x02\\u05F4\\x02\\u0622\\x02\\u064C\\x02\\u0670\\x02\\u0671\\x02\" +\r\n\t\t\"\\u0673\\x02\\u06D5\\x02\\u06D7\\x02\\u06D7\\x02\\u06E7\\x02\\u06E8\\x02\\u06F0\\x02\" +\r\n\t\t\"\\u06F1\\x02\\u06FC\\x02\\u06FE\\x02\\u0701\\x02\\u0701\\x02\\u0712\\x02\\u0712\\x02\" +\r\n\t\t\"\\u0714\\x02\\u0731\\x02\\u074F\\x02\\u07A7\\x02\\u07B3\\x02\\u07B3\\x02\\u07CC\\x02\" +\r\n\t\t\"\\u07EC\\x02\\u07F6\\x02\\u07F7\\x02\\u07FC\\x02\\u07FC\\x02\\u0802\\x02\\u0817\\x02\" +\r\n\t\t\"\\u081C\\x02\\u081C\\x02\\u0826\\x02\\u0826\\x02\\u082A\\x02\\u082A\\x02\\u0842\\x02\" +\r\n\t\t\"\\u085A\\x02\\u08A2\\x02\\u08B6\\x02\\u08B8\\x02\\u08BF\\x02\\u0906\\x02\\u093B\\x02\" +\r\n\t\t\"\\u093F\\x02\\u093F\\x02\\u0952\\x02\\u0952\\x02\\u095A\\x02\\u0963\\x02\\u0973\\x02\" +\r\n\t\t\"\\u0982\\x02\\u0987\\x02\\u098E\\x02\\u0991\\x02\\u0992\\x02\\u0995\\x02\\u09AA\\x02\" +\r\n\t\t\"\\u09AC\\x02\\u09B2\\x02\\u09B4\\x02\\u09B4\\x02\\u09B8\\x02\\u09BB\\x02\\u09BF\\x02\" +\r\n\t\t\"\\u09BF\\x02\\u09D0\\x02\\u09D0\\x02\\u09DE\\x02\\u09DF\\x02\\u09E1\\x02\\u09E3\\x02\" +\r\n\t\t\"\\u09F2\\x02\\u09F3\\x02\\u0A07\\x02\\u0A0C\\x02\\u0A11\\x02\\u0A12\\x02\\u0A15\\x02\" +\r\n\t\t\"\\u0A2A\\x02\\u0A2C\\x02\\u0A32\\x02\\u0A34\\x02\\u0A35\\x02\\u0A37\\x02\\u0A38\\x02\" +\r\n\t\t\"\\u0A3A\\x02\\u0A3B\\x02\\u0A5B\\x02\\u0A5E\\x02\\u0A60\\x02\\u0A60\\x02\\u0A74\\x02\" +\r\n\t\t\"\\u0A76\\x02\\u0A87\\x02\\u0A8F\\x02\\u0A91\\x02\\u0A93\\x02\\u0A95\\x02\\u0AAA\\x02\" +\r\n\t\t\"\\u0AAC\\x02\\u0AB2\\x02\\u0AB4\\x02\\u0AB5\\x02\\u0AB7\\x02\\u0ABB\\x02\\u0ABF\\x02\" +\r\n\t\t\"\\u0ABF\\x02\\u0AD2\\x02\\u0AD2\\x02\\u0AE2\\x02\\u0AE3\\x02\\u0AFB\\x02\\u0AFB\\x02\" +\r\n\t\t\"\\u0B07\\x02\\u0B0E\\x02\\u0B11\\x02\\u0B12\\x02\\u0B15\\x02\\u0B2A\\x02\\u0B2C\\x02\" +\r\n\t\t\"\\u0B32\\x02\\u0B34\\x02\\u0B35\\x02\\u0B37\\x02\\u0B3B\\x02\\u0B3F\\x02\\u0B3F\\x02\" +\r\n\t\t\"\\u0B5E\\x02\\u0B5F\\x02\\u0B61\\x02\\u0B63\\x02\\u0B73\\x02\\u0B73\\x02\\u0B85\\x02\" +\r\n\t\t\"\\u0B85\\x02\\u0B87\\x02\\u0B8C\\x02\\u0B90\\x02\\u0B92\\x02\\u0B94\\x02\\u0B97\\x02\" +\r\n\t\t\"\\u0B9B\\x02\\u0B9C\\x02\\u0B9E\\x02\\u0B9E\\x02\\u0BA0\\x02\\u0BA1\\x02\\u0BA5\\x02\" +\r\n\t\t\"\\u0BA6\\x02\\u0BAA\\x02\\u0BAC\\x02\\u0BB0\\x02\\u0BBB\\x02\\u0BD2\\x02\\u0BD2\\x02\" +\r\n\t\t\"\\u0C07\\x02\\u0C0E\\x02\\u0C10\\x02\\u0C12\\x02\\u0C14\\x02\\u0C2A\\x02\\u0C2C\\x02\" +\r\n\t\t\"\\u0C3B\\x02\\u0C3F\\x02\\u0C3F\\x02\\u0C5A\\x02\\u0C5C\\x02\\u0C62\\x02\\u0C63\\x02\" +\r\n\t\t\"\\u0C82\\x02\\u0C82\\x02\\u0C87\\x02\\u0C8E\\x02\\u0C90\\x02\\u0C92\\x02\\u0C94\\x02\" +\r\n\t\t\"\\u0CAA\\x02\\u0CAC\\x02\\u0CB5\\x02\\u0CB7\\x02\\u0CBB\\x02\\u0CBF\\x02\\u0CBF\\x02\" +\r\n\t\t\"\\u0CE0\\x02\\u0CE0\\x02\\u0CE2\\x02\\u0CE3\\x02\\u0CF3\\x02\\u0CF4\\x02\\u0D07\\x02\" +\r\n\t\t\"\\u0D0E\\x02\\u0D10\\x02\\u0D12\\x02\\u0D14\\x02\\u0D3C\\x02\\u0D3F\\x02\\u0D3F\\x02\" +\r\n\t\t\"\\u0D50\\x02\\u0D50\\x02\\u0D56\\x02\\u0D58\\x02\\u0D61\\x02\\u0D63\\x02\\u0D7C\\x02\" +\r\n\t\t\"\\u0D81\\x02\\u0D87\\x02\\u0D98\\x02\\u0D9C\\x02\\u0DB3\\x02\\u0DB5\\x02\\u0DBD\\x02\" +\r\n\t\t\"\\u0DBF\\x02\\u0DBF\\x02\\u0DC2\\x02\\u0DC8\\x02\\u0E03\\x02\\u0E32\\x02\\u0E34\\x02\" +\r\n\t\t\"\\u0E35\\x02\\u0E42\\x02\\u0E48\\x02\\u0E83\\x02\\u0E84\\x02\\u0E86\\x02\\u0E86\\x02\" +\r\n\t\t\"\\u0E89\\x02\\u0E8A\\x02\\u0E8C\\x02\\u0E8C\\x02\\u0E8F\\x02\\u0E8F\\x02\\u0E96\\x02\" +\r\n\t\t\"\\u0E99\\x02\\u0E9B\\x02\\u0EA1\\x02\\u0EA3\\x02\\u0EA5\\x02\\u0EA7\\x02\\u0EA7\\x02\" +\r\n\t\t\"\\u0EA9\\x02\\u0EA9\\x02\\u0EAC\\x02\\u0EAD\\x02\\u0EAF\\x02\\u0EB2\\x02\\u0EB4\\x02\" +\r\n\t\t\"\\u0EB5\\x02\\u0EBF\\x02\\u0EBF\\x02\\u0EC2\\x02\\u0EC6\\x02\\u0EC8\\x02\\u0EC8\\x02\" +\r\n\t\t\"\\u0EDE\\x02\\u0EE1\\x02\\u0F02\\x02\\u0F02\\x02\\u0F42\\x02\\u0F49\\x02\\u0F4B\\x02\" +\r\n\t\t\"\\u0F6E\\x02\\u0F8A\\x02\\u0F8E\\x02\\u1002\\x02\\u102C\\x02\\u1041\\x02\\u1041\\x02\" +\r\n\t\t\"\\u1052\\x02\\u1057\\x02\\u105C\\x02\\u105F\\x02\\u1063\\x02\\u1063\\x02\\u1067\\x02\" +\r\n\t\t\"\\u1068\\x02\\u1070\\x02\\u1072\\x02\\u1077\\x02\\u1083\\x02\\u1090\\x02\\u1090\\x02\" +\r\n\t\t\"\\u10A2\\x02\\u10C7\\x02\\u10C9\\x02\\u10C9\\x02\\u10CF\\x02\\u10CF\\x02\\u10D2\\x02\" +\r\n\t\t\"\\u10FC\\x02\\u10FE\\x02\\u124A\\x02\\u124C\\x02\\u124F\\x02\\u1252\\x02\\u1258\\x02\" +\r\n\t\t\"\\u125A\\x02\\u125A\\x02\\u125C\\x02\\u125F\\x02\\u1262\\x02\\u128A\\x02\\u128C\\x02\" +\r\n\t\t\"\\u128F\\x02\\u1292\\x02\\u12B2\\x02\\u12B4\\x02\\u12B7\\x02\\u12BA\\x02\\u12C0\\x02\" +\r\n\t\t\"\\u12C2\\x02\\u12C2\\x02\\u12C4\\x02\\u12C7\\x02\\u12CA\\x02\\u12D8\\x02\\u12DA\\x02\" +\r\n\t\t\"\\u1312\\x02\\u1314\\x02\\u1317\\x02\\u131A\\x02\\u135C\\x02\\u1382\\x02\\u1391\\x02\" +\r\n\t\t\"\\u13A2\\x02\\u13F7\\x02\\u13FA\\x02\\u13FF\\x02\\u1403\\x02\\u166E\\x02\\u1671\\x02\" +\r\n\t\t\"\\u1681\\x02\\u1683\\x02\\u169C\\x02\\u16A2\\x02\\u16EC\\x02\\u16F0\\x02\\u16FA\\x02\" +\r\n\t\t\"\\u1702\\x02\\u170E\\x02\\u1710\\x02\\u1713\\x02\\u1722\\x02\\u1733\\x02\\u1742\\x02\" +\r\n\t\t\"\\u1753\\x02\\u1762\\x02\\u176E\\x02\\u1770\\x02\\u1772\\x02\\u1782\\x02\\u17B5\\x02\" +\r\n\t\t\"\\u17D9\\x02\\u17D9\\x02\\u17DE\\x02\\u17DE\\x02\\u1822\\x02\\u1879\\x02\\u1882\\x02\" +\r\n\t\t\"\\u1886\\x02\\u1889\\x02\\u18AA\\x02\\u18AC\\x02\\u18AC\\x02\\u18B2\\x02\\u18F7\\x02\" +\r\n\t\t\"\\u1902\\x02\\u1920\\x02\\u1952\\x02\\u196F\\x02\\u1972\\x02\\u1976\\x02\\u1982\\x02\" +\r\n\t\t\"\\u19AD\\x02\\u19B2\\x02\\u19CB\\x02\\u1A02\\x02\\u1A18\\x02\\u1A22\\x02\\u1A56\\x02\" +\r\n\t\t\"\\u1AA9\\x02\\u1AA9\\x02\\u1B07\\x02\\u1B35\\x02\\u1B47\\x02\\u1B4D\\x02\\u1B85\\x02\" +\r\n\t\t\"\\u1BA2\\x02\\u1BB0\\x02\\u1BB1\\x02\\u1BBC\\x02\\u1BE7\\x02\\u1C02\\x02\\u1C25\\x02\" +\r\n\t\t\"\\u1C4F\\x02\\u1C51\\x02\\u1C5C\\x02\\u1C7F\\x02\\u1C82\\x02\\u1C8A\\x02\\u1CEB\\x02\" +\r\n\t\t\"\\u1CEE\\x02\\u1CF0\\x02\\u1CF3\\x02\\u1CF7\\x02\\u1CF8\\x02\\u1D02\\x02\\u1DC1\\x02\" +\r\n\t\t\"\\u1E02\\x02\\u1F17\\x02\\u1F1A\\x02\\u1F1F\\x02\\u1F22\\x02\\u1F47\\x02\\u1F4A\\x02\" +\r\n\t\t\"\\u1F4F\\x02\\u1F52\\x02\\u1F59\\x02\\u1F5B\\x02\\u1F5B\\x02\\u1F5D\\x02\\u1F5D\\x02\" +\r\n\t\t\"\\u1F5F\\x02\\u1F5F\\x02\\u1F61\\x02\\u1F7F\\x02\\u1F82\\x02\\u1FB6\\x02\\u1FB8\\x02\" +\r\n\t\t\"\\u1FBE\\x02\\u1FC0\\x02\\u1FC0\\x02\\u1FC4\\x02\\u1FC6\\x02\\u1FC8\\x02\\u1FCE\\x02\" +\r\n\t\t\"\\u1FD2\\x02\\u1FD5\\x02\\u1FD8\\x02\\u1FDD\\x02\\u1FE2\\x02\\u1FEE\\x02\\u1FF4\\x02\" +\r\n\t\t\"\\u1FF6\\x02\\u1FF8\\x02\\u1FFE\\x02\\u2073\\x02\\u2073\\x02\\u2081\\x02\\u2081\\x02\" +\r\n\t\t\"\\u2092\\x02\\u209E\\x02\\u2104\\x02\\u2104\\x02\\u2109\\x02\\u2109\\x02\\u210C\\x02\" +\r\n\t\t\"\\u2115\\x02\\u2117\\x02\\u2117\\x02\\u211B\\x02\\u211F\\x02\\u2126\\x02\\u2126\\x02\" +\r\n\t\t\"\\u2128\\x02\\u2128\\x02\\u212A\\x02\\u212A\\x02\\u212C\\x02\\u212F\\x02\\u2131\\x02\" +\r\n\t\t\"\\u213B\\x02\\u213E\\x02\\u2141\\x02\\u2147\\x02\\u214B\\x02\\u2150\\x02\\u2150\\x02\" +\r\n\t\t\"\\u2162\\x02\\u218A\\x02\\u2C02\\x02\\u2C30\\x02\\u2C32\\x02\\u2C60\\x02\\u2C62\\x02\" +\r\n\t\t\"\\u2CE6\\x02\\u2CED\\x02\\u2CF0\\x02\\u2CF4\\x02\\u2CF5\\x02\\u2D02\\x02\\u2D27\\x02\" +\r\n\t\t\"\\u2D29\\x02\\u2D29\\x02\\u2D2F\\x02\\u2D2F\\x02\\u2D32\\x02\\u2D69\\x02\\u2D71\\x02\" +\r\n\t\t\"\\u2D71\\x02\\u2D82\\x02\\u2D98\\x02\\u2DA2\\x02\\u2DA8\\x02\\u2DAA\\x02\\u2DB0\\x02\" +\r\n\t\t\"\\u2DB2\\x02\\u2DB8\\x02\\u2DBA\\x02\\u2DC0\\x02\\u2DC2\\x02\\u2DC8\\x02\\u2DCA\\x02\" +\r\n\t\t\"\\u2DD0\\x02\\u2DD2\\x02\\u2DD8\\x02\\u2DDA\\x02\\u2DE0\\x02\\u2E31\\x02\\u2E31\\x02\" +\r\n\t\t\"\\u3007\\x02\\u3009\\x02\\u3023\\x02\\u302B\\x02\\u3033\\x02\\u3037\\x02\\u303A\\x02\" +\r\n\t\t\"\\u303E\\x02\\u3043\\x02\\u3098\\x02\\u309F\\x02\\u30A1\\x02\\u30A3\\x02\\u30FC\\x02\" +\r\n\t\t\"\\u30FE\\x02\\u3101\\x02\\u3107\\x02\\u312F\\x02\\u3133\\x02\\u3190\\x02\\u31A2\\x02\" +\r\n\t\t\"\\u31BC\\x02\\u31F2\\x02\\u3201\\x02\\u3402\\x02\\u4DB7\\x02\\u4E02\\x02\\u9FD7\\x02\" +\r\n\t\t\"\\uA002\\x02\\uA48E\\x02\\uA4D2\\x02\\uA4FF\\x02\\uA502\\x02\\uA60E\\x02\\uA612\\x02\" +\r\n\t\t\"\\uA621\\x02\\uA62C\\x02\\uA62D\\x02\\uA642\\x02\\uA670\\x02\\uA681\\x02\\uA69F\\x02\" +\r\n\t\t\"\\uA6A2\\x02\\uA6F1\\x02\\uA719\\x02\\uA721\\x02\\uA724\\x02\\uA78A\\x02\\uA78D\\x02\" +\r\n\t\t\"\\uA7B0\\x02\\uA7B2\\x02\\uA7B9\\x02\\uA7F9\\x02\\uA803\\x02\\uA805\\x02\\uA807\\x02\" +\r\n\t\t\"\\uA809\\x02\\uA80C\\x02\\uA80E\\x02\\uA824\\x02\\uA842\\x02\\uA875\\x02\\uA884\\x02\" +\r\n\t\t\"\\uA8B5\\x02\\uA8F4\\x02\\uA8F9\\x02\\uA8FD\\x02\\uA8FD\\x02\\uA8FF\\x02\\uA8FF\\x02\" +\r\n\t\t\"\\uA90C\\x02\\uA927\\x02\\uA932\\x02\\uA948\\x02\\uA962\\x02\\uA97E\\x02\\uA986\\x02\" +\r\n\t\t\"\\uA9B4\\x02\\uA9D1\\x02\\uA9D1\\x02\\uA9E2\\x02\\uA9E6\\x02\\uA9E8\\x02\\uA9F1\\x02\" +\r\n\t\t\"\\uA9FC\\x02\\uAA00\\x02\\uAA02\\x02\\uAA2A\\x02\\uAA42\\x02\\uAA44\\x02\\uAA46\\x02\" +\r\n\t\t\"\\uAA4D\\x02\\uAA62\\x02\\uAA78\\x02\\uAA7C\\x02\\uAA7C\\x02\\uAA80\\x02\\uAAB1\\x02\" +\r\n\t\t\"\\uAAB3\\x02\\uAAB3\\x02\\uAAB7\\x02\\uAAB8\\x02\\uAABB\\x02\\uAABF\\x02\\uAAC2\\x02\" +\r\n\t\t\"\\uAAC2\\x02\\uAAC4\\x02\\uAAC4\\x02\\uAADD\\x02\\uAADF\\x02\\uAAE2\\x02\\uAAEC\\x02\" +\r\n\t\t\"\\uAAF4\\x02\\uAAF6\\x02\\uAB03\\x02\\uAB08\\x02\\uAB0B\\x02\\uAB10\\x02\\uAB13\\x02\" +\r\n\t\t\"\\uAB18\\x02\\uAB22\\x02\\uAB28\\x02\\uAB2A\\x02\\uAB30\\x02\\uAB32\\x02\\uAB5C\\x02\" +\r\n\t\t\"\\uAB5E\\x02\\uAB67\\x02\\uAB72\\x02\\uABE4\\x02\\uAC02\\x02\\uD7A5\\x02\\uD7B2\\x02\" +\r\n\t\t\"\\uD7C8\\x02\\uD7CD\\x02\\uD7FD\\x02\\uF902\\x02\\uFA6F\\x02\\uFA72\\x02\\uFADB\\x02\" +\r\n\t\t\"\\uFB02\\x02\\uFB08\\x02\\uFB15\\x02\\uFB19\\x02\\uFB1F\\x02\\uFB1F\\x02\\uFB21\\x02\" +\r\n\t\t\"\\uFB2A\\x02\\uFB2C\\x02\\uFB38\\x02\\uFB3A\\x02\\uFB3E\\x02\\uFB40\\x02\\uFB40\\x02\" +\r\n\t\t\"\\uFB42\\x02\\uFB43\\x02\\uFB45\\x02\\uFB46\\x02\\uFB48\\x02\\uFBB3\\x02\\uFBD5\\x02\" +\r\n\t\t\"\\uFD3F\\x02\\uFD52\\x02\\uFD91\\x02\\uFD94\\x02\\uFDC9\\x02\\uFDF2\\x02\\uFDFD\\x02\" +\r\n\t\t\"\\uFE72\\x02\\uFE76\\x02\\uFE78\\x02\\uFEFE\\x02\\uFF23\\x02\\uFF3C\\x02\\uFF43\\x02\" +\r\n\t\t\"\\uFF5C\\x02\\uFF68\\x02\\uFFC0\\x02\\uFFC4\\x02\\uFFC9\\x02\\uFFCC\\x02\\uFFD1\\x02\" +\r\n\t\t\"\\uFFD4\\x02\\uFFD9\\x02\\uFFDC\\x02\\uFFDE\\x02\\x02\\x03\\r\\x03\\x0F\\x03(\\x03*\\x03\" +\r\n\t\t\"<\\x03>\\x03?\\x03A\\x03O\\x03R\\x03_\\x03\\x82\\x03\\xFC\\x03\\u0142\\x03\\u0176\\x03\" +\r\n\t\t\"\\u0282\\x03\\u029E\\x03\\u02A2\\x03\\u02D2\\x03\\u0302\\x03\\u0321\\x03\\u0332\\x03\" +\r\n\t\t\"\\u034C\\x03\\u0352\\x03\\u0377\\x03\\u0382\\x03\\u039F\\x03\\u03A2\\x03\\u03C5\\x03\" +\r\n\t\t\"\\u03CA\\x03\\u03D1\\x03\\u03D3\\x03\\u03D7\\x03\\u0402\\x03\\u049F\\x03\\u04B2\\x03\" +\r\n\t\t\"\\u04D5\\x03\\u04DA\\x03\\u04FD\\x03\\u0502\\x03\\u0529\\x03\\u0532\\x03\\u0565\\x03\" +\r\n\t\t\"\\u0602\\x03\\u0738\\x03\\u0742\\x03\\u0757\\x03\\u0762\\x03\\u0769\\x03\\u0802\\x03\" +\r\n\t\t\"\\u0807\\x03\\u080A\\x03\\u080A\\x03\\u080C\\x03\\u0837\\x03\\u0839\\x03\\u083A\\x03\" +\r\n\t\t\"\\u083E\\x03\\u083E\\x03\\u0841\\x03\\u0857\\x03\\u0862\\x03\\u0878\\x03\\u0882\\x03\" +\r\n\t\t\"\\u08A0\\x03\\u08E2\\x03\\u08F4\\x03\\u08F6\\x03\\u08F7\\x03\\u0902\\x03\\u0917\\x03\" +\r\n\t\t\"\\u0922\\x03\\u093B\\x03\\u0982\\x03\\u09B9\\x03\\u09C0\\x03\\u09C1\\x03\\u0A02\\x03\" +\r\n\t\t\"\\u0A02\\x03\\u0A12\\x03\\u0A15\\x03\\u0A17\\x03\\u0A19\\x03\\u0A1B\\x03\\u0A35\\x03\" +\r\n\t\t\"\\u0A62\\x03\\u0A7E\\x03\\u0A82\\x03\\u0A9E\\x03\\u0AC2\\x03\\u0AC9\\x03\\u0ACB\\x03\" +\r\n\t\t\"\\u0AE6\\x03\\u0B02\\x03\\u0B37\\x03\\u0B42\\x03\\u0B57\\x03\\u0B62\\x03\\u0B74\\x03\" +\r\n\t\t\"\\u0B82\\x03\\u0B93\\x03\\u0C02\\x03\\u0C4A\\x03\\u0C82\\x03\\u0CB4\\x03\\u0CC2\\x03\" +\r\n\t\t\"\\u0CF4\\x03\\u1005\\x03\\u1039\\x03\\u1085\\x03\\u10B1\\x03\\u10D2\\x03\\u10EA\\x03\" +\r\n\t\t\"\\u1105\\x03\\u1128\\x03\\u1152\\x03\\u1174\\x03\\u1178\\x03\\u1178\\x03\\u1185\\x03\" +\r\n\t\t\"\\u11B4\\x03\\u11C3\\x03\\u11C6\\x03\\u11DC\\x03\\u11DC\\x03\\u11DE\\x03\\u11DE\\x03\" +\r\n\t\t\"\\u1202\\x03\\u1213\\x03\\u1215\\x03\\u122D\\x03\\u1282\\x03\\u1288\\x03\\u128A\\x03\" +\r\n\t\t\"\\u128A\\x03\\u128C\\x03\\u128F\\x03\\u1291\\x03\\u129F\\x03\\u12A1\\x03\\u12AA\\x03\" +\r\n\t\t\"\\u12B2\\x03\\u12E0\\x03\\u1307\\x03\\u130E\\x03\\u1311\\x03\\u1312\\x03\\u1315\\x03\" +\r\n\t\t\"\\u132A\\x03\\u132C\\x03\\u1332\\x03\\u1334\\x03\\u1335\\x03\\u1337\\x03\\u133B\\x03\" +\r\n\t\t\"\\u133F\\x03\\u133F\\x03\\u1352\\x03\\u1352\\x03\\u135F\\x03\\u1363\\x03\\u1402\\x03\" +\r\n\t\t\"\\u1436\\x03\\u1449\\x03\\u144C\\x03\\u1482\\x03\\u14B1\\x03\\u14C6\\x03\\u14C7\\x03\" +\r\n\t\t\"\\u14C9\\x03\\u14C9\\x03\\u1582\\x03\\u15B0\\x03\\u15DA\\x03\\u15DD\\x03\\u1602\\x03\" +\r\n\t\t\"\\u1631\\x03\\u1646\\x03\\u1646\\x03\\u1682\\x03\\u16AC\\x03\\u1702\\x03\\u171B\\x03\" +\r\n\t\t\"\\u18A2\\x03\\u18E1\\x03\\u1901\\x03\\u1901\\x03\\u1AC2\\x03\\u1AFA\\x03\\u1C02\\x03\" +\r\n\t\t\"\\u1C0A\\x03\\u1C0C\\x03\\u1C30\\x03\\u1C42\\x03\\u1C42\\x03\\u1C74\\x03\\u1C91\\x03\" +\r\n\t\t\"\\u2002\\x03\\u239B\\x03\\u2402\\x03\\u2470\\x03\\u2482\\x03\\u2545\\x03\\u3002\\x03\" +\r\n\t\t\"\\u3430\\x03\\u4402\\x03\\u4648\\x03\\u6802\\x03\\u6A3A\\x03\\u6A42\\x03\\u6A60\\x03\" +\r\n\t\t\"\\u6AD2\\x03\\u6AEF\\x03\\u6B02\\x03\\u6B31\\x03\\u6B42\\x03\\u6B45\\x03\\u6B65\\x03\" +\r\n\t\t\"\\u6B79\\x03\\u6B7F\\x03\\u6B91\\x03\\u6F02\\x03\\u6F46\\x03\\u6F52\\x03\\u6F52\\x03\" +\r\n\t\t\"\\u6F95\\x03\\u6FA1\\x03\\u6FE2\\x03\\u6FE2\\x03\\u7002\\x03\\u87EE\\x03\\u8802\\x03\" +\r\n\t\t\"\\u8AF4\\x03\\uB002\\x03\\uB003\\x03\\uBC02\\x03\\uBC6C\\x03\\uBC72\\x03\\uBC7E\\x03\" +\r\n\t\t\"\\uBC82\\x03\\uBC8A\\x03\\uBC92\\x03\\uBC9B\\x03\\uD402\\x03\\uD456\\x03\\uD458\\x03\" +\r\n\t\t\"\\uD49E\\x03\\uD4A0\\x03\\uD4A1\\x03\\uD4A4\\x03\\uD4A4\\x03\\uD4A7\\x03\\uD4A8\\x03\" +\r\n\t\t\"\\uD4AB\\x03\\uD4AE\\x03\\uD4B0\\x03\\uD4BB\\x03\\uD4BD\\x03\\uD4BD\\x03\\uD4BF\\x03\" +\r\n\t\t\"\\uD4C5\\x03\\uD4C7\\x03\\uD507\\x03\\uD509\\x03\\uD50C\\x03\\uD50F\\x03\\uD516\\x03\" +\r\n\t\t\"\\uD518\\x03\\uD51E\\x03\\uD520\\x03\\uD53B\\x03\\uD53D\\x03\\uD540\\x03\\uD542\\x03\" +\r\n\t\t\"\\uD546\\x03\\uD548\\x03\\uD548\";\r\n\tprivate static readonly _serializedATNSegment1: string =\r\n\t\t\"\\x03\\uD54C\\x03\\uD552\\x03\\uD554\\x03\\uD6A7\\x03\\uD6AA\\x03\\uD6C2\\x03\\uD6C4\" +\r\n\t\t\"\\x03\\uD6DC\\x03\\uD6DE\\x03\\uD6FC\\x03\\uD6FE\\x03\\uD716\\x03\\uD718\\x03\\uD736\" +\r\n\t\t\"\\x03\\uD738\\x03\\uD750\\x03\\uD752\\x03\\uD770\\x03\\uD772\\x03\\uD78A\\x03\\uD78C\" +\r\n\t\t\"\\x03\\uD7AA\\x03\\uD7AC\\x03\\uD7C4\\x03\\uD7C6\\x03\\uD7CD\\x03\\uE802\\x03\\uE8C6\" +\r\n\t\t\"\\x03\\uE902\\x03\\uE945\\x03\\uEE02\\x03\\uEE05\\x03\\uEE07\\x03\\uEE21\\x03\\uEE23\" +\r\n\t\t\"\\x03\\uEE24\\x03\\uEE26\\x03\\uEE26\\x03\\uEE29\\x03\\uEE29\\x03\\uEE2B\\x03\\uEE34\" +\r\n\t\t\"\\x03\\uEE36\\x03\\uEE39\\x03\\uEE3B\\x03\\uEE3B\\x03\\uEE3D\\x03\\uEE3D\\x03\\uEE44\" +\r\n\t\t\"\\x03\\uEE44\\x03\\uEE49\\x03\\uEE49\\x03\\uEE4B\\x03\\uEE4B\\x03\\uEE4D\\x03\\uEE4D\" +\r\n\t\t\"\\x03\\uEE4F\\x03\\uEE51\\x03\\uEE53\\x03\\uEE54\\x03\\uEE56\\x03\\uEE56\\x03\\uEE59\" +\r\n\t\t\"\\x03\\uEE59\\x03\\uEE5B\\x03\\uEE5B\\x03\\uEE5D\\x03\\uEE5D\\x03\\uEE5F\\x03\\uEE5F\" +\r\n\t\t\"\\x03\\uEE61\\x03\\uEE61\\x03\\uEE63\\x03\\uEE64\\x03\\uEE66\\x03\\uEE66\\x03\\uEE69\" +\r\n\t\t\"\\x03\\uEE6C\\x03\\uEE6E\\x03\\uEE74\\x03\\uEE76\\x03\\uEE79\\x03\\uEE7B\\x03\\uEE7E\" +\r\n\t\t\"\\x03\\uEE80\\x03\\uEE80\\x03\\uEE82\\x03\\uEE8B\\x03\\uEE8D\\x03\\uEE9D\\x03\\uEEA3\" +\r\n\t\t\"\\x03\\uEEA5\\x03\\uEEA7\\x03\\uEEAB\\x03\\uEEAD\\x03\\uEEBD\\x03\\x02\\x04\\uA6D8\\x04\" +\r\n\t\t\"\\uA702\\x04\\uB736\\x04\\uB742\\x04\\uB81F\\x04\\uB822\\x04\\uCEA3\\x04\\uF802\\x04\" +\r\n\t\t\"\\uFA1F\\x041\\x02\\x03\\x03\\x02\\x02\\x02\\x02\\x05\\x03\\x02\\x02\\x02\\x02\\x07\\x03\" +\r\n\t\t\"\\x02\\x02\\x02\\x02\\t\\x03\\x02\\x02\\x02\\x02\\v\\x03\\x02\\x02\\x02\\x02\\x11\\x03\\x02\" +\r\n\t\t\"\\x02\\x02\\x03\\x13\\x03\\x02\\x02\\x02\\x05\\x16\\x03\\x02\\x02\\x02\\x07\\x18\\x03\\x02\" +\r\n\t\t\"\\x02\\x02\\t\\x1A\\x03\\x02\\x02\\x02\\v\\x1C\\x03\\x02\\x02\\x02\\r%\\x03\\x02\\x02\\x02\" +\r\n\t\t\"\\x0F\\'\\x03\\x02\\x02\\x02\\x11)\\x03\\x02\\x02\\x02\\x13\\x14\\x071\\x02\\x02\\x14\\x15\" +\r\n\t\t\"\\x071\\x02\\x02\\x15\\x04\\x03\\x02\\x02\\x02\\x16\\x17\\x071\\x02\\x02\\x17\\x06\\x03\" +\r\n\t\t\"\\x02\\x02\\x02\\x18\\x19\\x07,\\x02\\x02\\x19\\b\\x03\\x02\\x02\\x02\\x1A\\x1B\\x07#\\x02\" +\r\n\t\t\"\\x02\\x1B\\n\\x03\\x02\\x02\\x02\\x1C \\x05\\x0F\\b\\x02\\x1D\\x1F\\x05\\r\\x07\\x02\\x1E\" +\r\n\t\t\"\\x1D\\x03\\x02\\x02\\x02\\x1F\\\"\\x03\\x02\\x02\\x02 \\x1E\\x03\\x02\\x02\\x02 !\\x03\" +\r\n\t\t\"\\x02\\x02\\x02!#\\x03\\x02\\x02\\x02\\\" \\x03\\x02\\x02\\x02#$\\b\\x06\\x02\\x02$\\f\\x03\" +\r\n\t\t\"\\x02\\x02\\x02%&\\t\\x02\\x02\\x02&\\x0E\\x03\\x02\\x02\\x02\\'(\\t\\x03\\x02\\x02(\\x10\" +\r\n\t\t\"\\x03\\x02\\x02\\x02)-\\x07)\\x02\\x02*,\\v\\x02\\x02\\x02+*\\x03\\x02\\x02\\x02,/\\x03\" +\r\n\t\t\"\\x02\\x02\\x02-.\\x03\\x02\\x02\\x02-+\\x03\\x02\\x02\\x02.0\\x03\\x02\\x02\\x02/-\\x03\" +\r\n\t\t\"\\x02\\x02\\x0201\\x07)\\x02\\x021\\x12\\x03\\x02\\x02\\x02\\x05\\x02 -\\x03\\x03\\x06\" +\r\n\t\t\"\\x02\";\r\n\tpublic static readonly _serializedATN: string = Utils.join(\r\n\t\t[\r\n\t\t\tXPathLexer._serializedATNSegment0,\r\n\t\t\tXPathLexer._serializedATNSegment1,\r\n\t\t],\r\n\t\t\"\",\r\n\t);\r\n\tpublic static __ATN: ATN;\r\n\tpublic static get _ATN(): ATN {\r\n\t\tif (!XPathLexer.__ATN) {\r\n\t\t\tXPathLexer.__ATN = new ATNDeserializer().deserialize(Utils.toCharArray(XPathLexer._serializedATN));\r\n\t\t}\r\n\r\n\t\treturn XPathLexer.__ATN;\r\n\t}\r\n\r\n}\r\n\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\n\r\nimport { ANTLRErrorListener } from \"../../ANTLRErrorListener\";\r\nimport { Override } from \"../../Decorators\";\r\nimport { Recognizer } from \"../../Recognizer\";\r\nimport { RecognitionException } from \"../../RecognitionException\";\r\n\r\nexport class XPathLexerErrorListener implements ANTLRErrorListener<number> {\r\n\t@Override\r\n\tpublic syntaxError<T extends number>(\r\n\t\trecognizer: Recognizer<T, any>, offendingSymbol: T | undefined,\r\n\t\tline: number, charPositionInLine: number, msg: string,\r\n\t\te: RecognitionException | undefined): void {\r\n\t\t// intentionally empty\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\n\r\nexport abstract class XPathElement {\r\n\tprotected nodeName: string;\r\n\tpublic invert: boolean;\r\n\r\n\t/** Construct element like `/ID` or `ID` or `/*` etc...\r\n\t *  op is null if just node\r\n\t */\r\n\tconstructor(nodeName: string) {\r\n\t\tthis.nodeName = nodeName;\r\n\t\tthis.invert = false;\r\n\t}\r\n\r\n\t/**\r\n\t * Given tree rooted at `t` return all nodes matched by this path\r\n\t * element.\r\n\t */\r\n\tpublic abstract evaluate(t: ParseTree): ParseTree[];\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tlet inv: string = this.invert ? \"!\" : \"\";\r\n\t\tlet className: string = Object.constructor.name;\r\n\t\treturn className + \"[\" + inv + this.nodeName + \"]\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\n/**\r\n * Either `ID` at start of path or `...//ID` in middle of path.\r\n */\r\nexport class XPathRuleAnywhereElement extends XPathElement {\r\n\tprotected ruleIndex: number;\r\n\tconstructor(ruleName: string, ruleIndex: number) {\r\n\t\tsuper(ruleName);\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\treturn Trees.findAllRuleNodes(t, this.ruleIndex);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\nexport class XPathRuleElement extends XPathElement {\r\n\tprotected ruleIndex: number;\r\n\tconstructor(ruleName: string, ruleIndex: number) {\r\n\t\tsuper(ruleName);\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\t// return all children of t that match nodeName\r\n\t\tlet nodes: ParseTree[] = [];\r\n\t\tfor (let c of Trees.getChildren(t)) {\r\n\t\t\tif (c instanceof ParserRuleContext) {\r\n\t\t\t\tif ((c.ruleIndex === this.ruleIndex && !this.invert) ||\r\n\t\t\t\t\t(c.ruleIndex !== this.ruleIndex && this.invert)) {\r\n\t\t\t\t\tnodes.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\nexport class XPathTokenAnywhereElement extends XPathElement {\r\n\tprotected tokenType: number;\r\n\tconstructor(tokenName: string, tokenType: number) {\r\n\t\tsuper(tokenName);\r\n\t\tthis.tokenType = tokenType;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\treturn Trees.findAllTokenNodes(t, this.tokenType);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { TerminalNode } from \"../TerminalNode\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\nexport class XPathTokenElement extends XPathElement {\r\n\tprotected tokenType: number;\r\n\tconstructor(tokenName: string, tokenType: number) {\r\n\t\tsuper(tokenName);\r\n\t\tthis.tokenType = tokenType;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\t// return all children of t that match nodeName\r\n\t\tlet nodes: ParseTree[] = [];\r\n\t\tfor (let c of Trees.getChildren(t)) {\r\n\t\t\tif (c instanceof TerminalNode) {\r\n\t\t\t\tif ((c.symbol.type === this.tokenType && !this.invert) ||\r\n\t\t\t\t\t(c.symbol.type !== this.tokenType && this.invert)) {\r\n\t\t\t\t\tnodes.push(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nodes;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { TerminalNode } from \"../TerminalNode\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPath } from \"./XPath\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\nexport class XPathWildcardAnywhereElement extends XPathElement {\r\n\tconstructor() {\r\n\t\tsuper(XPath.WILDCARD);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\tif (this.invert) {\r\n\t\t\t// !* is weird but valid (empty)\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\treturn Trees.getDescendants(t);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { Override } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { TerminalNode } from \"../TerminalNode\";\r\nimport { Trees } from \"../Trees\";\r\nimport { XPath } from \"./XPath\";\r\nimport { XPathElement } from \"./XPathElement\";\r\n\r\nexport class XPathWildcardElement extends XPathElement {\r\n\tconstructor() {\r\n\t\tsuper(XPath.WILDCARD);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic evaluate(t: ParseTree): ParseTree[] {\r\n\t\tlet kids: ParseTree[] = [];\r\n\t\tif (this.invert) {\r\n\t\t\t// !* is weird but valid (empty)\r\n\t\t\treturn kids;\r\n\t\t}\r\n\t\tfor (let c of Trees.getChildren(t)) {\r\n\t\t\tkids.push(c);\r\n\t\t}\r\n\t\treturn kids;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:46.4373888-07:00\r\n\r\nimport { CharStreams } from \"../../CharStreams\";\r\nimport { CommonTokenStream } from \"../../CommonTokenStream\";\r\nimport { LexerNoViableAltException } from \"../../LexerNoViableAltException\";\r\nimport { Parser } from \"../../Parser\";\r\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { Token } from \"../../Token\";\r\nimport { XPathElement } from \"./XPathElement\";\r\nimport { XPathLexer } from \"./XPathLexer\";\r\nimport { XPathLexerErrorListener } from \"./XPathLexerErrorListener\";\r\nimport { XPathRuleAnywhereElement } from \"./XPathRuleAnywhereElement\";\r\nimport { XPathRuleElement } from \"./XPathRuleElement\";\r\nimport { XPathTokenAnywhereElement } from \"./XPathTokenAnywhereElement\";\r\nimport { XPathTokenElement } from \"./XPathTokenElement\";\r\nimport { XPathWildcardAnywhereElement } from \"./XPathWildcardAnywhereElement\";\r\nimport { XPathWildcardElement } from \"./XPathWildcardElement\";\r\n\r\n/**\r\n * Represent a subset of XPath XML path syntax for use in identifying nodes in\r\n * parse trees.\r\n *\r\n * Split path into words and separators `/` and `//` via ANTLR\r\n * itself then walk path elements from left to right. At each separator-word\r\n * pair, find set of nodes. Next stage uses those as work list.\r\n *\r\n * The basic interface is\r\n * {@link XPath#findAll ParseTree.findAll}`(tree, pathString, parser)`.\r\n * But that is just shorthand for:\r\n *\r\n * ```\r\n * let p = new XPath(parser, pathString);\r\n * return p.evaluate(tree);\r\n * ```\r\n *\r\n * See `TestXPath` for descriptions. In short, this\r\n * allows operators:\r\n *\r\n * | | |\r\n * | --- | --- |\r\n * | `/` | root |\r\n * | `//` | anywhere |\r\n * | `!` | invert; this much appear directly after root or anywhere operator |\r\n *\r\n * and path elements:\r\n *\r\n * | | |\r\n * | --- | --- |\r\n * | `ID` | token name |\r\n * | `'string'` | any string literal token from the grammar |\r\n * | `expr` | rule name |\r\n * | `*` | wildcard matching any node |\r\n *\r\n * Whitespace is not allowed.\r\n */\r\nexport class XPath {\r\n\tpublic static readonly WILDCARD: string = \"*\"; // word not operator/separator\r\n\tpublic static readonly NOT: string = \"!\"; \t   // word for invert operator\r\n\r\n\tprotected path: string;\r\n\tprotected elements: XPathElement[];\r\n\tprotected parser: Parser;\r\n\r\n\tconstructor(parser: Parser, path: string) {\r\n\t\tthis.parser = parser;\r\n\t\tthis.path = path;\r\n\t\tthis.elements = this.split(path);\r\n\t\t// console.log(this.elements.toString());\r\n\t}\r\n\r\n\t// TODO: check for invalid token/rule names, bad syntax\r\n\r\n\tpublic split(path: string): XPathElement[] {\r\n\t\tlet lexer = new XPathLexer(CharStreams.fromString(path));\r\n\t\tlexer.recover = (e: LexerNoViableAltException) => { throw e; };\r\n\r\n\t\tlexer.removeErrorListeners();\r\n\t\tlexer.addErrorListener(new XPathLexerErrorListener());\r\n\t\tlet tokenStream = new CommonTokenStream(lexer);\r\n\t\ttry {\r\n\t\t\ttokenStream.fill();\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\tif (e instanceof LexerNoViableAltException) {\r\n\t\t\t\tlet pos: number = lexer.charPositionInLine;\r\n\t\t\t\tlet msg: string = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\r\n\t\t\t\tthrow new RangeError(msg);\r\n\t\t\t}\r\n\t\t\tthrow e;\r\n\t\t}\r\n\r\n\t\tlet tokens: Token[] = tokenStream.getTokens();\r\n\t\t// console.log(\"path=\" + path + \"=>\" + tokens);\r\n\t\tlet elements: XPathElement[] = [];\r\n\t\tlet n: number = tokens.length;\r\n\t\tlet i: number = 0;\r\n\t\tloop:\r\n\t\twhile (i < n) {\r\n\t\t\tlet el: Token = tokens[i];\r\n\t\t\tlet next: Token | undefined;\r\n\t\t\tswitch (el.type) {\r\n\t\t\t\tcase XPathLexer.ROOT:\r\n\t\t\t\tcase XPathLexer.ANYWHERE:\r\n\t\t\t\t\tlet anywhere: boolean = el.type === XPathLexer.ANYWHERE;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tnext = tokens[i];\r\n\t\t\t\t\tlet invert: boolean = next.type === XPathLexer.BANG;\r\n\t\t\t\t\tif (invert) {\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\tnext = tokens[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet pathElement: XPathElement = this.getXPathElement(next, anywhere);\r\n\t\t\t\t\tpathElement.invert = invert;\r\n\t\t\t\t\telements.push(pathElement);\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase XPathLexer.TOKEN_REF:\r\n\t\t\t\tcase XPathLexer.RULE_REF:\r\n\t\t\t\tcase XPathLexer.WILDCARD:\r\n\t\t\t\t\telements.push(this.getXPathElement(el, false));\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Token.EOF:\r\n\t\t\t\t\tbreak loop;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"Unknowth path element \" + el);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn elements;\r\n\t}\r\n\r\n\t/**\r\n\t * Convert word like `*` or `ID` or `expr` to a path\r\n\t * element. `anywhere` is `true` if `//` precedes the\r\n\t * word.\r\n\t */\r\n\tprotected getXPathElement(wordToken: Token, anywhere: boolean): XPathElement {\r\n\t\tif (wordToken.type === Token.EOF) {\r\n\t\t\tthrow new Error(\"Missing path element at end of path\");\r\n\t\t}\r\n\r\n\t\tlet word = wordToken.text;\r\n\t\tif (word == null) {\r\n\t\t\tthrow new Error(\"Expected wordToken to have text content.\");\r\n\t\t}\r\n\r\n\t\tlet ttype: number = this.parser.getTokenType(word);\r\n\t\tlet ruleIndex: number = this.parser.getRuleIndex(word);\r\n\t\tswitch (wordToken.type) {\r\n\t\t\tcase XPathLexer.WILDCARD:\r\n\t\t\t\treturn anywhere ?\r\n\t\t\t\t\tnew XPathWildcardAnywhereElement() :\r\n\t\t\t\t\tnew XPathWildcardElement();\r\n\t\t\tcase XPathLexer.TOKEN_REF:\r\n\t\t\tcase XPathLexer.STRING:\r\n\t\t\t\tif (ttype === Token.INVALID_TYPE) {\r\n\t\t\t\t\tthrow new Error(word + \" at index \" +\r\n\t\t\t\t\t\twordToken.startIndex +\r\n\t\t\t\t\t\t\" isn't a valid token name\");\r\n\t\t\t\t}\r\n\t\t\t\treturn anywhere ?\r\n\t\t\t\t\tnew XPathTokenAnywhereElement(word, ttype) :\r\n\t\t\t\t\tnew XPathTokenElement(word, ttype);\r\n\t\t\tdefault:\r\n\t\t\t\tif (ruleIndex === -1) {\r\n\t\t\t\t\tthrow new Error(word + \" at index \" +\r\n\t\t\t\t\t\twordToken.startIndex +\r\n\t\t\t\t\t\t\" isn't a valid rule name\");\r\n\t\t\t\t}\r\n\t\t\t\treturn anywhere ?\r\n\t\t\t\t\tnew XPathRuleAnywhereElement(word, ruleIndex) :\r\n\t\t\t\t\tnew XPathRuleElement(word, ruleIndex);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static findAll(tree: ParseTree, xpath: string, parser: Parser): Set<ParseTree> {\r\n\t\tlet p: XPath = new XPath(parser, xpath);\r\n\t\treturn p.evaluate(tree);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a list of all nodes starting at `t` as root that satisfy the\r\n\t * path. The root `/` is relative to the node passed to {@link evaluate}.\r\n\t */\r\n\tpublic evaluate(t: ParseTree): Set<ParseTree> {\r\n\t\tlet dummyRoot = new ParserRuleContext();\r\n\t\tdummyRoot.addChild(t as ParserRuleContext);\r\n\r\n\t\tlet work = new Set<ParseTree>([dummyRoot]);\r\n\r\n\t\tlet i: number = 0;\r\n\t\twhile (i < this.elements.length) {\r\n\t\t\tlet next = new Set<ParseTree>();\r\n\t\t\tfor (let node of work) {\r\n\t\t\t\tif (node.childCount > 0) {\r\n\t\t\t\t\t// only try to match next element if it has children\r\n\t\t\t\t\t// e.g., //func/*/stat might have a token node for which\r\n\t\t\t\t\t// we can't go looking for stat nodes.\r\n\t\t\t\t\tlet matching = this.elements[i].evaluate(node);\r\n\t\t\t\t\tmatching.forEach(next.add, next);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t\twork = next;\r\n\t\t}\r\n\r\n\t\treturn work;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\nimport { NotNull } from \"../../Decorators\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { ParseTreeMatch } from \"./ParseTreeMatch\";\r\nimport { ParseTreePatternMatcher } from \"./ParseTreePatternMatcher\";\r\nimport { XPath } from \"../xpath/XPath\";\r\n\r\n/**\r\n * A pattern like `<ID> = <expr>;` converted to a {@link ParseTree} by\r\n * {@link ParseTreePatternMatcher#compile(String, int)}.\r\n */\r\nexport class ParseTreePattern {\r\n\t/**\r\n\t * This is the backing field for `patternRuleIndex`.\r\n\t */\r\n\tprivate _patternRuleIndex: number;\r\n\r\n\t/**\r\n\t * This is the backing field for `pattern`.\r\n\t */\r\n\t@NotNull\r\n\tprivate _pattern: string;\r\n\r\n\t/**\r\n\t * This is the backing field for `patternTree`.\r\n\t */\r\n\t@NotNull\r\n\tprivate _patternTree: ParseTree;\r\n\r\n\t/**\r\n\t * This is the backing field for `matcher`.\r\n\t */\r\n\t@NotNull\r\n\tprivate _matcher: ParseTreePatternMatcher;\r\n\r\n\t/**\r\n\t * Construct a new instance of the {@link ParseTreePattern} class.\r\n\t *\r\n\t * @param matcher The {@link ParseTreePatternMatcher} which created this\r\n\t * tree pattern.\r\n\t * @param pattern The tree pattern in concrete syntax form.\r\n\t * @param patternRuleIndex The parser rule which serves as the root of the\r\n\t * tree pattern.\r\n\t * @param patternTree The tree pattern in {@link ParseTree} form.\r\n\t */\r\n\tconstructor(\r\n\t\t@NotNull matcher: ParseTreePatternMatcher,\r\n\t\t@NotNull pattern: string,\r\n\t\tpatternRuleIndex: number,\r\n\t\t@NotNull patternTree: ParseTree) {\r\n\t\tthis._matcher = matcher;\r\n\t\tthis._patternRuleIndex = patternRuleIndex;\r\n\t\tthis._pattern = pattern;\r\n\t\tthis._patternTree = patternTree;\r\n\t}\r\n\r\n\t/**\r\n\t * Match a specific parse tree against this tree pattern.\r\n\t *\r\n\t * @param tree The parse tree to match against this tree pattern.\r\n\t * @returns A {@link ParseTreeMatch} object describing the result of the\r\n\t * match operation. The `ParseTreeMatch.succeeded` method can be\r\n\t * used to determine whether or not the match was successful.\r\n\t */\r\n\t@NotNull\r\n\tpublic match(@NotNull tree: ParseTree): ParseTreeMatch {\r\n\t\treturn this._matcher.match(tree, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Determine whether or not a parse tree matches this tree pattern.\r\n\t *\r\n\t * @param tree The parse tree to match against this tree pattern.\r\n\t * @returns `true` if `tree` is a match for the current tree\r\n\t * pattern; otherwise, `false`.\r\n\t */\r\n\tpublic matches(@NotNull tree: ParseTree): boolean {\r\n\t\treturn this._matcher.match(tree, this).succeeded;\r\n\t}\r\n\r\n\t/**\r\n\t * Find all nodes using XPath and then try to match those subtrees against\r\n\t * this tree pattern.\r\n\t *\r\n\t * @param tree The {@link ParseTree} to match against this pattern.\r\n\t * @param xpath An expression matching the nodes\r\n\t *\r\n\t * @returns A collection of {@link ParseTreeMatch} objects describing the\r\n\t * successful matches. Unsuccessful matches are omitted from the result,\r\n\t * regardless of the reason for the failure.\r\n\t */\r\n\t@NotNull\r\n\tpublic findAll(@NotNull tree: ParseTree, @NotNull xpath: string): ParseTreeMatch[] {\r\n\t\tlet subtrees: Set<ParseTree> = XPath.findAll(tree, xpath, this._matcher.parser);\r\n\t\tlet matches: ParseTreeMatch[] = [];\r\n\t\tfor (let t of subtrees) {\r\n\t\t\tlet match: ParseTreeMatch = this.match(t);\r\n\t\t\tif (match.succeeded) {\r\n\t\t\t\tmatches.push(match);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn matches;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the {@link ParseTreePatternMatcher} which created this tree pattern.\r\n\t *\r\n\t * @returns The {@link ParseTreePatternMatcher} which created this tree\r\n\t * pattern.\r\n\t */\r\n\t@NotNull\r\n\tget matcher(): ParseTreePatternMatcher {\r\n\t\treturn this._matcher;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the tree pattern in concrete syntax form.\r\n\t *\r\n\t * @returns The tree pattern in concrete syntax form.\r\n\t */\r\n\t@NotNull\r\n\tget pattern(): string {\r\n\t\treturn this._pattern;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the parser rule which serves as the outermost rule for the tree\r\n\t * pattern.\r\n\t *\r\n\t * @returns The parser rule which serves as the outermost rule for the tree\r\n\t * pattern.\r\n\t */\r\n\tget patternRuleIndex(): number {\r\n\t\treturn this._patternRuleIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the tree pattern as a {@link ParseTree}. The rule and token tags from\r\n\t * the pattern are present in the parse tree as terminal nodes with a symbol\r\n\t * of type {@link RuleTagToken} or {@link TokenTagToken}.\r\n\t *\r\n\t * @returns The tree pattern as a {@link ParseTree}.\r\n\t */\r\n\t@NotNull\r\n\tget patternTree(): ParseTree {\r\n\t\treturn this._patternTree;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:46.0343500-07:00\r\n\r\nimport { CharStream } from \"../../CharStream\";\r\nimport { NotNull, Override } from \"../../Decorators\";\r\nimport { Token } from \"../../Token\";\r\nimport { TokenSource } from \"../../TokenSource\";\r\n\r\n/**\r\n * A {@link Token} object representing an entire subtree matched by a parser\r\n * rule; e.g., `<expr>`. These tokens are created for {@link TagChunk}\r\n * chunks where the tag corresponds to a parser rule.\r\n */\r\nexport class RuleTagToken implements Token {\r\n\t/**\r\n\t * This is the backing field for `ruleName`.\r\n\t */\r\n\tprivate _ruleName: string;\r\n\t/**\r\n\t * The token type for the current token. This is the token type assigned to\r\n\t * the bypass alternative for the rule during ATN deserialization.\r\n\t */\r\n\tprivate bypassTokenType: number;\r\n\t/**\r\n\t * This is the backing field for `label`.\r\n\t */\r\n\tprivate _label?: string;\r\n\r\n\t/**\r\n\t * Constructs a new instance of {@link RuleTagToken} with the specified rule\r\n\t * name, bypass token type, and label.\r\n\t *\r\n\t * @param ruleName The name of the parser rule this rule tag matches.\r\n\t * @param bypassTokenType The bypass token type assigned to the parser rule.\r\n\t * @param label The label associated with the rule tag, or `undefined` if\r\n\t * the rule tag is unlabeled.\r\n\t *\r\n\t * @exception IllegalArgumentException if `ruleName` is not defined\r\n\t * or empty.\r\n\t */\r\n\tconstructor(@NotNull ruleName: string, bypassTokenType: number, label?: string) {\r\n\t\tif (ruleName == null || ruleName.length === 0) {\r\n\t\t\tthrow new Error(\"ruleName cannot be null or empty.\");\r\n\t\t}\r\n\r\n\t\tthis._ruleName = ruleName;\r\n\t\tthis.bypassTokenType = bypassTokenType;\r\n\t\tthis._label = label;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the name of the rule associated with this rule tag.\r\n\t *\r\n\t * @returns The name of the parser rule associated with this rule tag.\r\n\t */\r\n\t@NotNull\r\n\tget ruleName(): string {\r\n\t\treturn this._ruleName;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the label associated with the rule tag.\r\n\t *\r\n\t * @returns The name of the label associated with the rule tag, or\r\n\t * `undefined` if this is an unlabeled rule tag.\r\n\t */\r\n\tget label(): string | undefined {\r\n\t\treturn this._label;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.\r\n\t */\r\n\t@Override\r\n\tget channel(): number {\r\n\t\treturn Token.DEFAULT_CHANNEL;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This method returns the rule tag formatted with `<` and `>`\r\n\t * delimiters.\r\n\t */\r\n\t@Override\r\n\tget text(): string {\r\n\t\tif (this._label != null) {\r\n\t\t\treturn \"<\" + this._label + \":\" + this._ruleName + \">\";\r\n\t\t}\r\n\r\n\t\treturn \"<\" + this._ruleName + \">\";\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * Rule tag tokens have types assigned according to the rule bypass\r\n\t * transitions created during ATN deserialization.\r\n\t */\r\n\t@Override\r\n\tget type(): number {\r\n\t\treturn this.bypassTokenType;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns 0.\r\n\t */\r\n\t@Override\r\n\tget line(): number {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns -1.\r\n\t */\r\n\t@Override\r\n\tget charPositionInLine(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns -1.\r\n\t */\r\n\t@Override\r\n\tget tokenIndex(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns -1.\r\n\t */\r\n\t@Override\r\n\tget startIndex(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns -1.\r\n\t */\r\n\t@Override\r\n\tget stopIndex(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns `undefined`.\r\n\t */\r\n\t@Override\r\n\tget tokenSource(): TokenSource | undefined {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} always returns `undefined`.\r\n\t */\r\n\t@Override\r\n\tget inputStream(): CharStream | undefined {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link RuleTagToken} returns a string of the form\r\n\t * `ruleName:bypassTokenType`.\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this._ruleName + \":\" + this.bypassTokenType;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:45.2799060-07:00\r\n\r\n/**\r\n * A chunk is either a token tag, a rule tag, or a span of literal text within a\r\n * tree pattern.\r\n *\r\n * The method {@link ParseTreePatternMatcher#split(String)} returns a list of\r\n * chunks in preparation for creating a token stream by\r\n * {@link ParseTreePatternMatcher#tokenize(String)}. From there, we get a parse\r\n * tree from with {@link ParseTreePatternMatcher#compile(String, int)}. These\r\n * chunks are converted to {@link RuleTagToken}, {@link TokenTagToken}, or the\r\n * regular tokens of the text surrounding the tags.\r\n */\r\nexport abstract class Chunk {\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:46.1670669-07:00\r\n\r\nimport { Chunk } from \"./Chunk\";\r\nimport { NotNull, Override } from \"../../Decorators\";\r\n\r\n/**\r\n * Represents a placeholder tag in a tree pattern. A tag can have any of the\r\n * following forms.\r\n *\r\n * * `expr`: An unlabeled placeholder for a parser rule `expr`.\r\n * * `ID`: An unlabeled placeholder for a token of type `ID`.\r\n * * `e:expr`: A labeled placeholder for a parser rule `expr`.\r\n * * `id:ID`: A labeled placeholder for a token of type `ID`.\r\n *\r\n * This class does not perform any validation on the tag or label names aside\r\n * from ensuring that the tag is a defined, non-empty string.\r\n */\r\nexport class TagChunk extends Chunk {\r\n\t/**\r\n\t * This is the backing field for `tag`.\r\n\t */\r\n\tprivate _tag: string;\r\n\t/**\r\n\t * This is the backing field for `label`.\r\n\t */\r\n\tprivate _label?: string;\r\n\r\n\t/**\r\n\t * Construct a new instance of {@link TagChunk} using the specified label\r\n\t * and tag.\r\n\t *\r\n\t * @param label The label for the tag. If this is `undefined`, the\r\n\t * {@link TagChunk} represents an unlabeled tag.\r\n\t * @param tag The tag, which should be the name of a parser rule or token\r\n\t * type.\r\n\t *\r\n\t * @exception IllegalArgumentException if `tag` is not defined or\r\n\t * empty.\r\n\t */\r\n\tconstructor(tag: string, label?: string) {\r\n\t\tsuper();\r\n\r\n\t\tif (tag == null || tag.length === 0) {\r\n\t\t\tthrow new Error(\"tag cannot be null or empty\");\r\n\t\t}\r\n\r\n\t\tthis._tag = tag;\r\n\t\tthis._label = label;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the tag for this chunk.\r\n\t *\r\n\t * @returns The tag for the chunk.\r\n\t */\r\n\t@NotNull\r\n\tget tag(): string {\r\n\t\treturn this._tag;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the label, if any, assigned to this chunk.\r\n\t *\r\n\t * @returns The label assigned to this chunk, or `undefined` if no label is\r\n\t * assigned to the chunk.\r\n\t */\r\n\tget label(): string | undefined {\r\n\t\treturn this._label;\r\n\t}\r\n\r\n\t/**\r\n\t * This method returns a text representation of the tag chunk. Labeled tags\r\n\t * are returned in the form `label:tag`, and unlabeled tags are\r\n\t * returned as just the tag name.\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tif (this._label != null) {\r\n\t\t\treturn this._label + \":\" + this._tag;\r\n\t\t}\r\n\r\n\t\treturn this._tag;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:46.2521448-07:00\r\n\r\nimport { Chunk } from \"./Chunk\";\r\nimport { NotNull, Override } from \"../../Decorators\";\r\n\r\n/**\r\n * Represents a span of raw text (concrete syntax) between tags in a tree\r\n * pattern string.\r\n */\r\nexport class TextChunk extends Chunk {\r\n\t/**\r\n\t * This is the backing field for {@link #getText}.\r\n\t */\r\n\t@NotNull\r\n\tprivate _text: string;\r\n\r\n\t/**\r\n\t * Constructs a new instance of {@link TextChunk} with the specified text.\r\n\t *\r\n\t * @param text The text of this chunk.\r\n\t * @exception IllegalArgumentException if `text` is not defined.\r\n\t */\r\n\tconstructor(@NotNull text: string) {\r\n\t\tsuper();\r\n\r\n\t\tif (text == null) {\r\n\t\t\tthrow new Error(\"text cannot be null\");\r\n\t\t}\r\n\r\n\t\tthis._text = text;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the raw text of this chunk.\r\n\t *\r\n\t * @returns The text of the chunk.\r\n\t */\r\n\t@NotNull\r\n\tget text(): string {\r\n\t\treturn this._text;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link TextChunk} returns the result of\r\n\t * `text` in single quotes.\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"'\" + this._text + \"'\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:46.3281988-07:00\r\n\r\nimport { CommonToken } from \"../../CommonToken\";\r\nimport { NotNull, Override } from \"../../Decorators\";\r\n\r\n/**\r\n * A {@link Token} object representing a token of a particular type; e.g.,\r\n * `<ID>`. These tokens are created for {@link TagChunk} chunks where the\r\n * tag corresponds to a lexer rule or token type.\r\n */\r\nexport class TokenTagToken extends CommonToken {\r\n\t/**\r\n\t * This is the backing field for `tokenName`.\r\n\t */\r\n\t@NotNull\r\n\tprivate _tokenName: string;\r\n\t/**\r\n\t * This is the backing field for `label`.\r\n\t */\r\n\tprivate _label: string | undefined;\r\n\r\n\t/**\r\n\t * Constructs a new instance of {@link TokenTagToken} with the specified\r\n\t * token name, type, and label.\r\n\t *\r\n\t * @param tokenName The token name.\r\n\t * @param type The token type.\r\n\t * @param label The label associated with the token tag, or `undefined` if\r\n\t * the token tag is unlabeled.\r\n\t */\r\n\tconstructor(@NotNull tokenName: string, type: number, label?: string) {\r\n\t\tsuper(type);\r\n\t\tthis._tokenName = tokenName;\r\n\t\tthis._label = label;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the token name.\r\n\t * @returns The token name.\r\n\t */\r\n\t@NotNull\r\n\tget tokenName(): string {\r\n\t\treturn this._tokenName;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the label associated with the rule tag.\r\n\t *\r\n\t * @returns The name of the label associated with the rule tag, or\r\n\t * `undefined` if this is an unlabeled rule tag.\r\n\t */\r\n\tget label(): string | undefined {\r\n\t\treturn this._label;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link TokenTagToken} returns the token tag\r\n\t * formatted with `<` and `>` delimiters.\r\n\t */\r\n\t@Override\r\n\tget text(): string {\r\n\t\tif (this._label != null) {\r\n\t\t\treturn \"<\" + this._label + \":\" + this._tokenName + \">\";\r\n\t\t}\r\n\r\n\t\treturn \"<\" + this._tokenName + \">\";\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * The implementation for {@link TokenTagToken} returns a string of the form\r\n\t * `tokenName:type`.\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this._tokenName + \":\" + this.type;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// CONVERSTION complete, Burt Harris 10/14/2016\r\n\r\nimport { BailErrorStrategy } from \"../../BailErrorStrategy\";\r\nimport { CharStreams } from \"../../CharStreams\";\r\nimport { Chunk } from \"./Chunk\";\r\nimport { CommonTokenStream } from \"../../CommonTokenStream\";\r\nimport { Lexer } from \"../../Lexer\";\r\nimport { ListTokenSource } from \"../../ListTokenSource\";\r\nimport { MultiMap } from \"../../misc/MultiMap\";\r\nimport { NotNull } from \"../../Decorators\";\r\nimport { ParseCancellationException } from \"../../misc/ParseCancellationException\";\r\nimport { Parser } from \"../../Parser\";\r\nimport { ParserInterpreter } from \"../../ParserInterpreter\";\r\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\r\nimport { ParseTree } from \"../ParseTree\";\r\nimport { ParseTreeMatch } from \"./ParseTreeMatch\";\r\nimport { ParseTreePattern } from \"./ParseTreePattern\";\r\nimport { RecognitionException } from \"../../RecognitionException\";\r\nimport { RuleNode } from \"../RuleNode\";\r\nimport { RuleTagToken } from \"./RuleTagToken\";\r\nimport { TagChunk } from \"./TagChunk\";\r\nimport { TerminalNode } from \"../TerminalNode\";\r\nimport { TextChunk } from \"./TextChunk\";\r\nimport { Token } from \"../../Token\";\r\nimport { TokenTagToken } from \"./TokenTagToken\";\r\n\r\n/**\r\n * A tree pattern matching mechanism for ANTLR {@link ParseTree}s.\r\n *\r\n * Patterns are strings of source input text with special tags representing\r\n * token or rule references such as:\r\n *\r\n * ```\r\n * <ID> = <expr>;\r\n * ```\r\n *\r\n * Given a pattern start rule such as `statement`, this object constructs\r\n * a {@link ParseTree} with placeholders for the `ID` and `expr`\r\n * subtree. Then the {@link #match} routines can compare an actual\r\n * {@link ParseTree} from a parse with this pattern. Tag `<ID>` matches\r\n * any `ID` token and tag `<expr>` references the result of the\r\n * `expr` rule (generally an instance of `ExprContext`.\r\n *\r\n * Pattern `x = 0;` is a similar pattern that matches the same pattern\r\n * except that it requires the identifier to be `x` and the expression to\r\n * be `0`.\r\n *\r\n * The {@link #matches} routines return `true` or `false` based\r\n * upon a match for the tree rooted at the parameter sent in. The\r\n * {@link #match} routines return a {@link ParseTreeMatch} object that\r\n * contains the parse tree, the parse tree pattern, and a map from tag name to\r\n * matched nodes (more below). A subtree that fails to match, returns with\r\n * {@link ParseTreeMatch#mismatchedNode} set to the first tree node that did not\r\n * match.\r\n *\r\n * For efficiency, you can compile a tree pattern in string form to a\r\n * {@link ParseTreePattern} object.\r\n *\r\n * See `TestParseTreeMatcher` for lots of examples.\r\n * {@link ParseTreePattern} has two static helper methods:\r\n * {@link ParseTreePattern#findAll} and {@link ParseTreePattern#match} that\r\n * are easy to use but not super efficient because they create new\r\n * {@link ParseTreePatternMatcher} objects each time and have to compile the\r\n * pattern in string form before using it.\r\n *\r\n * The lexer and parser that you pass into the {@link ParseTreePatternMatcher}\r\n * constructor are used to parse the pattern in string form. The lexer converts\r\n * the `<ID> = <expr>;` into a sequence of four tokens (assuming lexer\r\n * throws out whitespace or puts it on a hidden channel). Be aware that the\r\n * input stream is reset for the lexer (but not the parser; a\r\n * {@link ParserInterpreter} is created to parse the input.). Any user-defined\r\n * fields you have put into the lexer might get changed when this mechanism asks\r\n * it to scan the pattern string.\r\n *\r\n * Normally a parser does not accept token `<expr>` as a valid\r\n * `expr` but, from the parser passed in, we create a special version of\r\n * the underlying grammar representation (an {@link ATN}) that allows imaginary\r\n * tokens representing rules (`<expr>`) to match entire rules. We call\r\n * these *bypass alternatives*.\r\n *\r\n * Delimiters are `<`} and `>`}, with `\\` as the escape string\r\n * by default, but you can set them to whatever you want using\r\n * {@link #setDelimiters}. You must escape both start and stop strings\r\n * `\\<` and `\\>`.\r\n */\r\nexport class ParseTreePatternMatcher {\r\n\t/**\r\n\t * This is the backing field for `lexer`.\r\n\t */\r\n\tprivate _lexer: Lexer;\r\n\r\n\t/**\r\n\t * This is the backing field for `parser`.\r\n\t */\r\n\tprivate _parser: Parser;\r\n\r\n\tprotected start = \"<\";\r\n\tprotected stop = \">\";\r\n\tprotected escape = \"\\\\\"; // e.g., \\< and \\> must escape BOTH!\r\n\r\n\t/**\r\n\t * Regular expression corresponding to escape, for global replace\r\n\t */\r\n\tprotected escapeRE = /\\\\/g;\r\n\r\n\t/**\r\n\t * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and\r\n\t * {@link Parser} object. The lexer input stream is altered for tokenizing\r\n\t * the tree patterns. The parser is used as a convenient mechanism to get\r\n\t * the grammar name, plus token, rule names.\r\n\t */\r\n\tconstructor(lexer: Lexer, parser: Parser) {\r\n\t\tthis._lexer = lexer;\r\n\t\tthis._parser = parser;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the delimiters used for marking rule and token tags within concrete\r\n\t * syntax used by the tree pattern parser.\r\n\t *\r\n\t * @param start The start delimiter.\r\n\t * @param stop The stop delimiter.\r\n\t * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.\r\n\t *\r\n\t * @throws {@link Error} if `start` is not defined or empty.\r\n\t * @throws {@link Error} if `stop` is not defined or empty.\r\n\t */\r\n\tpublic setDelimiters(start: string, stop: string, escapeLeft: string): void {\r\n\t\tif (!start) {\r\n\t\t\tthrow new Error(\"start cannot be null or empty\");\r\n\t\t}\r\n\r\n\t\tif (!stop) {\r\n\t\t\tthrow new Error(\"stop cannot be null or empty\");\r\n\t\t}\r\n\r\n\t\tthis.start = start;\r\n\t\tthis.stop = stop;\r\n\t\tthis.escape = escapeLeft;\r\n\t\tthis.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\r\n\t}\r\n\r\n\t/** Does `pattern` matched as rule `patternRuleIndex` match `tree`? */\r\n\tpublic matches(tree: ParseTree, pattern: string, patternRuleIndex: number): boolean;\r\n\r\n\t/** Does `pattern` matched as rule patternRuleIndex match tree? Pass in a\r\n\t *  compiled pattern instead of a string representation of a tree pattern.\r\n\t */\r\n\tpublic matches(tree: ParseTree, pattern: ParseTreePattern): boolean;\r\n\r\n\tpublic matches(tree: ParseTree, pattern: string | ParseTreePattern, patternRuleIndex: number = 0): boolean {\r\n\t\tif (typeof pattern === \"string\") {\r\n\t\t\tlet p: ParseTreePattern = this.compile(pattern, patternRuleIndex);\r\n\t\t\treturn this.matches(tree, p);\r\n\t\t} else {\r\n\t\t\tlet labels = new MultiMap<string, ParseTree>();\r\n\t\t\tlet mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\r\n\t\t\treturn !mismatchedNode;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Compare `pattern` matched as rule `patternRuleIndex` against\r\n\t * `tree` and return a {@link ParseTreeMatch} object that contains the\r\n\t * matched elements, or the node at which the match failed.\r\n\t */\r\n\tpublic match(tree: ParseTree, pattern: string, patternRuleIndex: number): ParseTreeMatch;\r\n\r\n\t/**\r\n\t * Compare `pattern` matched against `tree` and return a\r\n\t * {@link ParseTreeMatch} object that contains the matched elements, or the\r\n\t * node at which the match failed. Pass in a compiled pattern instead of a\r\n\t * string representation of a tree pattern.\r\n\t */\r\n\tpublic match(tree: ParseTree, pattern: ParseTreePattern): ParseTreeMatch;\r\n\r\n\t// Implementation of match\r\n\t@NotNull\r\n\tpublic match(tree: ParseTree, @NotNull pattern: string | ParseTreePattern, patternRuleIndex: number = 0): ParseTreeMatch {\r\n\t\tif (typeof pattern === \"string\") {\r\n\t\t\tlet p: ParseTreePattern = this.compile(pattern, patternRuleIndex);\r\n\t\t\treturn this.match(tree, p);\r\n\t\t} else {\r\n\t\t\tlet labels = new MultiMap<string, ParseTree>();\r\n\t\t\tlet mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\r\n\t\t\treturn new ParseTreeMatch(tree, pattern, labels, mismatchedNode);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * For repeated use of a tree pattern, compile it to a\r\n\t * {@link ParseTreePattern} using this method.\r\n\t */\r\n\tpublic compile(pattern: string, patternRuleIndex: number): ParseTreePattern {\r\n\t\tlet tokenList = this.tokenize(pattern);\r\n\t\tlet tokenSrc = new ListTokenSource(tokenList);\r\n\t\tlet tokens = new CommonTokenStream(tokenSrc);\r\n\t\tconst parser = this._parser;\r\n\r\n\t\tlet parserInterp = new ParserInterpreter(\r\n\t\t\tparser.grammarFileName,\r\n\t\t\tparser.vocabulary,\r\n\t\t\tparser.ruleNames,\r\n\t\t\tparser.getATNWithBypassAlts(),\r\n\t\t\ttokens);\r\n\r\n\t\tlet tree: ParseTree;\r\n\t\ttry {\r\n\t\t\tparserInterp.errorHandler = new BailErrorStrategy();\r\n\t\t\ttree = parserInterp.parse(patternRuleIndex);\r\n//\t\t\tSystem.out.println(\"pattern tree = \"+tree.toStringTree(parserInterp));\r\n\t\t} catch (e) {\r\n\t\t\tif (e instanceof ParseCancellationException) {\r\n\t\t\t\tthrow e.getCause();\r\n\t\t\t} else if (e instanceof RecognitionException) {\r\n\t\t\t\tthrow e;\r\n\t\t\t} else if (e instanceof Error) {\r\n\t\t\t\tthrow new ParseTreePatternMatcher.CannotInvokeStartRule(e);\r\n\t\t\t} else {\r\n\t\t\t\tthrow e;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Make sure tree pattern compilation checks for a complete parse\r\n\t\tif (tokens.LA(1) !== Token.EOF) {\r\n\t\t\tthrow new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();\r\n\t\t}\r\n\r\n\t\treturn new ParseTreePattern(this, pattern, patternRuleIndex, tree);\r\n\t}\r\n\r\n\t/**\r\n\t * Used to convert the tree pattern string into a series of tokens. The\r\n\t * input stream is reset.\r\n\t */\r\n\t@NotNull\r\n\tget lexer(): Lexer {\r\n\t\treturn this._lexer;\r\n\t}\r\n\r\n\t/**\r\n\t * Used to collect to the grammar file name, token names, rule names for\r\n\t * used to parse the pattern into a parse tree.\r\n\t */\r\n\t@NotNull\r\n\tget parser(): Parser {\r\n\t\treturn this._parser;\r\n\t}\r\n\r\n\t// ---- SUPPORT CODE ----\r\n\r\n\t/**\r\n\t * Recursively walk `tree` against `patternTree`, filling\r\n\t * `match.`{@link ParseTreeMatch#labels labels}.\r\n\t *\r\n\t * @returns the first node encountered in `tree` which does not match\r\n\t * a corresponding node in `patternTree`, or `undefined` if the match\r\n\t * was successful. The specific node returned depends on the matching\r\n\t * algorithm used by the implementation, and may be overridden.\r\n\t */\r\n\tprotected matchImpl(\r\n\t\t@NotNull tree: ParseTree,\r\n\t\t@NotNull patternTree: ParseTree,\r\n\t\t@NotNull labels: MultiMap<string, ParseTree>): ParseTree | undefined {\r\n\t\tif (!tree) {\r\n\t\t\tthrow new TypeError(\"tree cannot be null\");\r\n\t\t}\r\n\r\n\t\tif (!patternTree) {\r\n\t\t\tthrow new TypeError(\"patternTree cannot be null\");\r\n\t\t}\r\n\r\n\t\t// x and <ID>, x and y, or x and x; or could be mismatched types\r\n\t\tif (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {\r\n\t\t\tlet mismatchedNode: ParseTree | undefined;\r\n\t\t\t// both are tokens and they have same type\r\n\t\t\tif (tree.symbol.type === patternTree.symbol.type) {\r\n\t\t\t\tif (patternTree.symbol instanceof TokenTagToken) { // x and <ID>\r\n\t\t\t\t\tlet tokenTagToken = patternTree.symbol;\r\n\t\t\t\t\t// track label->list-of-nodes for both token name and label (if any)\r\n\t\t\t\t\tlabels.map(tokenTagToken.tokenName, tree);\r\n\t\t\t\t\tconst l = tokenTagToken.label;\r\n\t\t\t\t\tif (l) {\r\n\t\t\t\t\t\tlabels.map(l, tree);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (tree.text === patternTree.text) {\r\n\t\t\t\t\t// x and x\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// x and y\r\n\t\t\t\t\tif (!mismatchedNode) {\r\n\t\t\t\t\t\tmismatchedNode = tree;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (!mismatchedNode) {\r\n\t\t\t\t\tmismatchedNode = tree;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn mismatchedNode;\r\n\t\t}\r\n\r\n\t\tif (tree instanceof ParserRuleContext\r\n\t\t\t&& patternTree instanceof ParserRuleContext) {\r\n\t\t\tlet mismatchedNode: ParseTree | undefined;\r\n\t\t\t// (expr ...) and <expr>\r\n\t\t\tlet ruleTagToken = this.getRuleTagToken(patternTree);\r\n\t\t\tif (ruleTagToken) {\r\n\t\t\t\tlet m: ParseTreeMatch;\r\n\t\t\t\tif (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {\r\n\t\t\t\t\t// track label->list-of-nodes for both rule name and label (if any)\r\n\t\t\t\t\tlabels.map(ruleTagToken.ruleName, tree);\r\n\t\t\t\t\tconst l = ruleTagToken.label;\r\n\t\t\t\t\tif (l) {\r\n\t\t\t\t\t\tlabels.map(l, tree);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (!mismatchedNode) {\r\n\t\t\t\t\t\tmismatchedNode = tree;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn mismatchedNode;\r\n\t\t\t}\r\n\r\n\t\t\t// (expr ...) and (expr ...)\r\n\t\t\tif (tree.childCount !== patternTree.childCount) {\r\n\t\t\t\tif (!mismatchedNode) {\r\n\t\t\t\t\tmismatchedNode = tree;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn mismatchedNode;\r\n\t\t\t}\r\n\r\n\t\t\tlet n: number = tree.childCount;\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\r\n\t\t\t\tif (childMatch) {\r\n\t\t\t\t\treturn childMatch;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn mismatchedNode;\r\n\t\t}\r\n\r\n\t\t// if nodes aren't both tokens or both rule nodes, can't match\r\n\t\treturn tree;\r\n\t}\r\n\r\n\t/** Is `t` `(expr <expr>)` subtree? */\r\n\tprotected getRuleTagToken(t: ParseTree): RuleTagToken | undefined {\r\n\t\tif (t instanceof RuleNode) {\r\n\t\t\tif (t.childCount === 1 && t.getChild(0) instanceof TerminalNode) {\r\n\t\t\t\tlet c = t.getChild(0) as TerminalNode;\r\n\t\t\t\tif (c.symbol instanceof RuleTagToken) {\r\n//\t\t\t\t\tSystem.out.println(\"rule tag subtree \"+t.toStringTree(parser));\r\n\t\t\t\t\treturn c.symbol;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic tokenize(pattern: string): Token[] {\r\n\t\t// split pattern into chunks: sea (raw input) and islands (<ID>, <expr>)\r\n\t\tlet chunks = this.split(pattern);\r\n\r\n\t\t// create token stream from text and tags\r\n\t\tlet tokens: Token[] = [];\r\n\r\n\t\tfor (let chunk of chunks) {\r\n\t\t\tif (chunk instanceof TagChunk) {\r\n\t\t\t\tlet tagChunk = chunk;\r\n\t\t\t\tconst firstChar = tagChunk.tag.substr(0, 1);\r\n\t\t\t\t// add special rule token or conjure up new token from name\r\n\t\t\t\tif (firstChar === firstChar.toUpperCase()) {\r\n\t\t\t\t\tlet ttype: number = this._parser.getTokenType(tagChunk.tag);\r\n\t\t\t\t\tif (ttype === Token.INVALID_TYPE) {\r\n\t\t\t\t\t\tthrow new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet t: TokenTagToken = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);\r\n\t\t\t\t\ttokens.push(t);\r\n\t\t\t\t}\r\n\t\t\t\telse if (firstChar === firstChar.toLowerCase()) {\r\n\t\t\t\t\tlet ruleIndex: number = this._parser.getRuleIndex(tagChunk.tag);\r\n\t\t\t\t\tif (ruleIndex === -1) {\r\n\t\t\t\t\t\tthrow new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet ruleImaginaryTokenType: number = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\r\n\t\t\t\t\ttokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet textChunk = chunk as TextChunk;\r\n\t\t\t\tthis._lexer.inputStream = CharStreams.fromString(textChunk.text);\r\n\t\t\t\tlet t: Token = this._lexer.nextToken();\r\n\t\t\t\twhile (t.type !== Token.EOF) {\r\n\t\t\t\t\ttokens.push(t);\r\n\t\t\t\t\tt = this._lexer.nextToken();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n//\t\tSystem.out.println(\"tokens=\"+tokens);\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\t/** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */\r\n\tpublic split(pattern: string): Chunk[] {\r\n\t\tlet p: number = 0;\r\n\t\tlet n: number = pattern.length;\r\n\t\tlet chunks: Chunk[] = [];\r\n\t\tlet buf: \"\";\r\n\t\t// find all start and stop indexes first, then collect\r\n\t\tlet starts: number[] = [];\r\n\t\tlet stops: number[] = [];\r\n\t\twhile (p < n) {\r\n\t\t\tif (p === pattern.indexOf(this.escape + this.start, p)) {\r\n\t\t\t\tp += this.escape.length + this.start.length;\r\n\t\t\t}\r\n\t\t\telse if (p === pattern.indexOf(this.escape + this.stop, p)) {\r\n\t\t\t\tp += this.escape.length + this.stop.length;\r\n\t\t\t}\r\n\t\t\telse if (p === pattern.indexOf(this.start, p)) {\r\n\t\t\t\tstarts.push(p);\r\n\t\t\t\tp += this.start.length;\r\n\t\t\t}\r\n\t\t\telse if (p === pattern.indexOf(this.stop, p)) {\r\n\t\t\t\tstops.push(p);\r\n\t\t\t\tp += this.stop.length;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tp++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n//\t\tSystem.out.println(\"\");\r\n//\t\tSystem.out.println(starts);\r\n//\t\tSystem.out.println(stops);\r\n\t\tif (starts.length > stops.length) {\r\n\t\t\tthrow new Error(\"unterminated tag in pattern: \" + pattern);\r\n\t\t}\r\n\r\n\t\tif (starts.length < stops.length) {\r\n\t\t\tthrow new Error(\"missing start tag in pattern: \" + pattern);\r\n\t\t}\r\n\r\n\t\tlet ntags: number = starts.length;\r\n\t\tfor (let i = 0; i < ntags; i++) {\r\n\t\t\tif (starts[i] >= stops[i]) {\r\n\t\t\t\tthrow new Error(\"tag delimiters out of order in pattern: \" + pattern);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// collect into chunks now\r\n\t\tif (ntags === 0) {\r\n\t\t\tlet text: string = pattern.substring(0, n);\r\n\t\t\tchunks.push(new TextChunk(text));\r\n\t\t}\r\n\r\n\t\tif (ntags > 0 && starts[0] > 0) { // copy text up to first tag into chunks\r\n\t\t\tlet text: string = pattern.substring(0, starts[0]);\r\n\t\t\tchunks.push(new TextChunk(text));\r\n\t\t}\r\n\t\tfor (let i = 0; i < ntags; i++) {\r\n\t\t\t// copy inside of <tag>\r\n\t\t\tlet tag: string = pattern.substring(starts[i] + this.start.length, stops[i]);\r\n\t\t\tlet ruleOrToken: string = tag;\r\n\t\t\tlet label: string | undefined;\r\n\t\t\tlet colon: number = tag.indexOf(\":\");\r\n\t\t\tif (colon >= 0) {\r\n\t\t\t\tlabel = tag.substring(0, colon);\r\n\t\t\t\truleOrToken = tag.substring(colon + 1, tag.length);\r\n\t\t\t}\r\n\t\t\tchunks.push(new TagChunk(ruleOrToken, label));\r\n\t\t\tif (i + 1 < ntags) {\r\n\t\t\t\t// copy from end of <tag> to start of next\r\n\t\t\t\tlet text: string = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\r\n\t\t\t\tchunks.push(new TextChunk(text));\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ntags > 0) {\r\n\t\t\tlet afterLastTag: number = stops[ntags - 1] + this.stop.length;\r\n\t\t\tif (afterLastTag < n) { // copy text from end of last tag to end\r\n\t\t\t\tlet text: string = pattern.substring(afterLastTag, n);\r\n\t\t\t\tchunks.push(new TextChunk(text));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// strip out the escape sequences from text chunks but not tags\r\n\t\tfor (let i = 0; i < chunks.length; i++) {\r\n\t\t\tlet c: Chunk = chunks[i];\r\n\t\t\tif (c instanceof TextChunk) {\r\n\t\t\t\tlet unescaped: string = c.text.replace(this.escapeRE, \"\");\r\n\t\t\t\tif (unescaped.length < c.text.length) {\r\n\t\t\t\t\tchunks[i] = new TextChunk(unescaped);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn chunks;\r\n\t}\r\n}\r\n\r\nexport namespace ParseTreePatternMatcher {\r\n\texport class CannotInvokeStartRule extends Error {\r\n\t\tpublic constructor(public error: Error) {\r\n\t\t\tsuper(`CannotInvokeStartRule: ${error}`);\r\n\t\t}\r\n\t}\r\n\r\n\t// Fixes https://github.com/antlr/antlr4/issues/413\r\n\t// \"Tree pattern compilation doesn't check for a complete parse\"\r\n\texport class StartRuleDoesNotConsumeFullPattern extends Error {\r\n\t\tconstructor() {\r\n\t\t\tsuper(\"StartRuleDoesNotConsumeFullPattern\");\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.2401032-07:00\r\n\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This is the base class for gathering detailed information about prediction\r\n * events which occur during parsing.\r\n *\r\n * Note that we could record the parser call stack at the time this event\r\n * occurred but in the presence of left recursive rules, the stack is kind of\r\n * meaningless. It's better to look at the individual configurations for their\r\n * individual stacks. Of course that is a {@link PredictionContext} object\r\n * not a parse tree node and so it does not have information about the extent\r\n * (start...stop) of the various subtrees. Examining the stack tops of all\r\n * configurations provide the return states for the rule invocations.\r\n * From there you can get the enclosing rule.\r\n *\r\n * @since 4.3\r\n */\r\nexport class DecisionEventInfo {\r\n\t/**\r\n\t * The invoked decision number which this event is related to.\r\n\t *\r\n\t * @see ATN#decisionToState\r\n\t */\r\n\tpublic decision: number;\r\n\r\n\t/**\r\n\t * The simulator state containing additional information relevant to the\r\n\t * prediction state when the current event occurred, or `undefined` if no\r\n\t * additional information is relevant or available.\r\n\t */\r\n\tpublic state: SimulatorState | undefined;\r\n\r\n\t/**\r\n\t * The input token stream which is being parsed.\r\n\t */\r\n\t@NotNull\r\n\tpublic input: TokenStream;\r\n\r\n\t/**\r\n\t * The token index in the input stream at which the current prediction was\r\n\t * originally invoked.\r\n\t */\r\n\tpublic startIndex: number;\r\n\r\n\t/**\r\n\t * The token index in the input stream at which the current event occurred.\r\n\t */\r\n\tpublic stopIndex: number;\r\n\r\n\t/**\r\n\t * `true` if the current event occurred during LL prediction;\r\n\t * otherwise, `false` if the input occurred during SLL prediction.\r\n\t */\r\n\tpublic fullCtx: boolean;\r\n\r\n\tconstructor(\r\n\t\tdecision: number,\r\n\t\tstate: SimulatorState | undefined,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tfullCtx: boolean) {\r\n\r\n\t\tthis.decision = decision;\r\n\t\tthis.fullCtx = fullCtx;\r\n\t\tthis.stopIndex = stopIndex;\r\n\t\tthis.input = input;\r\n\t\tthis.startIndex = startIndex;\r\n\t\tthis.state = state;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:24.8229279-07:00\r\n\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This class represents profiling event information for an ambiguity.\r\n * Ambiguities are decisions where a particular input resulted in an SLL\r\n * conflict, followed by LL prediction also reaching a conflict state\r\n * (indicating a true ambiguity in the grammar).\r\n *\r\n * This event may be reported during SLL prediction in cases where the\r\n * conflicting SLL configuration set provides sufficient information to\r\n * determine that the SLL conflict is truly an ambiguity. For example, if none\r\n * of the ATN configurations in the conflicting SLL configuration set have\r\n * traversed a global follow transition (i.e.\r\n * {@link ATNConfig#getReachesIntoOuterContext} is `false` for all\r\n * configurations), then the result of SLL prediction for that input is known to\r\n * be equivalent to the result of LL prediction for that input.\r\n *\r\n * In some cases, the minimum represented alternative in the conflicting LL\r\n * configuration set is not equal to the minimum represented alternative in the\r\n * conflicting SLL configuration set. Grammars and inputs which result in this\r\n * scenario are unable to use {@link PredictionMode#SLL}, which in turn means\r\n * they cannot use the two-stage parsing strategy to improve parsing performance\r\n * for that input.\r\n *\r\n * @see ParserATNSimulator#reportAmbiguity\r\n * @see ParserErrorListener#reportAmbiguity\r\n *\r\n * @since 4.3\r\n */\r\nexport class AmbiguityInfo extends DecisionEventInfo {\r\n\t/** The set of alternative numbers for this decision event that lead to a valid parse. */\r\n\t@NotNull\r\n\tprivate ambigAlts: BitSet;\r\n\r\n\t/**\r\n\t * Constructs a new instance of the {@link AmbiguityInfo} class with the\r\n\t * specified detailed ambiguity information.\r\n\t *\r\n\t * @param decision The decision number\r\n\t * @param state The final simulator state identifying the ambiguous\r\n\t * alternatives for the current input\r\n\t * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.\r\n\t *                  The predicted alt is the min(ambigAlts)\r\n\t * @param input The input token stream\r\n\t * @param startIndex The start index for the current prediction\r\n\t * @param stopIndex The index at which the ambiguity was identified during\r\n\t * prediction\r\n\t */\r\n\tconstructor(\r\n\t\tdecision: number,\r\n\t\t@NotNull state: SimulatorState,\r\n\t\t@NotNull ambigAlts: BitSet,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number) {\r\n\t\tsuper(decision, state, input, startIndex, stopIndex, state.useContext);\r\n\t\tthis.ambigAlts = ambigAlts;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the set of alternatives in the decision that lead to a valid parse.\r\n\t *\r\n\t * @since 4.5\r\n\t */\r\n\t@NotNull\r\n\tget ambiguousAlternatives(): BitSet {\r\n\t\treturn this.ambigAlts;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.1575933-07:00\r\n\r\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This class represents profiling event information for a context sensitivity.\r\n * Context sensitivities are decisions where a particular input resulted in an\r\n * SLL conflict, but LL prediction produced a single unique alternative.\r\n *\r\n * In some cases, the unique alternative identified by LL prediction is not\r\n * equal to the minimum represented alternative in the conflicting SLL\r\n * configuration set. Grammars and inputs which result in this scenario are\r\n * unable to use {@link PredictionMode#SLL}, which in turn means they cannot use\r\n * the two-stage parsing strategy to improve parsing performance for that\r\n * input.\r\n *\r\n * @see ParserATNSimulator#reportContextSensitivity\r\n * @see ParserErrorListener#reportContextSensitivity\r\n *\r\n * @since 4.3\r\n */\r\nexport class ContextSensitivityInfo extends DecisionEventInfo {\r\n\t/**\r\n\t * Constructs a new instance of the {@link ContextSensitivityInfo} class\r\n\t * with the specified detailed context sensitivity information.\r\n\t *\r\n\t * @param decision The decision number\r\n\t * @param state The final simulator state containing the unique\r\n\t * alternative identified by full-context prediction\r\n\t * @param input The input token stream\r\n\t * @param startIndex The start index for the current prediction\r\n\t * @param stopIndex The index at which the context sensitivity was\r\n\t * identified during full-context prediction\r\n\t */\r\n\tconstructor(\r\n\t\tdecision: number,\r\n\t\t@NotNull state: SimulatorState,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number) {\r\n\r\n\t\tsuper(decision, state, input, startIndex, stopIndex, true);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.3330673-07:00\r\n\r\nimport { AmbiguityInfo } from \"./AmbiguityInfo\";\r\nimport { ContextSensitivityInfo } from \"./ContextSensitivityInfo\";\r\nimport { ErrorInfo } from \"./ErrorInfo\";\r\nimport { LookaheadEventInfo } from \"./LookaheadEventInfo\";\r\nimport { Override } from \"../Decorators\";\r\nimport { PredicateEvalInfo } from \"./PredicateEvalInfo\";\r\n\r\n/**\r\n * This class contains profiling gathered for a particular decision.\r\n *\r\n * Parsing performance in ANTLR 4 is heavily influenced by both static factors\r\n * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the\r\n * choice of input and the state of the DFA cache at the time profiling\r\n * operations are started). For best results, gather and use aggregate\r\n * statistics from a large sample of inputs representing the inputs expected in\r\n * production before using the results to make changes in the grammar.\r\n *\r\n * @since 4.3\r\n */\r\nexport class DecisionInfo {\r\n\t/**\r\n\t * The decision number, which is an index into {@link ATN#decisionToState}.\r\n\t */\r\n\tpublic decision: number;\r\n\r\n\t/**\r\n\t * The total number of times {@link ParserATNSimulator#adaptivePredict} was\r\n\t * invoked for this decision.\r\n\t */\r\n\tpublic invocations: number = 0;\r\n\r\n\t/**\r\n\t * The total time spent in {@link ParserATNSimulator#adaptivePredict} for\r\n\t * this decision, in nanoseconds.\r\n\t *\r\n\t * The value of this field contains the sum of differential results obtained\r\n\t * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT\r\n\t * and/or garbage collection overhead. For best accuracy, use a modern JVM\r\n\t * implementation that provides precise results from\r\n\t * {@link System#nanoTime()}, and perform profiling in a separate process\r\n\t * which is warmed up by parsing the input prior to profiling. If desired,\r\n\t * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\r\n\t * state before starting the profiling measurement pass.\r\n\t */\r\n\tpublic timeInPrediction: number = 0;\r\n\r\n\t/**\r\n\t * The sum of the lookahead required for SLL prediction for this decision.\r\n\t * Note that SLL prediction is used before LL prediction for performance\r\n\t * reasons even when {@link PredictionMode#LL} or\r\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\r\n\t */\r\n\tpublic SLL_TotalLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the minimum lookahead required for any single SLL prediction to\r\n\t * complete for this decision, by reaching a unique prediction, reaching an\r\n\t * SLL conflict state, or encountering a syntax error.\r\n\t */\r\n\tpublic SLL_MinLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the maximum lookahead required for any single SLL prediction to\r\n\t * complete for this decision, by reaching a unique prediction, reaching an\r\n\t * SLL conflict state, or encountering a syntax error.\r\n\t */\r\n\tpublic SLL_MaxLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\r\n\t * {@link #SLL_MaxLook} value was set.\r\n\t */\r\n\tpublic SLL_MaxLookEvent?: LookaheadEventInfo;\r\n\r\n\t/**\r\n\t * The sum of the lookahead required for LL prediction for this decision.\r\n\t * Note that LL prediction is only used when SLL prediction reaches a\r\n\t * conflict state.\r\n\t */\r\n\tpublic LL_TotalLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the minimum lookahead required for any single LL prediction to\r\n\t * complete for this decision. An LL prediction completes when the algorithm\r\n\t * reaches a unique prediction, a conflict state (for\r\n\t * {@link PredictionMode#LL}, an ambiguity state (for\r\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\r\n\t */\r\n\tpublic LL_MinLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the maximum lookahead required for any single LL prediction to\r\n\t * complete for this decision. An LL prediction completes when the algorithm\r\n\t * reaches a unique prediction, a conflict state (for\r\n\t * {@link PredictionMode#LL}, an ambiguity state (for\r\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\r\n\t */\r\n\tpublic LL_MaxLook: number = 0;\r\n\r\n\t/**\r\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\r\n\t * {@link #LL_MaxLook} value was set.\r\n\t */\r\n\tpublic LL_MaxLookEvent?: LookaheadEventInfo;\r\n\r\n\t/**\r\n\t * A collection of {@link ContextSensitivityInfo} instances describing the\r\n\t * context sensitivities encountered during LL prediction for this decision.\r\n\t *\r\n\t * @see ContextSensitivityInfo\r\n\t */\r\n\tpublic contextSensitivities: ContextSensitivityInfo[] = [];\r\n\r\n\t/**\r\n\t * A collection of {@link ErrorInfo} instances describing the parse errors\r\n\t * identified during calls to {@link ParserATNSimulator#adaptivePredict} for\r\n\t * this decision.\r\n\t *\r\n\t * @see ErrorInfo\r\n\t */\r\n\tpublic errors: ErrorInfo[] = [];\r\n\r\n\t/**\r\n\t * A collection of {@link AmbiguityInfo} instances describing the\r\n\t * ambiguities encountered during LL prediction for this decision.\r\n\t *\r\n\t * @see AmbiguityInfo\r\n\t */\r\n\tpublic ambiguities: AmbiguityInfo[] = [];\r\n\r\n\t/**\r\n\t * A collection of {@link PredicateEvalInfo} instances describing the\r\n\t * results of evaluating individual predicates during prediction for this\r\n\t * decision.\r\n\t *\r\n\t * @see PredicateEvalInfo\r\n\t */\r\n\tpublic predicateEvals: PredicateEvalInfo[] = [];\r\n\r\n\t/**\r\n\t * The total number of ATN transitions required during SLL prediction for\r\n\t * this decision. An ATN transition is determined by the number of times the\r\n\t * DFA does not contain an edge that is required for prediction, resulting\r\n\t * in on-the-fly computation of that edge.\r\n\t *\r\n\t * If DFA caching of SLL transitions is employed by the implementation, ATN\r\n\t * computation may cache the computed edge for efficient lookup during\r\n\t * future parsing of this decision. Otherwise, the SLL parsing algorithm\r\n\t * will use ATN transitions exclusively.\r\n\t *\r\n\t * @see #SLL_ATNTransitions\r\n\t * @see ParserATNSimulator#computeTargetState\r\n\t * @see LexerATNSimulator#computeTargetState\r\n\t */\r\n\tpublic SLL_ATNTransitions: number = 0;\r\n\r\n\t/**\r\n\t * The total number of DFA transitions required during SLL prediction for\r\n\t * this decision.\r\n\t *\r\n\t * If the ATN simulator implementation does not use DFA caching for SLL\r\n\t * transitions, this value will be 0.\r\n\t *\r\n\t * @see ParserATNSimulator#getExistingTargetState\r\n\t * @see LexerATNSimulator#getExistingTargetState\r\n\t */\r\n\tpublic SLL_DFATransitions: number = 0;\r\n\r\n\t/**\r\n\t * Gets the total number of times SLL prediction completed in a conflict\r\n\t * state, resulting in fallback to LL prediction.\r\n\t *\r\n\t * Note that this value is not related to whether or not\r\n\t * {@link PredictionMode#SLL} may be used successfully with a particular\r\n\t * grammar. If the ambiguity resolution algorithm applied to the SLL\r\n\t * conflicts for this decision produce the same result as LL prediction for\r\n\t * this decision, {@link PredictionMode#SLL} would produce the same overall\r\n\t * parsing result as {@link PredictionMode#LL}.\r\n\t */\r\n\tpublic LL_Fallback: number = 0;\r\n\r\n\t/**\r\n\t * The total number of ATN transitions required during LL prediction for\r\n\t * this decision. An ATN transition is determined by the number of times the\r\n\t * DFA does not contain an edge that is required for prediction, resulting\r\n\t * in on-the-fly computation of that edge.\r\n\t *\r\n\t * If DFA caching of LL transitions is employed by the implementation, ATN\r\n\t * computation may cache the computed edge for efficient lookup during\r\n\t * future parsing of this decision. Otherwise, the LL parsing algorithm will\r\n\t * use ATN transitions exclusively.\r\n\t *\r\n\t * @see #LL_DFATransitions\r\n\t * @see ParserATNSimulator#computeTargetState\r\n\t * @see LexerATNSimulator#computeTargetState\r\n\t */\r\n\tpublic LL_ATNTransitions: number = 0;\r\n\r\n\t/**\r\n\t * The total number of DFA transitions required during LL prediction for\r\n\t * this decision.\r\n\t *\r\n\t * If the ATN simulator implementation does not use DFA caching for LL\r\n\t * transitions, this value will be 0.\r\n\t *\r\n\t * @see ParserATNSimulator#getExistingTargetState\r\n\t * @see LexerATNSimulator#getExistingTargetState\r\n\t */\r\n\tpublic LL_DFATransitions: number = 0;\r\n\r\n\t/**\r\n\t * Constructs a new instance of the {@link DecisionInfo} class to contain\r\n\t * statistics for a particular decision.\r\n\t *\r\n\t * @param decision The decision number\r\n\t */\r\n\tconstructor(decision: number) {\r\n\t\tthis.decision = decision;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"{\" +\r\n\t\t\t\"decision=\" + this.decision +\r\n\t\t\t\", contextSensitivities=\" + this.contextSensitivities.length +\r\n\t\t\t\", errors=\" + this.errors.length +\r\n\t\t\t\", ambiguities=\" + this.ambiguities.length +\r\n\t\t\t\", SLL_lookahead=\" + this.SLL_TotalLook +\r\n\t\t\t\", SLL_ATNTransitions=\" + this.SLL_ATNTransitions +\r\n\t\t\t\", SLL_DFATransitions=\" + this.SLL_DFATransitions +\r\n\t\t\t\", LL_Fallback=\" + this.LL_Fallback +\r\n\t\t\t\", LL_lookahead=\" + this.LL_TotalLook +\r\n\t\t\t\", LL_ATNTransitions=\" + this.LL_ATNTransitions +\r\n\t\t\t\"}\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.7213647-07:00\r\n\r\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This class represents profiling event information for a syntax error\r\n * identified during prediction. Syntax errors occur when the prediction\r\n * algorithm is unable to identify an alternative which would lead to a\r\n * successful parse.\r\n *\r\n * @see Parser#notifyErrorListeners(Token, String, RecognitionException)\r\n * @see ANTLRErrorListener#syntaxError\r\n *\r\n * @since 4.3\r\n */\r\nexport class ErrorInfo extends DecisionEventInfo {\r\n\t/**\r\n\t * Constructs a new instance of the {@link ErrorInfo} class with the\r\n\t * specified detailed syntax error information.\r\n\t *\r\n\t * @param decision The decision number\r\n\t * @param state The final simulator state reached during prediction\r\n\t * prior to reaching the {@link ATNSimulator#ERROR} state\r\n\t * @param input The input token stream\r\n\t * @param startIndex The start index for the current prediction\r\n\t * @param stopIndex The index at which the syntax error was identified\r\n\t */\r\n\tconstructor(\r\n\t\tdecision: number,\r\n\t\t@NotNull state: SimulatorState,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number) {\r\n\r\n\t\tsuper(decision, state, input, startIndex, stopIndex, state.useContext);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.6852565-07:00\r\n\r\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This class represents profiling event information for tracking the lookahead\r\n * depth required in order to make a prediction.\r\n *\r\n * @since 4.3\r\n */\r\nexport class LookaheadEventInfo extends DecisionEventInfo {\r\n\t/** The alternative chosen by adaptivePredict(), not necessarily\r\n\t *  the outermost alt shown for a rule; left-recursive rules have\r\n\t *  user-level alts that differ from the rewritten rule with a (...) block\r\n\t *  and a (..)* loop.\r\n\t */\r\n\tpublic predictedAlt: number;\r\n\r\n\t/**\r\n\t * Constructs a new instance of the {@link LookaheadEventInfo} class with\r\n\t * the specified detailed lookahead information.\r\n\t *\r\n\t * @param decision The decision number\r\n\t * @param state The final simulator state containing the necessary\r\n\t * information to determine the result of a prediction, or `undefined` if\r\n\t * the final state is not available\r\n\t * @param input The input token stream\r\n\t * @param startIndex The start index for the current prediction\r\n\t * @param stopIndex The index at which the prediction was finally made\r\n\t * @param fullCtx `true` if the current lookahead is part of an LL\r\n\t * prediction; otherwise, `false` if the current lookahead is part of\r\n\t * an SLL prediction\r\n\t */\r\n\tconstructor(\r\n\t\tdecision: number,\r\n\t\tstate: SimulatorState | undefined,\r\n\t\tpredictedAlt: number,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\tfullCtx: boolean) {\r\n\r\n\t\tsuper(decision, state, input, startIndex, stopIndex, fullCtx);\r\n\t\tthis.predictedAlt = predictedAlt;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.1914305-07:00\r\n\r\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * This class represents profiling event information for semantic predicate\r\n * evaluations which occur during prediction.\r\n *\r\n * @see ParserATNSimulator#evalSemanticContext\r\n *\r\n * @since 4.3\r\n */\r\nexport class PredicateEvalInfo extends DecisionEventInfo {\r\n\t/**\r\n\t * The semantic context which was evaluated.\r\n\t */\r\n\tpublic semctx: SemanticContext;\r\n\t/**\r\n\t * The alternative number for the decision which is guarded by the semantic\r\n\t * context {@link #semctx}. Note that other ATN\r\n\t * configurations may predict the same alternative which are guarded by\r\n\t * other semantic contexts and/or {@link SemanticContext#NONE}.\r\n\t */\r\n\tpublic predictedAlt: number;\r\n\t/**\r\n\t * The result of evaluating the semantic context {@link #semctx}.\r\n\t */\r\n\tpublic evalResult: boolean;\r\n\r\n\t/**\r\n\t * Constructs a new instance of the {@link PredicateEvalInfo} class with the\r\n\t * specified detailed predicate evaluation information.\r\n\t *\r\n\t * @param state The simulator state\r\n\t * @param decision The decision number\r\n\t * @param input The input token stream\r\n\t * @param startIndex The start index for the current prediction\r\n\t * @param stopIndex The index at which the predicate evaluation was\r\n\t * triggered. Note that the input stream may be reset to other positions for\r\n\t * the actual evaluation of individual predicates.\r\n\t * @param semctx The semantic context which was evaluated\r\n\t * @param evalResult The results of evaluating the semantic context\r\n\t * @param predictedAlt The alternative number for the decision which is\r\n\t * guarded by the semantic context `semctx`. See {@link #predictedAlt}\r\n\t * for more information.\r\n\t *\r\n\t * @see ParserATNSimulator#evalSemanticContext(SemanticContext, ParserRuleContext, int)\r\n\t * @see SemanticContext#eval(Recognizer, RuleContext)\r\n\t */\r\n\tconstructor(\r\n\t\t@NotNull state: SimulatorState,\r\n\t\tdecision: number,\r\n\t\t@NotNull input: TokenStream,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number,\r\n\t\t@NotNull semctx: SemanticContext,\r\n\t\tevalResult: boolean,\r\n\t\tpredictedAlt: number) {\r\n\r\n\t\tsuper(decision, state, input, startIndex, stopIndex, state.useContext);\r\n\t\tthis.semctx = semctx;\r\n\t\tthis.evalResult = evalResult;\r\n\t\tthis.predictedAlt = predictedAlt;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00\r\n\r\nimport { AmbiguityInfo } from \"./AmbiguityInfo\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { ATNSimulator } from \"./ATNSimulator\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { ContextSensitivityInfo } from \"./ContextSensitivityInfo\";\r\nimport { DecisionInfo } from \"./DecisionInfo\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { DFAState } from \"../dfa/DFAState\";\r\nimport { ErrorInfo } from \"./ErrorInfo\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { LookaheadEventInfo } from \"./LookaheadEventInfo\";\r\nimport { Parser } from \"../Parser\";\r\nimport { ParserATNSimulator } from \"./ParserATNSimulator\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\nimport { PredicateEvalInfo } from \"./PredicateEvalInfo\";\r\nimport { PredictionContextCache } from \"./PredictionContextCache\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\nimport { SimulatorState } from \"./SimulatorState\";\r\nimport { TokenStream } from \"../TokenStream\";\r\n\r\n/**\r\n * @since 4.3\r\n */\r\nexport class ProfilingATNSimulator extends ParserATNSimulator {\r\n\tprotected decisions: DecisionInfo[];\r\n\tprotected numDecisions: number;\r\n\r\n\tprotected _input: TokenStream | undefined;\r\n\tprotected _startIndex: number = 0;\r\n\tprotected _sllStopIndex: number = 0;\r\n\tprotected _llStopIndex: number = 0;\r\n\r\n\tprotected currentDecision: number = 0;\r\n\tprotected currentState: SimulatorState | undefined;\r\n\r\n\t/** At the point of LL failover, we record how SLL would resolve the conflict so that\r\n\t *  we can determine whether or not a decision / input pair is context-sensitive.\r\n\t *  If LL gives a different result than SLL's predicted alternative, we have a\r\n\t *  context sensitivity for sure. The converse is not necessarily true, however.\r\n\t *  It's possible that after conflict resolution chooses minimum alternatives,\r\n\t *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\r\n\t *  an ambiguity, it is not treated as a context sensitivity because LL prediction\r\n\t *  was not required in order to produce a correct prediction for this decision and input sequence.\r\n\t *  It may in fact still be a context sensitivity but we don't know by looking at the\r\n\t *  minimum alternatives for the current input.\r\n\t */\r\n\tprotected conflictingAltResolvedBySLL: number = 0;\r\n\r\n\tconstructor(parser: Parser) {\r\n\t\tsuper(parser.interpreter.atn, parser);\r\n\t\tthis.optimize_ll1 = false;\r\n\t\tthis.reportAmbiguities = true;\r\n\t\tthis.numDecisions = this.atn.decisionToState.length;\r\n\t\tthis.decisions = [];\r\n\t\tfor (let i = 0; i < this.numDecisions; i++) {\r\n\t\t\tthis.decisions.push(new DecisionInfo(i));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined): number;\r\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined, useContext: boolean): number;\r\n\t@Override\r\n\tpublic adaptivePredict(\r\n\t\t@NotNull input: TokenStream,\r\n\t\tdecision: number,\r\n\t\touterContext: ParserRuleContext | undefined,\r\n\t\tuseContext?: boolean): number {\r\n\t\tif (useContext !== undefined) {\r\n\t\t\treturn super.adaptivePredict(input, decision, outerContext, useContext);\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tthis._input = input;\r\n\t\t\tthis._startIndex = input.index;\r\n\t\t\t// it's possible for SLL to reach a conflict state without consuming any input\r\n\t\t\tthis._sllStopIndex = this._startIndex - 1;\r\n\t\t\tthis._llStopIndex = -1;\r\n\t\t\tthis.currentDecision = decision;\r\n\t\t\tthis.currentState = undefined;\r\n\t\t\tthis.conflictingAltResolvedBySLL = ATN.INVALID_ALT_NUMBER;\r\n\t\t\tlet start: number[] = process.hrtime();\r\n\t\t\tlet alt: number = super.adaptivePredict(input, decision, outerContext);\r\n\t\t\tlet stop: number[] = process.hrtime();\r\n\r\n\t\t\tlet nanoseconds: number = (stop[0] - start[0]) * 1000000000;\r\n\t\t\tif (nanoseconds === 0) {\r\n\t\t\t\tnanoseconds = stop[1] - start[1];\r\n\t\t\t} else {\r\n\t\t\t\t// Add nanoseconds from start to end of that second, plus start of the end second to end\r\n\t\t\t\tnanoseconds += (1000000000 - start[1]) + stop[1];\r\n\t\t\t}\r\n\r\n\t\t\tthis.decisions[decision].timeInPrediction += nanoseconds;\r\n\t\t\tthis.decisions[decision].invocations++;\r\n\r\n\t\t\tlet SLL_k: number = this._sllStopIndex - this._startIndex + 1;\r\n\t\t\tthis.decisions[decision].SLL_TotalLook += SLL_k;\r\n\t\t\tthis.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);\r\n\t\t\tif (SLL_k > this.decisions[decision].SLL_MaxLook) {\r\n\t\t\t\tthis.decisions[decision].SLL_MaxLook = SLL_k;\r\n\t\t\t\tthis.decisions[decision].SLL_MaxLookEvent =\r\n\t\t\t\t\tnew LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._sllStopIndex, false);\r\n\t\t\t}\r\n\r\n\t\t\tif (this._llStopIndex >= 0) {\r\n\t\t\t\tlet LL_k: number = this._llStopIndex - this._startIndex + 1;\r\n\t\t\t\tthis.decisions[decision].LL_TotalLook += LL_k;\r\n\t\t\t\tthis.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);\r\n\t\t\t\tif (LL_k > this.decisions[decision].LL_MaxLook) {\r\n\t\t\t\t\tthis.decisions[decision].LL_MaxLook = LL_k;\r\n\t\t\t\t\tthis.decisions[decision].LL_MaxLookEvent =\r\n\t\t\t\t\t\tnew LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._llStopIndex, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn alt;\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tthis._input = undefined;\r\n\t\t\tthis.currentDecision = -1;\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tprotected getStartState(dfa: DFA, input: TokenStream, outerContext: ParserRuleContext, useContext: boolean): SimulatorState | undefined {\r\n\t\tlet state: SimulatorState | undefined = super.getStartState(dfa, input, outerContext, useContext);\r\n\t\tthis.currentState = state;\r\n\t\treturn state;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected computeStartState(dfa: DFA, globalContext: ParserRuleContext, useContext: boolean): SimulatorState {\r\n\t\tlet state: SimulatorState = super.computeStartState(dfa, globalContext, useContext);\r\n\t\tthis.currentState = state;\r\n\t\treturn state;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected computeReachSet(dfa: DFA, previous: SimulatorState, t: number, contextCache: PredictionContextCache): SimulatorState | undefined {\r\n\t\tif (this._input === undefined) {\r\n\t\t\tthrow new Error(\"Invalid state\");\r\n\t\t}\r\n\r\n\t\tlet reachState: SimulatorState | undefined = super.computeReachSet(dfa, previous, t, contextCache);\r\n\t\tif (reachState == null) {\r\n\t\t\t// no reach on current lookahead symbol. ERROR.\r\n\t\t\tthis.decisions[this.currentDecision].errors.push(\r\n\t\t\t\tnew ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index),\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.currentState = reachState;\r\n\t\treturn reachState;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected getExistingTargetState(previousD: DFAState, t: number): DFAState | undefined {\r\n\t\tif (this.currentState === undefined || this._input === undefined) {\r\n\t\t\tthrow new Error(\"Invalid state\");\r\n\t\t}\r\n\r\n\t\t// this method is called after each time the input position advances\r\n\t\tif (this.currentState.useContext) {\r\n\t\t\tthis._llStopIndex = this._input.index;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._sllStopIndex = this._input.index;\r\n\t\t}\r\n\r\n\t\tlet existingTargetState: DFAState | undefined = super.getExistingTargetState(previousD, t);\r\n\t\tif (existingTargetState != null) {\r\n\t\t\t// this method is directly called by execDFA; must construct a SimulatorState\r\n\t\t\t// to represent the current state for this case\r\n\t\t\tthis.currentState = new SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);\r\n\r\n\t\t\tif (this.currentState.useContext) {\r\n\t\t\t\tthis.decisions[this.currentDecision].LL_DFATransitions++;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.decisions[this.currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state\r\n\t\t\t}\r\n\r\n\t\t\tif (existingTargetState === ATNSimulator.ERROR) {\r\n\t\t\t\tlet state: SimulatorState = new SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);\r\n\t\t\t\tthis.decisions[this.currentDecision].errors.push(\r\n\t\t\t\t\tnew ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn existingTargetState;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected computeTargetState(dfa: DFA, s: DFAState, remainingGlobalContext: ParserRuleContext, t: number, useContext: boolean, contextCache: PredictionContextCache): [DFAState, ParserRuleContext | undefined] {\r\n\t\tlet targetState: [DFAState, ParserRuleContext | undefined] = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);\r\n\r\n\t\tif (useContext) {\r\n\t\t\tthis.decisions[this.currentDecision].LL_ATNTransitions++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.decisions[this.currentDecision].SLL_ATNTransitions++;\r\n\t\t}\r\n\r\n\t\treturn targetState;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected evalSemanticContextImpl(pred: SemanticContext, parserCallStack: ParserRuleContext, alt: number): boolean {\r\n\t\tif (this.currentState === undefined || this._input === undefined) {\r\n\t\t\tthrow new Error(\"Invalid state\");\r\n\t\t}\r\n\r\n\t\tlet result: boolean = super.evalSemanticContextImpl(pred, parserCallStack, alt);\r\n\t\tif (!(pred instanceof SemanticContext.PrecedencePredicate)) {\r\n\t\t\tlet fullContext: boolean = this._llStopIndex >= 0;\r\n\t\t\tlet stopIndex: number = fullContext ? this._llStopIndex : this._sllStopIndex;\r\n\t\t\tthis.decisions[this.currentDecision].predicateEvals.push(\r\n\t\t\t\tnew PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt),\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected reportContextSensitivity(dfa: DFA, prediction: number, acceptState: SimulatorState, startIndex: number, stopIndex: number): void {\r\n\t\tif (this._input === undefined) {\r\n\t\t\tthrow new Error(\"Invalid state\");\r\n\t\t}\r\n\r\n\t\tif (prediction !== this.conflictingAltResolvedBySLL) {\r\n\t\t\tthis.decisions[this.currentDecision].contextSensitivities.push(\r\n\t\t\t\tnew ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex),\r\n\t\t\t);\r\n\t\t}\r\n\t\tsuper.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected reportAttemptingFullContext(dfa: DFA, conflictingAlts: BitSet, conflictState: SimulatorState, startIndex: number, stopIndex: number): void {\r\n\t\tif (conflictingAlts != null) {\r\n\t\t\tthis.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);\r\n\t\t}\r\n\t\tthis.decisions[this.currentDecision].LL_Fallback++;\r\n\t\tsuper.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected reportAmbiguity(@NotNull dfa: DFA, D: DFAState, startIndex: number, stopIndex: number, exact: boolean, @NotNull ambigAlts: BitSet, @NotNull configs: ATNConfigSet): void {\r\n\t\tif (this.currentState === undefined || this._input === undefined) {\r\n\t\t\tthrow new Error(\"Invalid state\");\r\n\t\t}\r\n\r\n\t\tlet prediction: number;\r\n\t\tif (ambigAlts != null) {\r\n\t\t\tprediction = ambigAlts.nextSetBit(0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprediction = configs.getRepresentedAlternatives().nextSetBit(0);\r\n\t\t}\r\n\t\tif (this.conflictingAltResolvedBySLL !== ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {\r\n\t\t\t// Even though this is an ambiguity we are reporting, we can\r\n\t\t\t// still detect some context sensitivities.  Both SLL and LL\r\n\t\t\t// are showing a conflict, hence an ambiguity, but if they resolve\r\n\t\t\t// to different minimum alternatives we have also identified a\r\n\t\t\t// context sensitivity.\r\n\t\t\tthis.decisions[this.currentDecision].contextSensitivities.push(\r\n\t\t\t\tnew ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex),\r\n\t\t\t);\r\n\t\t}\r\n\t\tthis.decisions[this.currentDecision].ambiguities.push(\r\n\t\t\tnew AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex),\r\n\t\t);\r\n\t\tsuper.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\r\n\t}\r\n\r\n\t// ---------------------------------------------------------------------\r\n\r\n\tpublic getDecisionInfo(): DecisionInfo[] {\r\n\t\treturn this.decisions;\r\n\t}\r\n\r\n\tpublic getCurrentState(): SimulatorState | undefined {\r\n\t\treturn this.currentState;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:52.4399193-07:00\r\n\r\nimport * as assert from \"assert\";\r\nimport * as Utils from \"./misc/Utils\";\r\n\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { ANTLRErrorStrategy } from \"./ANTLRErrorStrategy\";\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNDeserializationOptions } from \"./atn/ATNDeserializationOptions\";\r\nimport { ATNDeserializer } from \"./atn/ATNDeserializer\";\r\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\r\nimport { ATNState } from \"./atn/ATNState\";\r\nimport { DefaultErrorStrategy } from \"./DefaultErrorStrategy\";\r\nimport { DFA } from \"./dfa/DFA\";\r\nimport { ErrorNode } from \"./tree/ErrorNode\";\r\nimport { IntegerStack } from \"./misc/IntegerStack\";\r\nimport { IntervalSet } from \"./misc/IntervalSet\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { Lexer } from \"./Lexer\";\r\nimport { Override, NotNull, Nullable } from \"./Decorators\";\r\nimport { ParseInfo } from \"./atn/ParseInfo\";\r\nimport { ParserATNSimulator } from \"./atn/ParserATNSimulator\";\r\nimport { ParserErrorListener } from \"./ParserErrorListener\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\nimport { ParseTreeListener } from \"./tree/ParseTreeListener\";\r\nimport { ParseTreePattern } from \"./tree/pattern/ParseTreePattern\";\r\nimport { ProxyParserErrorListener } from \"./ProxyParserErrorListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { RuleTransition } from \"./atn/RuleTransition\";\r\nimport { TerminalNode } from \"./tree/TerminalNode\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenFactory } from \"./TokenFactory\";\r\nimport { TokenSource } from \"./TokenSource\";\r\nimport { TokenStream } from \"./TokenStream\";\r\n\r\nclass TraceListener implements ParseTreeListener {\r\n\tconstructor(private ruleNames: string[], private tokenStream: TokenStream) {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic enterEveryRule(ctx: ParserRuleContext): void {\r\n\t\tconsole.log(\"enter   \" + this.ruleNames[ctx.ruleIndex] +\r\n\t\t\t\", LT(1)=\" + this.tokenStream.LT(1).text);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic exitEveryRule(ctx: ParserRuleContext): void {\r\n\t\tconsole.log(\"exit    \" + this.ruleNames[ctx.ruleIndex] +\r\n\t\t\t\", LT(1)=\" + this.tokenStream.LT(1).text);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic visitErrorNode(node: ErrorNode): void {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t@Override\r\n\tpublic visitTerminal(node: TerminalNode): void {\r\n\t\tlet parent = node.parent!.ruleContext;\r\n\t\tlet token: Token = node.symbol;\r\n\t\tconsole.log(\"consume \" + token + \" rule \" + this.ruleNames[parent.ruleIndex]);\r\n\t}\r\n}\r\n\r\n/** This is all the parsing support code essentially; most of it is error recovery stuff. */\r\nexport abstract class Parser extends Recognizer<Token, ParserATNSimulator> {\r\n\t/**\r\n\t * This field maps from the serialized ATN string to the deserialized {@link ATN} with\r\n\t * bypass alternatives.\r\n\t *\r\n\t * @see ATNDeserializationOptions.isGenerateRuleBypassTransitions\r\n\t */\r\n\tprivate static readonly bypassAltsAtnCache = new Map<string, ATN>();\r\n\r\n\t/**\r\n\t * The error handling strategy for the parser. The default value is a new\r\n\t * instance of {@link DefaultErrorStrategy}.\r\n\t *\r\n\t * @see #getErrorHandler\r\n\t * @see #setErrorHandler\r\n\t */\r\n\t@NotNull\r\n\tprotected _errHandler: ANTLRErrorStrategy = new DefaultErrorStrategy();\r\n\r\n\t/**\r\n\t * The input stream.\r\n\t *\r\n\t * @see #getInputStream\r\n\t * @see #setInputStream\r\n\t */\r\n\tprotected _input!: TokenStream;\r\n\r\n\tprotected readonly _precedenceStack: IntegerStack = new IntegerStack();\r\n\r\n\t/**\r\n\t * The {@link ParserRuleContext} object for the currently executing rule.\r\n\t *\r\n\t * This is always non-undefined during the parsing process.\r\n\t */\r\n\tprotected _ctx!: ParserRuleContext;\r\n\r\n\t/**\r\n\t * Specifies whether or not the parser should construct a parse tree during\r\n\t * the parsing process. The default value is `true`.\r\n\t *\r\n\t * @see `buildParseTree`\r\n\t */\r\n\tprivate _buildParseTrees: boolean = true;\r\n\r\n\t/**\r\n\t * When {@link #setTrace}`(true)` is called, a reference to the\r\n\t * {@link TraceListener} is stored here so it can be easily removed in a\r\n\t * later call to {@link #setTrace}`(false)`. The listener itself is\r\n\t * implemented as a parser listener so this field is not directly used by\r\n\t * other parser methods.\r\n\t */\r\n\tprivate _tracer: TraceListener | undefined;\r\n\r\n\t/**\r\n\t * The list of {@link ParseTreeListener} listeners registered to receive\r\n\t * events during the parse.\r\n\t *\r\n\t * @see #addParseListener\r\n\t */\r\n\tprotected _parseListeners: ParseTreeListener[] = [];\r\n\r\n\t/**\r\n\t * The number of syntax errors reported during parsing. This value is\r\n\t * incremented each time {@link #notifyErrorListeners} is called.\r\n\t */\r\n\tprotected _syntaxErrors: number = 0;\r\n\r\n\t/** Indicates parser has match()ed EOF token. See {@link #exitRule()}. */\r\n\tprotected matchedEOF: boolean = false;\r\n\r\n\tconstructor(input: TokenStream) {\r\n\t\tsuper();\r\n\t\tthis._precedenceStack.push(0);\r\n\t\tthis.inputStream = input;\r\n\t}\r\n\r\n\t/** reset the parser's state */\r\n\tpublic reset(): void;\r\n\tpublic reset(resetInput: boolean): void;\r\n\tpublic reset(resetInput?: boolean): void {\r\n\t\t// Note: this method executes when not parsing, so _ctx can be undefined\r\n\t\tif (resetInput === undefined || resetInput) {\r\n\t\t\tthis.inputStream.seek(0);\r\n\t\t}\r\n\r\n\t\tthis._errHandler.reset(this);\r\n\t\tthis._ctx = undefined as any;\r\n\t\tthis._syntaxErrors = 0;\r\n\t\tthis.matchedEOF = false;\r\n\t\tthis.isTrace = false;\r\n\t\tthis._precedenceStack.clear();\r\n\t\tthis._precedenceStack.push(0);\r\n\t\tlet interpreter: ATNSimulator = this.interpreter;\r\n\t\tif (interpreter != null) {\r\n\t\t\tinterpreter.reset();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Match current input symbol against `ttype`. If the symbol type\r\n\t * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are\r\n\t * called to complete the match process.\r\n\t *\r\n\t * If the symbol type does not match,\r\n\t * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\r\n\t * strategy to attempt recovery. If {@link #getBuildParseTree} is\r\n\t * `true` and the token index of the symbol returned by\r\n\t * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\r\n\t * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then\r\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\r\n\t *\r\n\t * @param ttype the token type to match\r\n\t * @returns the matched symbol\r\n\t * @ if the current input symbol did not match\r\n\t * `ttype` and the error strategy could not recover from the\r\n\t * mismatched symbol\r\n\t */\r\n\t@NotNull\r\n\tpublic match(ttype: number): Token {\r\n\t\tlet t: Token = this.currentToken;\r\n\t\tif (t.type === ttype) {\r\n\t\t\tif (ttype === Token.EOF) {\r\n\t\t\t\tthis.matchedEOF = true;\r\n\t\t\t}\r\n\t\t\tthis._errHandler.reportMatch(this);\r\n\t\t\tthis.consume();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tt = this._errHandler.recoverInline(this);\r\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\r\n\t\t\t\t// we must have conjured up a new token during single token insertion\r\n\t\t\t\t// if it's not the current symbol\r\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/**\r\n\t * Match current input symbol as a wildcard. If the symbol type matches\r\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}\r\n\t * and {@link #consume} are called to complete the match process.\r\n\t *\r\n\t * If the symbol type does not match,\r\n\t * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\r\n\t * strategy to attempt recovery. If {@link #getBuildParseTree} is\r\n\t * `true` and the token index of the symbol returned by\r\n\t * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\r\n\t * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then\r\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\r\n\t *\r\n\t * @returns the matched symbol\r\n\t * @ if the current input symbol did not match\r\n\t * a wildcard and the error strategy could not recover from the mismatched\r\n\t * symbol\r\n\t */\r\n\t@NotNull\r\n\tpublic matchWildcard(): Token {\r\n\t\tlet t: Token = this.currentToken;\r\n\t\tif (t.type > 0) {\r\n\t\t\tthis._errHandler.reportMatch(this);\r\n\t\t\tthis.consume();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tt = this._errHandler.recoverInline(this);\r\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\r\n\t\t\t\t// we must have conjured up a new token during single token insertion\r\n\t\t\t\t// if it's not the current symbol\r\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/**\r\n\t * Track the {@link ParserRuleContext} objects during the parse and hook\r\n\t * them up using the {@link ParserRuleContext#children} list so that it\r\n\t * forms a parse tree. The {@link ParserRuleContext} returned from the start\r\n\t * rule represents the root of the parse tree.\r\n\t *\r\n\t * Note that if we are not building parse trees, rule contexts only point\r\n\t * upwards. When a rule exits, it returns the context but that gets garbage\r\n\t * collected if nobody holds a reference. It points upwards but nobody\r\n\t * points at it.\r\n\t *\r\n\t * When we build parse trees, we are adding all of these contexts to\r\n\t * {@link ParserRuleContext#children} list. Contexts are then not candidates\r\n\t * for garbage collection.\r\n\t */\r\n\tset buildParseTree(buildParseTrees: boolean) {\r\n\t\tthis._buildParseTrees = buildParseTrees;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether or not a complete parse tree will be constructed while\r\n\t * parsing. This property is `true` for a newly constructed parser.\r\n\t *\r\n\t * @returns `true` if a complete parse tree will be constructed while\r\n\t * parsing, otherwise `false`\r\n\t */\r\n\tget buildParseTree(): boolean {\r\n\t\treturn this._buildParseTrees;\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getParseListeners(): ParseTreeListener[] {\r\n\t\treturn this._parseListeners;\r\n\t}\r\n\r\n\t/**\r\n\t * Registers `listener` to receive events during the parsing process.\r\n\t *\r\n\t * To support output-preserving grammar transformations (including but not\r\n\t * limited to left-recursion removal, automated left-factoring, and\r\n\t * optimized code generation), calls to listener methods during the parse\r\n\t * may differ substantially from calls made by\r\n\t * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In\r\n\t * particular, rule entry and exit events may occur in a different order\r\n\t * during the parse than after the parser. In addition, calls to certain\r\n\t * rule entry methods may be omitted.\r\n\t *\r\n\t * With the following specific exceptions, calls to listener events are\r\n\t * *deterministic*, i.e. for identical input the calls to listener\r\n\t * methods will be the same.\r\n\t *\r\n\t * * Alterations to the grammar used to generate code may change the\r\n\t *   behavior of the listener calls.\r\n\t * * Alterations to the command line options passed to ANTLR 4 when\r\n\t *   generating the parser may change the behavior of the listener calls.\r\n\t * * Changing the version of the ANTLR Tool used to generate the parser\r\n\t *   may change the behavior of the listener calls.\r\n\t *\r\n\t * @param listener the listener to add\r\n\t *\r\n\t * @throws {@link TypeError} if `listener` is `undefined`\r\n\t */\r\n\tpublic addParseListener(@NotNull listener: ParseTreeListener): void {\r\n\t\tif (listener == null) {\r\n\t\t\tthrow new TypeError(\"listener cannot be null\");\r\n\t\t}\r\n\r\n\t\tthis._parseListeners.push(listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove `listener` from the list of parse listeners.\r\n\t *\r\n\t * If `listener` is `undefined` or has not been added as a parse\r\n\t * listener, this method does nothing.\r\n\t *\r\n\t * @see #addParseListener\r\n\t *\r\n\t * @param listener the listener to remove\r\n\t */\r\n\tpublic removeParseListener(listener: ParseTreeListener): void {\r\n\t\tlet index = this._parseListeners.findIndex((l) => l === listener);\r\n\t\tif (index !== -1) {\r\n\t\t\tthis._parseListeners.splice(index, 1);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Remove all parse listeners.\r\n\t *\r\n\t * @see #addParseListener\r\n\t */\r\n\tpublic removeParseListeners(): void {\r\n\t\tthis._parseListeners.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Notify any parse listeners of an enter rule event.\r\n\t *\r\n\t * @see #addParseListener\r\n\t */\r\n\tprotected triggerEnterRuleEvent(): void {\r\n\t\tfor (let listener of this._parseListeners) {\r\n\t\t\tif (listener.enterEveryRule) {\r\n\t\t\t\tlistener.enterEveryRule(this._ctx);\r\n\t\t\t}\r\n\r\n\t\t\tthis._ctx.enterRule(listener);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Notify any parse listeners of an exit rule event.\r\n\t *\r\n\t * @see #addParseListener\r\n\t */\r\n\tprotected triggerExitRuleEvent(): void {\r\n\t\t// reverse order walk of listeners\r\n\t\tfor (let i = this._parseListeners.length - 1; i >= 0; i--) {\r\n\t\t\tlet listener: ParseTreeListener = this._parseListeners[i];\r\n\t\t\tthis._ctx.exitRule(listener);\r\n\t\t\tif (listener.exitEveryRule) {\r\n\t\t\t\tlistener.exitEveryRule(this._ctx);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the number of syntax errors reported during parsing. This value is\r\n\t * incremented each time {@link #notifyErrorListeners} is called.\r\n\t *\r\n\t * @see #notifyErrorListeners\r\n\t */\r\n\tget numberOfSyntaxErrors(): number {\r\n\t\treturn this._syntaxErrors;\r\n\t}\r\n\r\n\tget tokenFactory(): TokenFactory {\r\n\t\treturn this._input.tokenSource.tokenFactory;\r\n\t}\r\n\r\n\t/**\r\n\t * The ATN with bypass alternatives is expensive to create so we create it\r\n\t * lazily.\r\n\t *\r\n\t * @ if the current parser does not\r\n\t * implement the `serializedATN` property.\r\n\t */\r\n\t@NotNull\r\n\tpublic getATNWithBypassAlts(): ATN {\r\n\t\tlet serializedAtn: string = this.serializedATN;\r\n\t\tif (serializedAtn == null) {\r\n\t\t\tthrow new Error(\"The current parser does not support an ATN with bypass alternatives.\");\r\n\t\t}\r\n\r\n\t\tlet result = Parser.bypassAltsAtnCache.get(serializedAtn);\r\n\t\tif (result == null) {\r\n\t\t\tlet deserializationOptions: ATNDeserializationOptions = new ATNDeserializationOptions();\r\n\t\t\tdeserializationOptions.isGenerateRuleBypassTransitions = true;\r\n\t\t\tresult = new ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));\r\n\t\t\tParser.bypassAltsAtnCache.set(serializedAtn, result);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * The preferred method of getting a tree pattern. For example, here's a\r\n\t * sample use:\r\n\t *\r\n\t * ```\r\n\t * let t: ParseTree = parser.expr();\r\n\t * let p: ParseTreePattern = await parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\r\n\t * let m: ParseTreeMatch = p.match(t);\r\n\t * let id: string = m.get(\"ID\");\r\n\t * ```\r\n\t */\r\n\tpublic compileParseTreePattern(pattern: string, patternRuleIndex: number): Promise<ParseTreePattern>;\r\n\r\n\t/**\r\n\t * The same as {@link #compileParseTreePattern(String, int)} but specify a\r\n\t * {@link Lexer} rather than trying to deduce it from this parser.\r\n\t */\r\n\tpublic compileParseTreePattern(pattern: string, patternRuleIndex: number, lexer?: Lexer): Promise<ParseTreePattern>;\r\n\r\n\tpublic async compileParseTreePattern(pattern: string, patternRuleIndex: number, lexer?: Lexer): Promise<ParseTreePattern> {\r\n\t\tif (!lexer) {\r\n\t\t\tif (this.inputStream) {\r\n\t\t\t\tlet tokenSource = this.inputStream.tokenSource;\r\n\t\t\t\tif (tokenSource instanceof Lexer) {\r\n\t\t\t\t\tlexer = tokenSource;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!lexer) {\r\n\t\t\t\tthrow new Error(\"Parser can't discover a lexer to use\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet currentLexer = lexer;\r\n\t\tlet m = await import(\"./tree/pattern/ParseTreePatternMatcher\");\r\n\t\tlet matcher = new m.ParseTreePatternMatcher(currentLexer, this);\r\n\t\treturn matcher.compile(pattern, patternRuleIndex);\r\n\t}\r\n\r\n\t@NotNull\r\n\tget errorHandler(): ANTLRErrorStrategy {\r\n\t\treturn this._errHandler;\r\n\t}\r\n\r\n\tset errorHandler(@NotNull handler: ANTLRErrorStrategy) {\r\n\t\tthis._errHandler = handler;\r\n\t}\r\n\r\n\t@Override\r\n\tget inputStream(): TokenStream {\r\n\t\treturn this._input;\r\n\t}\r\n\r\n\t/** Set the token stream and reset the parser. */\r\n\tset inputStream(input: TokenStream) {\r\n\t\tthis.reset(false);\r\n\t\tthis._input = input;\r\n\t}\r\n\r\n\t/** Match needs to return the current input symbol, which gets put\r\n\t *  into the label for the associated token ref; e.g., x=ID.\r\n\t */\r\n\t@NotNull\r\n\tget currentToken(): Token {\r\n\t\treturn this._input.LT(1);\r\n\t}\r\n\r\n\tpublic notifyErrorListeners(/*@NotNull*/ msg: string): void;\r\n\tpublic notifyErrorListeners(/*@NotNull*/ msg: string, /*@NotNull*/ offendingToken: Token | null, e: RecognitionException | undefined): void;\r\n\r\n\tpublic notifyErrorListeners(msg: string, offendingToken?: Token | null, e?: RecognitionException | undefined): void {\r\n\t\tif (offendingToken === undefined) {\r\n\t\t\toffendingToken = this.currentToken;\r\n\t\t} else if (offendingToken === null) {\r\n\t\t\toffendingToken = undefined;\r\n\t\t}\r\n\r\n\t\tthis._syntaxErrors++;\r\n\t\tlet line: number = -1;\r\n\t\tlet charPositionInLine: number = -1;\r\n\t\tif (offendingToken != null) {\r\n\t\t\tline = offendingToken.line;\r\n\t\t\tcharPositionInLine = offendingToken.charPositionInLine;\r\n\t\t}\r\n\r\n\t\tlet listener = this.getErrorListenerDispatch();\r\n\t\tif (listener.syntaxError) {\r\n\t\t\tlistener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Consume and return the [current symbol](`currentToken`).\r\n\t *\r\n\t * E.g., given the following input with `A` being the current\r\n\t * lookahead symbol, this function moves the cursor to `B` and returns\r\n\t * `A`.\r\n\t *\r\n\t * ```\r\n\t * A B\r\n\t * ^\r\n\t * ```\r\n\t *\r\n\t * If the parser is not in error recovery mode, the consumed symbol is added\r\n\t * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and\r\n\t * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.\r\n\t * If the parser *is* in error recovery mode, the consumed symbol is\r\n\t * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then\r\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)} and\r\n\t * {@link ParseTreeListener#visitErrorNode} is called on any parse\r\n\t * listeners.\r\n\t */\r\n\tpublic consume(): Token {\r\n\t\tlet o: Token = this.currentToken;\r\n\t\tif (o.type !== Parser.EOF) {\r\n\t\t\tthis.inputStream.consume();\r\n\t\t}\r\n\t\tlet hasListener: boolean = this._parseListeners.length !== 0;\r\n\t\tif (this._buildParseTrees || hasListener) {\r\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\r\n\t\t\t\tlet node: ErrorNode = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));\r\n\t\t\t\tif (hasListener) {\r\n\t\t\t\t\tfor (let listener of this._parseListeners) {\r\n\t\t\t\t\t\tif (listener.visitErrorNode) {\r\n\t\t\t\t\t\t\tlistener.visitErrorNode(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet node: TerminalNode = this.createTerminalNode(this._ctx, o);\r\n\t\t\t\tthis._ctx.addChild(node);\r\n\t\t\t\tif (hasListener) {\r\n\t\t\t\t\tfor (let listener of this._parseListeners) {\r\n\t\t\t\t\t\tif (listener.visitTerminal) {\r\n\t\t\t\t\t\t\tlistener.visitTerminal(node);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn o;\r\n\t}\r\n\r\n\t/**\r\n\t * How to create a token leaf node associated with a parent.\r\n\t * Typically, the terminal node to create is not a function of the parent.\r\n\t *\r\n\t * @since 4.7\r\n\t */\r\n\tpublic createTerminalNode(parent: ParserRuleContext, t: Token): TerminalNode {\r\n\t\treturn new TerminalNode(t);\r\n\t}\r\n\r\n\t/**\r\n\t * How to create an error node, given a token, associated with a parent.\r\n\t * Typically, the error node to create is not a function of the parent.\r\n\t *\r\n\t * @since 4.7\r\n\t */\r\n\tpublic createErrorNode(parent: ParserRuleContext, t: Token): ErrorNode {\r\n\t\treturn new ErrorNode(t);\r\n\t}\r\n\r\n\tprotected addContextToParseTree(): void {\r\n\t\tlet parent = this._ctx._parent as ParserRuleContext | undefined;\r\n\t\t// add current context to parent if we have a parent\r\n\t\tif (parent != null) {\r\n\t\t\tparent.addChild(this._ctx);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Always called by generated parsers upon entry to a rule. Access field\r\n\t * {@link #_ctx} get the current context.\r\n\t */\r\n\tpublic enterRule(@NotNull localctx: ParserRuleContext, state: number, ruleIndex: number): void {\r\n\t\tthis.state = state;\r\n\t\tthis._ctx = localctx;\r\n\t\tthis._ctx._start = this._input.LT(1);\r\n\t\tif (this._buildParseTrees) {\r\n\t\t\tthis.addContextToParseTree();\r\n\t\t}\r\n\t\tthis.triggerEnterRuleEvent();\r\n\t}\r\n\r\n\tpublic enterLeftFactoredRule(localctx: ParserRuleContext, state: number, ruleIndex: number): void {\r\n\t\tthis.state = state;\r\n\t\tif (this._buildParseTrees) {\r\n\t\t\tlet factoredContext = this._ctx.getChild(this._ctx.childCount - 1) as ParserRuleContext;\r\n\t\t\tthis._ctx.removeLastChild();\r\n\t\t\tfactoredContext._parent = localctx;\r\n\t\t\tlocalctx.addChild(factoredContext);\r\n\t\t}\r\n\r\n\t\tthis._ctx = localctx;\r\n\t\tthis._ctx._start = this._input.LT(1);\r\n\t\tif (this._buildParseTrees) {\r\n\t\t\tthis.addContextToParseTree();\r\n\t\t}\r\n\r\n\t\tthis.triggerEnterRuleEvent();\r\n\t}\r\n\r\n\tpublic exitRule(): void {\r\n\t\tif (this.matchedEOF) {\r\n\t\t\t// if we have matched EOF, it cannot consume past EOF so we use LT(1) here\r\n\t\t\tthis._ctx._stop = this._input.LT(1); // LT(1) will be end of file\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._ctx._stop = this._input.tryLT(-1); // stop node is what we just matched\r\n\t\t}\r\n\t\t// trigger event on _ctx, before it reverts to parent\r\n\t\tthis.triggerExitRuleEvent();\r\n\t\tthis.state = this._ctx.invokingState;\r\n\t\tthis._ctx = this._ctx._parent as ParserRuleContext;\r\n\t}\r\n\r\n\tpublic enterOuterAlt(localctx: ParserRuleContext, altNum: number): void {\r\n\t\tlocalctx.altNumber = altNum;\r\n\t\t// if we have new localctx, make sure we replace existing ctx\r\n\t\t// that is previous child of parse tree\r\n\t\tif (this._buildParseTrees && this._ctx !== localctx) {\r\n\t\t\tlet parent = this._ctx._parent as ParserRuleContext | undefined;\r\n\t\t\tif (parent != null) {\r\n\t\t\t\tparent.removeLastChild();\r\n\t\t\t\tparent.addChild(localctx);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._ctx = localctx;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the precedence level for the top-most precedence rule.\r\n\t *\r\n\t * @returns The precedence level for the top-most precedence rule, or -1 if\r\n\t * the parser context is not nested within a precedence rule.\r\n\t */\r\n\tget precedence(): number {\r\n\t\tif (this._precedenceStack.isEmpty) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\treturn this._precedenceStack.peek();\r\n\t}\r\n\r\n\tpublic enterRecursionRule(localctx: ParserRuleContext, state: number, ruleIndex: number, precedence: number): void {\r\n\t\tthis.state = state;\r\n\t\tthis._precedenceStack.push(precedence);\r\n\t\tthis._ctx = localctx;\r\n\t\tthis._ctx._start = this._input.LT(1);\r\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\r\n\t}\r\n\r\n\t/** Like {@link #enterRule} but for recursive rules.\r\n\t *  Make the current context the child of the incoming localctx.\r\n\t */\r\n\tpublic pushNewRecursionContext(localctx: ParserRuleContext, state: number, ruleIndex: number): void {\r\n\t\tlet previous: ParserRuleContext = this._ctx;\r\n\t\tprevious._parent = localctx;\r\n\t\tprevious.invokingState = state;\r\n\t\tprevious._stop = this._input.tryLT(-1);\r\n\r\n\t\tthis._ctx = localctx;\r\n\t\tthis._ctx._start = previous._start;\r\n\t\tif (this._buildParseTrees) {\r\n\t\t\tthis._ctx.addChild(previous);\r\n\t\t}\r\n\r\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\r\n\t}\r\n\r\n\tpublic unrollRecursionContexts(_parentctx: ParserRuleContext): void {\r\n\t\tthis._precedenceStack.pop();\r\n\t\tthis._ctx._stop = this._input.tryLT(-1);\r\n\t\tlet retctx: ParserRuleContext = this._ctx; // save current ctx (return value)\r\n\r\n\t\t// unroll so _ctx is as it was before call to recursive method\r\n\t\tif (this._parseListeners.length > 0) {\r\n\t\t\twhile (this._ctx !== _parentctx) {\r\n\t\t\t\tthis.triggerExitRuleEvent();\r\n\t\t\t\tthis._ctx = this._ctx._parent as ParserRuleContext;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._ctx = _parentctx;\r\n\t\t}\r\n\r\n\t\t// hook into tree\r\n\t\tretctx._parent = _parentctx;\r\n\r\n\t\tif (this._buildParseTrees && _parentctx != null) {\r\n\t\t\t// add return ctx into invoking rule's tree\r\n\t\t\t_parentctx.addChild(retctx);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getInvokingContext(ruleIndex: number): ParserRuleContext | undefined {\r\n\t\tlet p = this._ctx;\r\n\t\twhile (p && p.ruleIndex !== ruleIndex) {\r\n\t\t\tp = p._parent as ParserRuleContext;\r\n\t\t}\r\n\t\treturn p;\r\n\t}\r\n\r\n\tget context(): ParserRuleContext {\r\n\t\treturn this._ctx;\r\n\t}\r\n\r\n\tset context(ctx: ParserRuleContext) {\r\n\t\tthis._ctx = ctx;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic precpred(@Nullable localctx: RuleContext, precedence: number): boolean {\r\n\t\treturn precedence >= this._precedenceStack.peek();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getErrorListenerDispatch(): ParserErrorListener {\r\n\t\treturn new ProxyParserErrorListener(this.getErrorListeners());\r\n\t}\r\n\r\n\tpublic inContext(context: string): boolean {\r\n\t\t// TODO: useful in parser?\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether or not `symbol` can follow the current state in the\r\n\t * ATN. The behavior of this method is equivalent to the following, but is\r\n\t * implemented such that the complete context-sensitive follow set does not\r\n\t * need to be explicitly constructed.\r\n\t *\r\n\t * ```\r\n\t * return getExpectedTokens().contains(symbol);\r\n\t * ```\r\n\t *\r\n\t * @param symbol the symbol type to check\r\n\t * @returns `true` if `symbol` can follow the current state in\r\n\t * the ATN, otherwise `false`.\r\n\t */\r\n\tpublic isExpectedToken(symbol: number): boolean {\r\n//   \t\treturn interpreter.atn.nextTokens(_ctx);\r\n\t\tlet atn: ATN = this.interpreter.atn;\r\n\t\tlet ctx: ParserRuleContext = this._ctx;\r\n\t\tlet s: ATNState = atn.states[this.state];\r\n\t\tlet following: IntervalSet = atn.nextTokens(s);\r\n\t\tif (following.contains(symbol)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n//        System.out.println(\"following \"+s+\"=\"+following);\r\n\t\tif (!following.contains(Token.EPSILON)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\twhile (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\r\n\t\t\tlet invokingState: ATNState = atn.states[ctx.invokingState];\r\n\t\t\tlet rt = invokingState.transition(0) as RuleTransition;\r\n\t\t\tfollowing = atn.nextTokens(rt.followState);\r\n\t\t\tif (following.contains(symbol)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tctx = ctx._parent as ParserRuleContext;\r\n\t\t}\r\n\r\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget isMatchedEOF(): boolean {\r\n\t\treturn this.matchedEOF;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the set of input symbols which could follow the current parser\r\n\t * state and context, as given by {@link #getState} and {@link #getContext},\r\n\t * respectively.\r\n\t *\r\n\t * @see ATN#getExpectedTokens(int, RuleContext)\r\n\t */\r\n\t@NotNull\r\n\tpublic getExpectedTokens(): IntervalSet {\r\n\t\treturn this.atn.getExpectedTokens(this.state, this.context);\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getExpectedTokensWithinCurrentRule(): IntervalSet {\r\n\t\tlet atn: ATN = this.interpreter.atn;\r\n\t\tlet s: ATNState = atn.states[this.state];\r\n\t\treturn atn.nextTokens(s);\r\n\t}\r\n\r\n\t/** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */\r\n\tpublic getRuleIndex(ruleName: string): number {\r\n\t\tlet ruleIndex = this.getRuleIndexMap().get(ruleName);\r\n\t\tif (ruleIndex != null) {\r\n\t\t\treturn ruleIndex;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tget ruleContext(): ParserRuleContext { return this._ctx; }\r\n\r\n\t/** Return List&lt;String&gt; of the rule names in your parser instance\r\n\t *  leading up to a call to the current rule.  You could override if\r\n\t *  you want more details such as the file/line info of where\r\n\t *  in the ATN a rule is invoked.\r\n\t *\r\n\t *  This is very useful for error messages.\r\n\t */\r\n\r\n\tpublic getRuleInvocationStack(ctx: RuleContext = this._ctx): string[] {\r\n\t\tlet p: RuleContext | undefined = ctx;  \t\t// Workaround for Microsoft/TypeScript#14487\r\n\t\tlet ruleNames: string[] = this.ruleNames;\r\n\t\tlet stack: string[] = [];\r\n\t\twhile (p != null) {\r\n\t\t\t// compute what follows who invoked us\r\n\t\t\tlet ruleIndex: number = p.ruleIndex;\r\n\t\t\tif (ruleIndex < 0) {\r\n\t\t\t\tstack.push(\"n/a\");\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(ruleNames[ruleIndex]);\r\n\t\t\t}\r\n\t\t\tp = p._parent as RuleContext;\r\n\t\t}\r\n\t\treturn stack;\r\n\t}\r\n\r\n\t/** For debugging and other purposes. */\r\n\tpublic getDFAStrings(): string[] {\r\n\t\tlet s: string[] = [];\r\n\t\tfor (let dfa of this._interp.atn.decisionToDFA) {\r\n\t\t\ts.push(dfa.toString(this.vocabulary, this.ruleNames));\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\t/** For debugging and other purposes. */\r\n\tpublic dumpDFA(): void {\r\n\t\tlet seenOne: boolean = false;\r\n\t\tfor (let dfa of this._interp.atn.decisionToDFA) {\r\n\t\t\tif (!dfa.isEmpty) {\r\n\t\t\t\tif (seenOne) {\r\n\t\t\t\t\tconsole.log();\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(\"Decision \" + dfa.decision + \":\");\r\n\t\t\t\tprocess.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));\r\n\t\t\t\tseenOne = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tget sourceName(): string {\r\n\t\treturn this._input.sourceName;\r\n\t}\r\n\r\n\t@Override\r\n\tget parseInfo(): Promise<ParseInfo | undefined> {\r\n\t\treturn import(\"./atn/ProfilingATNSimulator\").then((m) => {\r\n\t\t\tlet interp: ParserATNSimulator = this.interpreter;\r\n\t\t\tif (interp instanceof m.ProfilingATNSimulator) {\r\n\t\t\t\treturn new ParseInfo(interp);\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * @since 4.3\r\n\t */\r\n\tpublic async setProfile(profile: boolean): Promise<void> {\r\n\t\tlet m = await import(\"./atn/ProfilingATNSimulator\");\r\n\t\tlet interp: ParserATNSimulator = this.interpreter;\r\n\t\tif (profile) {\r\n\t\t\tif (!(interp instanceof m.ProfilingATNSimulator)) {\r\n\t\t\t\tthis.interpreter = new m.ProfilingATNSimulator(this);\r\n\t\t\t}\r\n\t\t} else if (interp instanceof m.ProfilingATNSimulator) {\r\n\t\t\tthis.interpreter = new ParserATNSimulator(this.atn, this);\r\n\t\t}\r\n\r\n\t\tthis.interpreter.setPredictionMode(interp.getPredictionMode());\r\n\t}\r\n\r\n\t/** During a parse is sometimes useful to listen in on the rule entry and exit\r\n\t *  events as well as token matches. This is for quick and dirty debugging.\r\n\t */\r\n\tset isTrace(trace: boolean) {\r\n\t\tif (!trace) {\r\n\t\t\tif (this._tracer) {\r\n\t\t\t\tthis.removeParseListener(this._tracer);\r\n\t\t\t\tthis._tracer = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._tracer) {\r\n\t\t\t\tthis.removeParseListener(this._tracer);\r\n\t\t\t} else {\r\n\t\t\t\tthis._tracer = new TraceListener(this.ruleNames, this._input);\r\n\t\t\t}\r\n\r\n\t\t\tthis.addParseListener(this._tracer);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether a {@link TraceListener} is registered as a parse listener\r\n\t * for the parser.\r\n\t */\r\n\tget isTrace(): boolean {\r\n\t\treturn this._tracer != null;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:48.3187865-07:00\r\n\r\nimport { Arrays } from \"../misc/Arrays\";\r\nimport { ATN } from \"../atn/ATN\";\r\nimport { CommonToken } from \"../CommonToken\";\r\nimport { ErrorNode } from \"./ErrorNode\";\r\nimport { Interval } from \"../misc/Interval\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { Parser } from \"../Parser\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\nimport { Token } from \"../Token\";\r\nimport { Tree } from \"./Tree\";\r\nimport * as Utils from \"../misc/Utils\";\r\n\r\n/** A set of utility routines useful for all kinds of ANTLR trees. */\r\nexport class Trees {\r\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\r\n\t *  node payloads to get the text for the nodes.  Detect\r\n\t *  parse trees and extract data appropriately.\r\n\t */\r\n\tpublic static toStringTree(/*@NotNull*/ t: Tree): string;\r\n\r\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\r\n\t *  node payloads to get the text for the nodes.  Detect\r\n\t *  parse trees and extract data appropriately.\r\n\t */\r\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, recog: Parser | undefined): string;\r\n\r\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\r\n\t *  node payloads to get the text for the nodes.\r\n\t */\r\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, /*@Nullable*/ ruleNames: string[] | undefined): string;\r\n\r\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, arg2?: Parser | string[]): string;\r\n\tpublic static toStringTree(@NotNull t: Tree, arg2?: Parser | string[]): string {\r\n\t\tlet ruleNames: string[] | undefined;\r\n\t\tif (arg2 instanceof Parser) {\r\n\t\t\truleNames = arg2.ruleNames;\r\n\t\t} else {\r\n\t\t\truleNames = arg2;\r\n\t\t}\r\n\r\n\t\tlet s: string = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\r\n\t\tif (t.childCount === 0) {\r\n\t\t\treturn s;\r\n\t\t}\r\n\t\tlet buf = \"\";\r\n\t\tbuf += (\"(\");\r\n\t\ts = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\r\n\t\tbuf += (s);\r\n\t\tbuf += (\" \");\r\n\t\tfor (let i = 0; i < t.childCount; i++) {\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tbuf += (\" \");\r\n\t\t\t}\r\n\t\t\tbuf += (this.toStringTree(t.getChild(i), ruleNames));\r\n\t\t}\r\n\t\tbuf += (\")\");\r\n\t\treturn buf;\r\n\t}\r\n\r\n\tpublic static getNodeText(/*@NotNull*/ t: Tree, recog: Parser | undefined): string;\r\n\tpublic static getNodeText(/*@NotNull*/ t: Tree, ruleNames: string[] | undefined): string;\r\n\tpublic static getNodeText(t: Tree, arg2: Parser | string[] | undefined): string {\r\n\t\tlet ruleNames: string[] | undefined;\r\n\t\tif (arg2 instanceof Parser) {\r\n\t\t\truleNames = arg2.ruleNames;\r\n\t\t} else if (arg2) {\r\n\t\t\truleNames = arg2;\r\n\t\t} else {\r\n\t\t\t// no recog or rule names\r\n\t\t\tlet payload = t.payload;\r\n\t\t\tif (typeof payload.text === \"string\") {\r\n\t\t\t\treturn payload.text;\r\n\t\t\t}\r\n\t\t\treturn t.payload.toString();\r\n\t\t}\r\n\r\n\t\tif (t instanceof RuleNode) {\r\n\t\t\tlet ruleContext: RuleContext = t.ruleContext;\r\n\t\t\tlet ruleIndex: number = ruleContext.ruleIndex;\r\n\t\t\tlet ruleName: string = ruleNames[ruleIndex];\r\n\t\t\tlet altNumber: number = ruleContext.altNumber;\r\n\t\t\tif (altNumber !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\t\treturn ruleName + \":\" + altNumber;\r\n\t\t\t}\r\n\t\t\treturn ruleName;\r\n\t\t}\r\n\t\telse if (t instanceof ErrorNode) {\r\n\t\t\treturn t.toString();\r\n\t\t}\r\n\t\telse if (t instanceof TerminalNode) {\r\n\t\t\tlet symbol = t.symbol;\r\n\t\t\treturn symbol.text || \"\";\r\n\t\t}\r\n\t\tthrow new TypeError(\"Unexpected node type\");\r\n\t}\r\n\r\n\t/** Return ordered list of all children of this node */\r\n\tpublic static getChildren(t: ParseTree): ParseTree[];\r\n\tpublic static getChildren(t: Tree): Tree[];\r\n\tpublic static getChildren(t: Tree): Tree[] {\r\n\t\tlet kids: Tree[] = [];\r\n\t\tfor (let i = 0; i < t.childCount; i++) {\r\n\t\t\tkids.push(t.getChild(i));\r\n\t\t}\r\n\t\treturn kids;\r\n\t}\r\n\r\n\t/** Return a list of all ancestors of this node.  The first node of\r\n\t *  list is the root and the last is the parent of this node.\r\n\t *\r\n\t *  @since 4.5.1\r\n\t */\r\n\tpublic static getAncestors(t: ParseTree): ParseTree[];\r\n\tpublic static getAncestors(t: Tree): Tree[];\r\n\t@NotNull\r\n\tpublic static getAncestors(@NotNull t: Tree): Tree[] {\r\n\t\tlet ancestors: Tree[] = [];\r\n\t\tlet p = t.parent;\r\n\t\twhile (p) {\r\n\t\t\tancestors.unshift(p); // insert at start\r\n\t\t\tp = p.parent;\r\n\t\t}\r\n\t\treturn ancestors;\r\n\t}\r\n\r\n\t/** Return true if t is u's parent or a node on path to root from u.\r\n\t *  Use === not equals().\r\n\t *\r\n\t *  @since 4.5.1\r\n\t */\r\n\tpublic static isAncestorOf(t: Tree, u: Tree): boolean {\r\n\t\tif (!t || !u || !t.parent) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tlet p = u.parent;\r\n\t\twhile (p) {\r\n\t\t\tif (t === p) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tp = p.parent;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic static findAllTokenNodes(t: ParseTree, ttype: number): ParseTree[] {\r\n\t\treturn Trees.findAllNodes(t, ttype, true);\r\n\t}\r\n\r\n\tpublic static findAllRuleNodes(t: ParseTree, ruleIndex: number): ParseTree[] {\r\n\t\treturn Trees.findAllNodes(t, ruleIndex, false);\r\n\t}\r\n\r\n\tpublic static findAllNodes(t: ParseTree, index: number, findTokens: boolean): ParseTree[] {\r\n\t\tlet nodes: ParseTree[] = [];\r\n\t\tTrees._findAllNodes(t, index, findTokens, nodes);\r\n\t\treturn nodes;\r\n\t}\r\n\r\n\tpublic static _findAllNodes(t: ParseTree, index: number, findTokens: boolean, nodes: ParseTree[]): void {\r\n\t\t// check this node (the root) first\r\n\t\tif (findTokens && t instanceof TerminalNode) {\r\n\t\t\tif (t.symbol.type === index) {\r\n\t\t\t\tnodes.push(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (!findTokens && t instanceof ParserRuleContext) {\r\n\t\t\tif (t.ruleIndex === index) {\r\n\t\t\t\tnodes.push(t);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// check children\r\n\t\tfor (let i = 0; i < t.childCount; i++) {\r\n\t\t\tTrees._findAllNodes(t.getChild(i), index, findTokens, nodes);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Get all descendents; includes t itself.\r\n\t *\r\n\t * @since 4.5.1\r\n\t */\r\n\tpublic static getDescendants(t: ParseTree): ParseTree[] {\r\n\t\tlet nodes: ParseTree[] = [];\r\n\r\n\t\tfunction recurse(e: ParseTree): void {\r\n\t\t\tnodes.push(e);\r\n\t\t\tconst n = e.childCount;\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\trecurse(e.getChild(i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trecurse(t);\r\n\t\treturn nodes;\r\n\t}\r\n\r\n\t/** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex\r\n\t *  inclusively using postorder traversal.  Recursive depth-first-search.\r\n\t *\r\n\t *  @since 4.5\r\n\t */\r\n\tpublic static getRootOfSubtreeEnclosingRegion(\r\n\t\t@NotNull t: ParseTree,\r\n\t\tstartTokenIndex: number, // inclusive\r\n\t\tstopTokenIndex: number, // inclusive\r\n\t): ParserRuleContext | undefined {\r\n\t\tlet n: number = t.childCount;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet child: ParseTree = t.getChild(i);\r\n\t\t\tlet r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\r\n\t\t\tif (r) {\r\n\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (t instanceof ParserRuleContext) {\r\n\t\t\tlet stopToken = t.stop;\r\n\t\t\tif (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?\r\n\t\t\t\t(stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {\r\n\t\t\t\t// note: r.stop==null likely implies that we bailed out of parser and there's nothing to the right\r\n\t\t\t\treturn t;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/** Replace any subtree siblings of root that are completely to left\r\n\t *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,\"...\")\r\n\t *  node. The source interval for t is not altered to suit smaller range!\r\n\t *\r\n\t *  WARNING: destructive to t.\r\n\t *\r\n\t *  @since 4.5.1\r\n\t */\r\n\tpublic static stripChildrenOutOfRange(\r\n\t\tt: ParserRuleContext,\r\n\t\troot: ParserRuleContext,\r\n\t\tstartIndex: number,\r\n\t\tstopIndex: number): void {\r\n\t\tif (!t) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet count = t.childCount;\r\n\t\tfor (let i = 0; i < count; i++) {\r\n\t\t\tlet child = t.getChild(i);\r\n\t\t\tlet range: Interval = child.sourceInterval;\r\n\t\t\tif (child instanceof ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {\r\n\t\t\t\tif (Trees.isAncestorOf(child, root)) { // replace only if subtree doesn't have displayed root\r\n\t\t\t\t\tlet abbrev: CommonToken = new CommonToken(Token.INVALID_TYPE, \"...\");\r\n\t\t\t\t\tt.children![i] = new TerminalNode(abbrev); // HACK access to private\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Return first node satisfying the pred\r\n\t *\r\n\t *  @since 4.5.1\r\n\t */\r\n\tpublic static findNodeSuchThat(t: ParseTree, pred: (tree: ParseTree) => boolean): ParseTree | undefined;\r\n\tpublic static findNodeSuchThat(t: Tree, pred: (tree: Tree) => boolean): Tree | undefined;\r\n\tpublic static findNodeSuchThat(t: Tree, pred: (tree: ParseTree) => boolean): Tree | undefined {\r\n\t\t// No type check needed as long as users only use one of the available overloads\r\n\t\tif (pred(t as ParseTree)) {\r\n\t\t\treturn t;\r\n\t\t}\r\n\r\n\t\tlet n: number =  t.childCount;\r\n\t\tfor (let i = 0 ; i < n ; i++){\r\n\t\t\tlet u = Trees.findNodeSuchThat(t.getChild(i), pred as (tree: Tree) => boolean);\r\n\t\t\tif (u !== undefined) {\r\n\t\t\t\treturn u;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.3490837-07:00\r\n\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { Parser } from \"./Parser\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { RuleNode } from \"./tree/RuleNode\";\r\nimport { ParseTree } from \"./tree/ParseTree\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Override } from \"./Decorators\";\r\nimport { Trees } from \"./tree/Trees\";\r\nimport { ParseTreeVisitor } from \"./tree/ParseTreeVisitor\";\r\nimport { ParserRuleContext } from \"./ParserRuleContext\";\r\n\r\n/** A rule context is a record of a single rule invocation.\r\n *\r\n *  We form a stack of these context objects using the parent\r\n *  pointer. A parent pointer of `undefined` indicates that the current\r\n *  context is the bottom of the stack. The ParserRuleContext subclass\r\n *  as a children list so that we can turn this data structure into a\r\n *  tree.\r\n *\r\n *  The root node always has a `undefined` pointer and invokingState of -1.\r\n *\r\n *  Upon entry to parsing, the first invoked rule function creates a\r\n *  context object (a subclass specialized for that rule such as\r\n *  SContext) and makes it the root of a parse tree, recorded by field\r\n *  Parser._ctx.\r\n *\r\n *  public final SContext s() throws RecognitionException {\r\n *      SContext _localctx = new SContext(_ctx, state); <-- create new node\r\n *      enterRule(_localctx, 0, RULE_s);                     <-- push it\r\n *      ...\r\n *      exitRule();                                          <-- pop back to _localctx\r\n *      return _localctx;\r\n *  }\r\n *\r\n *  A subsequent rule invocation of r from the start rule s pushes a\r\n *  new context object for r whose parent points at s and use invoking\r\n *  state is the state with r emanating as edge label.\r\n *\r\n *  The invokingState fields from a context object to the root\r\n *  together form a stack of rule indication states where the root\r\n *  (bottom of the stack) has a -1 sentinel value. If we invoke start\r\n *  symbol s then call r1, which calls r2, the  would look like\r\n *  this:\r\n *\r\n *     SContext[-1]   <- root node (bottom of the stack)\r\n *     R1Context[p]   <- p in rule s called r1\r\n *     R2Context[q]   <- q in rule r1 called r2\r\n *\r\n *  So the top of the stack, _ctx, represents a call to the current\r\n *  rule and it holds the return address from another rule that invoke\r\n *  to this rule. To invoke a rule, we must always have a current context.\r\n *\r\n *  The parent contexts are useful for computing lookahead sets and\r\n *  getting error information.\r\n *\r\n *  These objects are used during parsing and prediction.\r\n *  For the special case of parsers, we use the subclass\r\n *  ParserRuleContext.\r\n *\r\n *  @see ParserRuleContext\r\n */\r\nexport class RuleContext extends RuleNode {\r\n\tpublic _parent: RuleContext | undefined;\r\n\tpublic invokingState: number;\r\n\r\n\tconstructor();\r\n\tconstructor(parent: RuleContext | undefined, invokingState: number);\r\n\tconstructor(parent?: RuleContext, invokingState?: number) {\r\n\t\tsuper();\r\n\t\tthis._parent = parent;\r\n\t\tthis.invokingState = invokingState != null ? invokingState : -1;\r\n\t}\r\n\r\n\tpublic static getChildContext(parent: RuleContext, invokingState: number): RuleContext {\r\n\t\treturn new RuleContext(parent, invokingState);\r\n\t}\r\n\r\n\tpublic depth(): number {\r\n\t\tlet n = 0;\r\n\t\tlet p: RuleContext | undefined = this;\r\n\t\twhile (p) {\r\n\t\t\tp = p._parent;\r\n\t\t\tn++;\r\n\t\t}\r\n\t\treturn n;\r\n\t}\r\n\r\n\t/** A context is empty if there is no invoking state; meaning nobody called\r\n\t *  current context.\r\n\t */\r\n\tget isEmpty(): boolean {\r\n\t\treturn this.invokingState === -1;\r\n\t}\r\n\r\n\t// satisfy the ParseTree / SyntaxTree interface\r\n\r\n\t@Override\r\n\tget sourceInterval(): Interval {\r\n\t\treturn Interval.INVALID;\r\n\t}\r\n\r\n\t@Override\r\n\tget ruleContext(): RuleContext { return this; }\r\n\r\n\t@Override\r\n\tget parent(): RuleContext | undefined { return this._parent; }\r\n\r\n\t/** @since 4.7. {@see ParseTree#setParent} comment */\r\n\t@Override\r\n\tpublic setParent(parent: RuleContext): void {\r\n\t\tthis._parent = parent;\r\n\t}\r\n\r\n\t@Override\r\n\tget payload(): RuleContext { return this; }\r\n\r\n\t/** Return the combined text of all child nodes. This method only considers\r\n\t *  tokens which have been added to the parse tree.\r\n\t *\r\n\t *  Since tokens on hidden channels (e.g. whitespace or comments) are not\r\n\t *  added to the parse trees, they will not appear in the output of this\r\n\t *  method.\r\n\t */\r\n\t@Override\r\n\tget text(): string {\r\n\t\tif (this.childCount === 0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet builder = \"\";\r\n\t\tfor (let i = 0; i < this.childCount; i++) {\r\n\t\t\tbuilder += this.getChild(i).text;\r\n\t\t}\r\n\r\n\t\treturn builder.toString();\r\n\t}\r\n\r\n\tget ruleIndex(): number { return -1; }\r\n\r\n\t/** For rule associated with this parse tree internal node, return\r\n\t *  the outer alternative number used to match the input. Default\r\n\t *  implementation does not compute nor store this alt num. Create\r\n\t *  a subclass of ParserRuleContext with backing field and set\r\n\t *  option contextSuperClass.\r\n\t *  to set it.\r\n\t *\r\n\t *  @since 4.5.3\r\n\t */\r\n\tget altNumber(): number { return ATN.INVALID_ALT_NUMBER; }\r\n\r\n\t/** Set the outer alternative number for this context node. Default\r\n\t *  implementation does nothing to avoid backing field overhead for\r\n\t *  trees that don't need it.  Create\r\n\t *  a subclass of ParserRuleContext with backing field and set\r\n\t *  option contextSuperClass.\r\n\t *\r\n\t *  @since 4.5.3\r\n\t */\r\n\tset altNumber(altNumber: number) {\r\n\t\t// intentionally ignored by the base implementation\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getChild(i: number): ParseTree {\r\n\t\tthrow new RangeError(\"i must be greater than or equal to 0 and less than childCount\");\r\n\t}\r\n\r\n\t@Override\r\n\tget childCount(): number {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\r\n\t\treturn visitor.visitChildren(this);\r\n\t}\r\n\r\n\t/** Print out a whole tree, not just a node, in LISP format\r\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\r\n\t *  We have to know the recognizer so we can get rule names.\r\n\t */\r\n\tpublic toStringTree(recog: Parser): string;\r\n\r\n\t/** Print out a whole tree, not just a node, in LISP format\r\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\r\n\t */\r\n\tpublic toStringTree(ruleNames: string[] | undefined): string;\r\n\r\n\tpublic toStringTree(): string;\r\n\r\n\t@Override\r\n\tpublic toStringTree(recog?: Parser | string[]): string {\r\n\t\treturn Trees.toStringTree(this, recog);\r\n\t}\r\n\r\n\tpublic toString(): string;\r\n\tpublic toString(recog: Recognizer<any, any> | undefined): string;\r\n\tpublic toString(ruleNames: string[] | undefined): string;\r\n\r\n\t// // recog undefined unless ParserRuleContext, in which case we use subclass toString(...)\r\n\tpublic toString(recog: Recognizer<any, any> | undefined, stop: RuleContext | undefined): string;\r\n\r\n\tpublic toString(ruleNames: string[] | undefined, stop: RuleContext | undefined): string;\r\n\r\n\tpublic toString(\r\n\t\targ1?: Recognizer<any, any> | string[],\r\n\t\tstop?: RuleContext)\r\n\t\t: string {\r\n\t\tconst ruleNames = (arg1 instanceof Recognizer) ? arg1.ruleNames : arg1;\r\n\t\tstop = stop || ParserRuleContext.emptyContext();\r\n\r\n\t\tlet buf = \"\";\r\n\t\tlet p: RuleContext | undefined = this;\r\n\t\tbuf += (\"[\");\r\n\t\twhile (p && p !== stop) {\r\n\t\t\tif (!ruleNames) {\r\n\t\t\t\tif (!p.isEmpty) {\r\n\t\t\t\t\tbuf += (p.invokingState);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tlet ruleIndex: number = p.ruleIndex;\r\n\t\t\t\tlet ruleName: string = (ruleIndex >= 0 && ruleIndex < ruleNames.length)\r\n\t\t\t\t\t? ruleNames[ruleIndex] : ruleIndex.toString();\r\n\t\t\t\tbuf += (ruleName);\r\n\t\t\t}\r\n\r\n\t\t\tif (p._parent && (ruleNames || !p._parent.isEmpty)) {\r\n\t\t\t\tbuf += (\" \");\r\n\t\t\t}\r\n\r\n\t\t\tp = p._parent;\r\n\t\t}\r\n\r\n\t\tbuf += (\"]\");\r\n\t\treturn buf.toString();\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:56.6285494-07:00\r\nimport { ErrorNode } from \"./tree/ErrorNode\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Override } from \"./Decorators\";\r\nimport { Parser } from \"./Parser\";\r\nimport { ParseTree } from \"./tree/ParseTree\";\r\nimport { ParseTreeListener } from \"./tree/ParseTreeListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { TerminalNode } from \"./tree/TerminalNode\";\r\nimport { Token } from \"./Token\";\r\n\r\n/** A rule invocation record for parsing.\r\n *\r\n *  Contains all of the information about the current rule not stored in the\r\n *  RuleContext. It handles parse tree children list, Any ATN state\r\n *  tracing, and the default values available for rule invocations:\r\n *  start, stop, rule index, current alt number.\r\n *\r\n *  Subclasses made for each rule and grammar track the parameters,\r\n *  return values, locals, and labels specific to that rule. These\r\n *  are the objects that are returned from rules.\r\n *\r\n *  Note text is not an actual field of a rule return value; it is computed\r\n *  from start and stop using the input stream's toString() method.  I\r\n *  could add a ctor to this so that we can pass in and store the input\r\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\r\n *  to get the .text property anyway if the rule matches tokens from multiple\r\n *  input streams.\r\n *\r\n *  I do not use getters for fields of objects that are used simply to\r\n *  group values such as this aggregate.  The getters/setters are there to\r\n *  satisfy the superclass interface.\r\n */\r\nexport class ParserRuleContext extends RuleContext {\r\n\tprivate static readonly EMPTY: ParserRuleContext = new ParserRuleContext();\r\n\r\n\t/** If we are debugging or building a parse tree for a visitor,\r\n\t *  we need to track all of the tokens and rule invocations associated\r\n\t *  with this rule's context. This is empty for parsing w/o tree constr.\r\n\t *  operation because we don't the need to track the details about\r\n\t *  how we parse this rule.\r\n\t */\r\n\tpublic children?: ParseTree[];\r\n\r\n\t/** For debugging/tracing purposes, we want to track all of the nodes in\r\n\t *  the ATN traversed by the parser for a particular rule.\r\n\t *  This list indicates the sequence of ATN nodes used to match\r\n\t *  the elements of the children list. This list does not include\r\n\t *  ATN nodes and other rules used to match rule invocations. It\r\n\t *  traces the rule invocation node itself but nothing inside that\r\n\t *  other rule's ATN submachine.\r\n\t *\r\n\t *  There is NOT a one-to-one correspondence between the children and\r\n\t *  states list. There are typically many nodes in the ATN traversed\r\n\t *  for each element in the children list. For example, for a rule\r\n\t *  invocation there is the invoking state and the following state.\r\n\t *\r\n\t *  The parser state property updates field s and adds it to this list\r\n\t *  if we are debugging/tracing.\r\n\t *\r\n\t *  This does not trace states visited during prediction.\r\n\t */\r\n//\tpublic Array<number> states;\r\n\r\n\tpublic _start!: Token;\r\n\tpublic _stop: Token | undefined;\r\n\r\n\t/**\r\n\t * The exception that forced this rule to return. If the rule successfully\r\n\t * completed, this is `undefined`.\r\n\t */\r\n\tpublic exception?: RecognitionException;\r\n\r\n\tconstructor();\r\n\tconstructor(parent: ParserRuleContext | undefined, invokingStateNumber: number);\r\n\tconstructor(parent?: ParserRuleContext, invokingStateNumber?: number) {\r\n\t\tif (invokingStateNumber == null) {\r\n\t\t\tsuper();\r\n\t\t} else {\r\n\t\t\tsuper(parent, invokingStateNumber);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static emptyContext(): ParserRuleContext {\r\n\t\treturn ParserRuleContext.EMPTY;\r\n\t}\r\n\r\n\t/**\r\n\t * COPY a ctx (I'm deliberately not using copy constructor) to avoid\r\n\t * confusion with creating node with parent. Does not copy children\r\n\t * (except error leaves).\r\n\t *\r\n\t * This is used in the generated parser code to flip a generic XContext\r\n\t * node for rule X to a YContext for alt label Y. In that sense, it is not\r\n\t * really a generic copy function.\r\n\t *\r\n\t * If we do an error sync() at start of a rule, we might add error nodes\r\n\t * to the generic XContext so this function must copy those nodes to the\r\n\t * YContext as well else they are lost!\r\n\t */\r\n\tpublic copyFrom(ctx: ParserRuleContext): void {\r\n\t\tthis._parent = ctx._parent;\r\n\t\tthis.invokingState = ctx.invokingState;\r\n\r\n\t\tthis._start = ctx._start;\r\n\t\tthis._stop = ctx._stop;\r\n\r\n\t\t// copy any error nodes to alt label node\r\n\t\tif (ctx.children) {\r\n\t\t\tthis.children = [];\r\n\t\t\t// reset parent pointer for any error nodes\r\n\t\t\tfor (let child of ctx.children) {\r\n\t\t\t\tif (child instanceof ErrorNode) {\r\n\t\t\t\t\tthis.addChild(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Double dispatch methods for listeners\r\n\r\n\tpublic enterRule(listener: ParseTreeListener): void {\r\n\t\t// intentionally empty\r\n\t}\r\n\tpublic exitRule(listener: ParseTreeListener): void {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\t/** Add a parse tree node to this as a child.  Works for\r\n\t *  internal and leaf nodes. Does not set parent link;\r\n\t *  other add methods must do that. Other addChild methods\r\n\t *  call this.\r\n\t *\r\n\t *  We cannot set the parent pointer of the incoming node\r\n\t *  because the existing interfaces do not have a setParent()\r\n\t *  method and I don't want to break backward compatibility for this.\r\n\t *\r\n\t *  @since 4.7\r\n\t */\r\n\tpublic addAnyChild<T extends ParseTree>(t: T): T {\r\n\t\tif (!this.children) {\r\n\t\t\tthis.children = [t];\r\n\t\t} else {\r\n\t\t\tthis.children.push(t);\r\n\t\t}\r\n\r\n\t\treturn t;\r\n\t}\r\n\r\n\t/** Add a token leaf node child and force its parent to be this node. */\r\n\tpublic addChild(t: TerminalNode): void;\r\n\tpublic addChild(ruleInvocation: RuleContext): void;\r\n\t/**\r\n\t * Add a child to this node based upon matchedToken. It\r\n\t * creates a TerminalNodeImpl rather than using\r\n\t * {@link Parser#createTerminalNode(ParserRuleContext, Token)}. I'm leaving this\r\n\t * in for compatibility but the parser doesn't use this anymore.\r\n\t *\r\n\t * @deprecated Use another overload instead.\r\n\t */\r\n\tpublic addChild(matchedToken: Token): TerminalNode;\r\n\tpublic addChild(t: TerminalNode | RuleContext | Token): TerminalNode | void {\r\n\t\tlet result: TerminalNode | void;\r\n\t\tif (t instanceof TerminalNode) {\r\n\t\t\tt.setParent(this);\r\n\t\t\tthis.addAnyChild(t);\r\n\t\t\treturn;\r\n\t\t} else if (t instanceof RuleContext) {\r\n\t\t\t// Does not set parent link\r\n\t\t\tthis.addAnyChild(t);\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\t// Deprecated code path\r\n\t\t\tt = new TerminalNode(t);\r\n\t\t\tthis.addAnyChild(t);\r\n\t\t\tt.setParent(this);\r\n\t\t\treturn t;\r\n\t\t}\r\n\t}\r\n\r\n\t/** Add an error node child and force its parent to be this node.\r\n\t *\r\n\t * @since 4.7\r\n\t */\r\n\tpublic addErrorNode(errorNode: ErrorNode): ErrorNode;\r\n\r\n\t/**\r\n\t * Add a child to this node based upon badToken. It\r\n\t * creates a ErrorNode rather than using\r\n\t * {@link Parser#createErrorNode(ParserRuleContext, Token)}. I'm leaving this\r\n\t * in for compatibility but the parser doesn't use this anymore.\r\n\t *\r\n\t * @deprecated Use another overload instead.\r\n\t */\r\n\tpublic addErrorNode(badToken: Token): ErrorNode;\r\n\tpublic addErrorNode(node: ErrorNode | Token): ErrorNode {\r\n\t\tif (node instanceof ErrorNode) {\r\n\t\t\tconst errorNode: ErrorNode = node;\r\n\t\t\terrorNode.setParent(this);\r\n\t\t\treturn this.addAnyChild(errorNode);\r\n\t\t} else {\r\n\t\t\t// deprecated path\r\n\t\t\tconst badToken: Token = node;\r\n\t\t\tlet t = new ErrorNode(badToken);\r\n\t\t\tthis.addAnyChild(t);\r\n\t\t\tt.setParent(this);\r\n\t\t\treturn t;\r\n\t\t}\r\n\t}\r\n\r\n//\tpublic void trace(int s) {\r\n//\t\tif ( states==null ) states = new ArrayList<Integer>();\r\n//\t\tstates.add(s);\r\n//\t}\r\n\r\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\r\n\t *  we entered a rule. If we have # label, we will need to remove\r\n\t *  generic ruleContext object.\r\n\t */\r\n\tpublic removeLastChild(): void {\r\n\t\tif (this.children) {\r\n\t\t\tthis.children.pop();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\t/** Override to make type more specific */\r\n\tget parent(): ParserRuleContext | undefined {\r\n\t\tlet parent = super.parent;\r\n\t\tif (parent === undefined || parent instanceof ParserRuleContext) {\r\n\t\t\treturn parent;\r\n\t\t}\r\n\r\n\t\tthrow new TypeError(\"Invalid parent type for ParserRuleContext\");\r\n\t}\r\n\r\n\tpublic getChild(i: number): ParseTree;\r\n\tpublic getChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T;\r\n\t// Note: in TypeScript, order or arguments reversed\r\n\tpublic getChild<T extends ParseTree>(i: number, ctxType?: { new (...args: any[]): T; }): ParseTree {\r\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\r\n\t\t\tthrow new RangeError(\"index parameter must be between >= 0 and <= number of children.\");\r\n\t\t}\r\n\r\n\t\tif (ctxType == null) {\r\n\t\t\treturn this.children[i];\r\n\t\t}\r\n\r\n\t\tlet result = this.tryGetChild(i, ctxType);\r\n\t\tif (result === undefined) {\r\n\t\t\tthrow new Error(\"The specified node does not exist\");\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic tryGetChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\r\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet j: number = -1; // what node with ctxType have we found?\r\n\t\tfor (let o of this.children) {\r\n\t\t\tif (o instanceof ctxType) {\r\n\t\t\t\tj++;\r\n\t\t\t\tif (j === i) {\r\n\t\t\t\t\treturn o;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic getToken(ttype: number, i: number): TerminalNode {\r\n\t\tlet result = this.tryGetToken(ttype, i);\r\n\t\tif (result === undefined) {\r\n\t\t\tthrow new Error(\"The specified token does not exist\");\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic tryGetToken(ttype: number, i: number): TerminalNode | undefined {\r\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet j: number = -1; // what token with ttype have we found?\r\n\t\tfor (let o of this.children) {\r\n\t\t\tif (o instanceof TerminalNode) {\r\n\t\t\t\tlet symbol: Token = o.symbol;\r\n\t\t\t\tif (symbol.type === ttype) {\r\n\t\t\t\t\tj++;\r\n\t\t\t\t\tif (j === i) {\r\n\t\t\t\t\t\treturn o;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic getTokens(ttype: number): TerminalNode[] {\r\n\t\tlet tokens: TerminalNode[] = [];\r\n\r\n\t\tif (!this.children) {\r\n\t\t\treturn tokens;\r\n\t\t}\r\n\r\n\t\tfor (let o of this.children) {\r\n\t\t\tif (o instanceof TerminalNode) {\r\n\t\t\t\tlet symbol = o.symbol;\r\n\t\t\t\tif (symbol.type === ttype) {\r\n\t\t\t\t\ttokens.push(o);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tget ruleContext(): this {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t// NOTE: argument order change from Java version\r\n\tpublic getRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T {\r\n\t\treturn this.getChild(i, ctxType);\r\n\t}\r\n\r\n\tpublic tryGetRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\r\n\t\treturn this.tryGetChild(i, ctxType);\r\n\t}\r\n\r\n\tpublic getRuleContexts<T extends ParserRuleContext>(ctxType: { new (...args: any[]): T; }): T[] {\r\n\t\tlet contexts: T[] = [];\r\n\t\tif (!this.children) {\r\n\t\t\treturn contexts;\r\n\t\t}\r\n\r\n\t\tfor (let o of this.children) {\r\n\t\t\tif (o instanceof ctxType) {\r\n\t\t\t\tcontexts.push(o);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn contexts;\r\n\t}\r\n\r\n\t@Override\r\n\tget childCount() {\r\n\t\treturn this.children ? this.children.length : 0;\r\n\t}\r\n\r\n\t@Override\r\n\tget sourceInterval(): Interval {\r\n\t\tif (!this._start) {\r\n\t\t\treturn Interval.INVALID;\r\n\t\t}\r\n\t\tif (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {\r\n\t\t\treturn Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1); // empty\r\n\t\t}\r\n\t\treturn Interval.of(this._start.tokenIndex, this._stop.tokenIndex);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the initial token in this context.\r\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\r\n\t * (for example, zero length or error productions) this token may exceed stop.\r\n\t */\r\n\tget start(): Token { return this._start; }\r\n\t/**\r\n\t * Get the final token in this context.\r\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\r\n\t * (for example, zero length or error productions) this token may precede start.\r\n\t */\r\n\tget stop(): Token | undefined { return this._stop; }\r\n\r\n\t/** Used for rule context info debugging during parse-time, not so much for ATN debugging */\r\n\tpublic toInfoString(recognizer: Parser): string {\r\n\t\tlet rules: string[] =\r\n\t\t\trecognizer.getRuleInvocationStack(this).reverse();\r\n\t\treturn \"ParserRuleContext\" + rules + \"{\" +\r\n\t\t\t\"start=\" + this._start +\r\n\t\t\t\", stop=\" + this._stop +\r\n\t\t\t\"}\";\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["LexerMoreAction", "LexerPopModeAction", "LexerSkipAction", "PredictionMode", "ParserATNSimulator", "predicates", "UnicodeDeserializingMode", "i", "CodePointBuffer", "Type", "CharStreams", "ParserInterpreter", "source", "ParseTreePatternMatcher"]
}
