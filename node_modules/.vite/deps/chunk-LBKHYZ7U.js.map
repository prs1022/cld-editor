{
  "version": 3,
  "sources": ["../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/Array2DHashMap.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/DecisionState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/Arrays.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PredictionContextCache.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/PredictionContext.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNConfig.ts", "browser-external:util", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/BitSet.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNConfigSet.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/dfa/DFAState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNSimulator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ConsoleErrorListener.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/ProxyErrorListener.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/Recognizer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/dfa/DFASerializer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/dfa/LexerDFASerializer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATNStateType.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/StarLoopEntryState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/dfa/DFA.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/IntegerList.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/Interval.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CommonToken.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/CommonTokenFactory.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/IntegerStack.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/dfa/AcceptStateInfo.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerIndexedCustomAction.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerActionExecutor.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/LexerNoViableAltException.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/OrderedATNConfigSet.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/RuleStopState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LexerATNSimulator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/Lexer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/IntervalSet.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/BasicState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/InvalidState.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/SetTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/NotSetTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/RuleTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/WildcardTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/LL1Analyzer.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/ATN.ts"],
  "sourcesContent": ["/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport { Array2DHashSet } from \"./Array2DHashSet\";\r\nimport { DefaultEqualityComparator } from \"./DefaultEqualityComparator\";\r\nimport { EqualityComparator } from \"./EqualityComparator\";\r\nimport { Equatable, JavaCollection, JavaMap, JavaSet } from \"./Stubs\";\r\n\r\n// Since `Array2DHashMap` is implemented on top of `Array2DHashSet`, we defined a bucket type which can store a\r\n// key-value pair. The value is optional since looking up values in the map by a key only needs to include the key.\r\ninterface Bucket<K, V> { key: K; value?: V; }\r\n\r\nclass MapKeyEqualityComparator<K, V> implements EqualityComparator<Bucket<K, V>> {\r\n\tprivate readonly keyComparator: EqualityComparator<K>;\r\n\r\n\tconstructor(keyComparator: EqualityComparator<K>) {\r\n\t\tthis.keyComparator = keyComparator;\r\n\t}\r\n\r\n\tpublic hashCode(obj: Bucket<K, V>): number {\r\n\t\treturn this.keyComparator.hashCode(obj.key);\r\n\t}\r\n\r\n\tpublic equals(a: Bucket<K, V>, b: Bucket<K, V>): boolean {\r\n\t\treturn this.keyComparator.equals(a.key, b.key);\r\n\t}\r\n}\r\n\r\nexport class Array2DHashMap<K, V> implements JavaMap<K, V> {\r\n\tprivate backingStore: Array2DHashSet<Bucket<K, V>>;\r\n\r\n\tconstructor(keyComparer: EqualityComparator<K>);\r\n\tconstructor(map: Array2DHashMap<K, V>);\r\n\tconstructor(keyComparer: EqualityComparator<K> | Array2DHashMap<K, V>) {\r\n\t\tif (keyComparer instanceof Array2DHashMap) {\r\n\t\t\tthis.backingStore = new Array2DHashSet<Bucket<K, V>>(keyComparer.backingStore);\r\n\t\t} else {\r\n\t\t\tthis.backingStore = new Array2DHashSet<Bucket<K, V>>(new MapKeyEqualityComparator<K, V>(keyComparer));\r\n\t\t}\r\n\t}\r\n\r\n\tpublic clear(): void {\r\n\t\tthis.backingStore.clear();\r\n\t}\r\n\r\n\tpublic containsKey(key: K): boolean {\r\n\t\treturn this.backingStore.contains({ key });\r\n\t}\r\n\r\n\tpublic get(key: K): V | undefined {\r\n\t\tlet bucket = this.backingStore.get({ key });\r\n\t\tif (!bucket) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn bucket.value;\r\n\t}\r\n\r\n\tget isEmpty(): boolean {\r\n\t\treturn this.backingStore.isEmpty;\r\n\t}\r\n\r\n\tpublic put(key: K, value: V): V | undefined {\r\n\t\tlet element = this.backingStore.get({ key, value });\r\n\t\tlet result: V | undefined;\r\n\t\tif (!element) {\r\n\t\t\tthis.backingStore.add({ key, value });\r\n\t\t} else {\r\n\t\t\tresult = element.value;\r\n\t\t\telement.value = value;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic putIfAbsent(key: K, value: V): V | undefined {\r\n\t\tlet element = this.backingStore.get({ key, value });\r\n\t\tlet result: V | undefined;\r\n\t\tif (!element) {\r\n\t\t\tthis.backingStore.add({ key, value });\r\n\t\t} else {\r\n\t\t\tresult = element.value;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tget size(): number {\r\n\t\treturn this.backingStore.size;\r\n\t}\r\n\r\n\tpublic hashCode(): number {\r\n\t\treturn this.backingStore.hashCode();\r\n\t}\r\n\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (!(o instanceof Array2DHashMap)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.backingStore.equals(o.backingStore);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.4734328-07:00\r\n\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { Override } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\n\r\nconst INITIAL_NUM_TRANSITIONS: number = 4;\r\n\r\n/**\r\n * The following images show the relation of states and\r\n * {@link ATNState#transitions} for various grammar constructs.\r\n *\r\n * * Solid edges marked with an &#0949; indicate a required\r\n *   {@link EpsilonTransition}.\r\n *\r\n * * Dashed edges indicate locations where any transition derived from\r\n *   {@link Transition} might appear.\r\n *\r\n * * Dashed nodes are place holders for either a sequence of linked\r\n *   {@link BasicState} states or the inclusion of a block representing a nested\r\n *   construct in one of the forms below.\r\n *\r\n * * Nodes showing multiple outgoing alternatives with a `...` support\r\n *   any number of alternatives (one or more). Nodes without the `...` only\r\n *   support the exact number of alternatives shown in the diagram.\r\n *\r\n * <h2>Basic Blocks</h2>\r\n *\r\n * <h3>Rule</h3>\r\n *\r\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h3>Block of 1 or more alternatives</h3>\r\n *\r\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h2>Greedy Loops</h2>\r\n *\r\n * <h3>Greedy Closure: `(...)*`</h3>\r\n *\r\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h3>Greedy Positive Closure: `(...)+`</h3>\r\n *\r\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h3>Greedy Optional: `(...)?`</h3>\r\n *\r\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h2>Non-Greedy Loops</h2>\r\n *\r\n * <h3>Non-Greedy Closure: `(...)*?`</h3>\r\n *\r\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h3>Non-Greedy Positive Closure: `(...)+?`</h3>\r\n *\r\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\r\n *\r\n * <h3>Non-Greedy Optional: `(...)??`</h3>\r\n *\r\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\r\n */\r\nexport abstract class ATNState {\r\n\r\n\t/** Which ATN are we in? */\r\n\tpublic atn?: ATN;\r\n\r\n\tpublic stateNumber: number = ATNState.INVALID_STATE_NUMBER;\r\n\r\n\tpublic ruleIndex: number = 0;  // at runtime, we don't have Rule objects\r\n\r\n\tpublic epsilonOnlyTransitions: boolean = false;\r\n\r\n\t/** Track the transitions emanating from this ATN state. */\r\n\tprotected transitions: Transition[] = [];\r\n\r\n\tprotected optimizedTransitions: Transition[] = this.transitions;\r\n\r\n\t/** Used to cache lookahead during parsing, not used during construction */\r\n\tpublic nextTokenWithinRule?: IntervalSet;\r\n\r\n\t/**\r\n\t * Gets the state number.\r\n\t *\r\n\t * @returns the state number\r\n\t */\r\n\tpublic getStateNumber(): number {\r\n\t\treturn this.stateNumber;\r\n\t}\r\n\r\n\t/**\r\n\t * For all states except {@link RuleStopState}, this returns the state\r\n\t * number. Returns -1 for stop states.\r\n\t *\r\n\t * @returns -1 for {@link RuleStopState}, otherwise the state number\r\n\t */\r\n\tget nonStopStateNumber(): number {\r\n\t\treturn this.getStateNumber();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\treturn this.stateNumber;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\t// are these states same object?\r\n\t\tif (o instanceof ATNState) {\r\n\t\t\treturn this.stateNumber === o.stateNumber;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget isNonGreedyExitState(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn String(this.stateNumber);\r\n\t}\r\n\r\n\tpublic getTransitions(): Transition[] {\r\n\t\treturn this.transitions.slice(0);\r\n\t}\r\n\r\n\tget numberOfTransitions(): number {\r\n\t\treturn this.transitions.length;\r\n\t}\r\n\r\n\tpublic addTransition(e: Transition, index?: number): void {\r\n\t\tif (this.transitions.length === 0) {\r\n\t\t\tthis.epsilonOnlyTransitions = e.isEpsilon;\r\n\t\t}\r\n\t\telse if (this.epsilonOnlyTransitions !== e.isEpsilon) {\r\n\t\t\tthis.epsilonOnlyTransitions = false;\r\n\t\t\tthrow new Error(\"ATN state \" + this.stateNumber + \" has both epsilon and non-epsilon transitions.\");\r\n\t\t}\r\n\r\n\t\tthis.transitions.splice(index !== undefined ? index : this.transitions.length, 0, e);\r\n\t}\r\n\r\n\tpublic transition(i: number): Transition {\r\n\t\treturn this.transitions[i];\r\n\t}\r\n\r\n\tpublic setTransition(i: number, e: Transition): void {\r\n\t\tthis.transitions[i] = e;\r\n\t}\r\n\r\n\tpublic removeTransition(index: number): Transition {\r\n\t\treturn this.transitions.splice(index, 1)[0];\r\n\t}\r\n\r\n\tpublic abstract readonly stateType: ATNStateType;\r\n\r\n\tget onlyHasEpsilonTransitions(): boolean {\r\n\t\treturn this.epsilonOnlyTransitions;\r\n\t}\r\n\r\n\tpublic setRuleIndex(ruleIndex: number): void {\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t}\r\n\r\n\tget isOptimized(): boolean {\r\n\t\treturn this.optimizedTransitions !== this.transitions;\r\n\t}\r\n\r\n\tget numberOfOptimizedTransitions(): number {\r\n\t\treturn this.optimizedTransitions.length;\r\n\t}\r\n\r\n\tpublic getOptimizedTransition(i: number): Transition {\r\n\t\treturn this.optimizedTransitions[i];\r\n\t}\r\n\r\n\tpublic addOptimizedTransition(e: Transition): void {\r\n\t\tif (!this.isOptimized) {\r\n\t\t\tthis.optimizedTransitions = new Array<Transition>();\r\n\t\t}\r\n\r\n\t\tthis.optimizedTransitions.push(e);\r\n\t}\r\n\r\n\tpublic setOptimizedTransition(i: number, e: Transition): void {\r\n\t\tif (!this.isOptimized) {\r\n\t\t\tthrow new Error(\"This ATNState is not optimized.\");\r\n\t\t}\r\n\r\n\t\tthis.optimizedTransitions[i] = e;\r\n\t}\r\n\r\n\tpublic removeOptimizedTransition(i: number): void {\r\n\t\tif (!this.isOptimized) {\r\n\t\t\tthrow new Error(\"This ATNState is not optimized.\");\r\n\t\t}\r\n\r\n\t\tthis.optimizedTransitions.splice(i, 1);\r\n\t}\r\n}\r\n\r\nexport namespace ATNState {\r\n\texport const INVALID_STATE_NUMBER: number = -1;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.4381103-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\n\r\nexport abstract class DecisionState extends ATNState {\r\n\tpublic decision: number = -1;\r\n\tpublic nonGreedy: boolean = false;\r\n\tpublic sll: boolean = false;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nexport namespace Arrays {\r\n\t/**\r\n\t * Searches the specified array of numbers for the specified value using the binary search algorithm. The array must\r\n\t * be sorted prior to making this call. If it is not sorted, the results are unspecified. If the array contains\r\n\t * multiple elements with the specified value, there is no guarantee which one will be found.\r\n\t *\r\n\t * @returns index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The\r\n\t * insertion point is defined as the point at which the key would be inserted into the array: the index of the first\r\n\t * element greater than the key, or array.length if all elements in the array are less than the specified key. Note\r\n\t * that this guarantees that the return value will be >= 0 if and only if the key is found.\r\n\t */\r\n\texport function binarySearch(array: ArrayLike<number>, key: number, fromIndex?: number, toIndex?: number): number {\r\n\t\treturn binarySearch0(array, fromIndex !== undefined ? fromIndex : 0, toIndex !== undefined ? toIndex : array.length, key);\r\n\t}\r\n\r\n\tfunction binarySearch0(array: ArrayLike<number>, fromIndex: number, toIndex: number, key: number): number {\r\n\t\tlet low: number = fromIndex;\r\n\t\tlet high: number = toIndex - 1;\r\n\r\n\t\twhile (low <= high) {\r\n\t\t\tlet mid: number = (low + high) >>> 1;\r\n\t\t\tlet midVal: number = array[mid];\r\n\r\n\t\t\tif (midVal < key) {\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t} else if (midVal > key) {\r\n\t\t\t\thigh = mid - 1;\r\n\t\t\t} else {\r\n\t\t\t\t// key found\r\n\t\t\t\treturn mid;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// key not found.\r\n\t\treturn -(low + 1);\r\n\t}\r\n\r\n\texport function toString<T>(array: Iterable<T>) {\r\n\t\tlet result = \"[\";\r\n\r\n\t\tlet first = true;\r\n\t\tfor (let element of array) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tresult += \", \";\r\n\t\t\t}\r\n\r\n\t\t\tif (element === null) {\r\n\t\t\t\tresult += \"null\";\r\n\t\t\t} else if (element === undefined) {\r\n\t\t\t\tresult += \"undefined\";\r\n\t\t\t} else {\r\n\t\t\t\tresult += element;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult += \"]\";\r\n\t\treturn result;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.6390614-07:00\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { Override } from \"../Decorators\";\r\nimport { JavaMap } from \"../misc/Stubs\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport * as assert from \"assert\";\r\n\r\n/** Used to cache {@link PredictionContext} objects. Its used for the shared\r\n *  context cash associated with contexts in DFA states. This cache\r\n *  can be used for both lexers and parsers.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class PredictionContextCache {\r\n\tpublic static UNCACHED: PredictionContextCache = new PredictionContextCache(false);\r\n\r\n\tprivate contexts: JavaMap<PredictionContext, PredictionContext> =\r\n\t\tnew Array2DHashMap<PredictionContext, PredictionContext>(ObjectEqualityComparator.INSTANCE);\r\n\tprivate childContexts: JavaMap<PredictionContextCache.PredictionContextAndInt, PredictionContext> =\r\n\t\tnew Array2DHashMap<PredictionContextCache.PredictionContextAndInt, PredictionContext>(ObjectEqualityComparator.INSTANCE);\r\n\tprivate joinContexts: JavaMap<PredictionContextCache.IdentityCommutativePredictionContextOperands, PredictionContext> =\r\n\t\tnew Array2DHashMap<PredictionContextCache.IdentityCommutativePredictionContextOperands, PredictionContext>(ObjectEqualityComparator.INSTANCE);\r\n\r\n\tprivate enableCache: boolean;\r\n\r\n\tconstructor(enableCache: boolean = true) {\r\n\t\tthis.enableCache = enableCache;\r\n\t}\r\n\r\n\tpublic getAsCached(context: PredictionContext): PredictionContext {\r\n\t\tif (!this.enableCache) {\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\tlet result = this.contexts.get(context);\r\n\t\tif (!result) {\r\n\t\t\tresult = context;\r\n\t\t\tthis.contexts.put(context, context);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic getChild(context: PredictionContext, invokingState: number): PredictionContext {\r\n\t\tif (!this.enableCache) {\r\n\t\t\treturn context.getChild(invokingState);\r\n\t\t}\r\n\r\n\t\tlet operands: PredictionContextCache.PredictionContextAndInt = new PredictionContextCache.PredictionContextAndInt(context, invokingState);\r\n\t\tlet result = this.childContexts.get(operands);\r\n\t\tif (!result) {\r\n\t\t\tresult = context.getChild(invokingState);\r\n\t\t\tresult = this.getAsCached(result);\r\n\t\t\tthis.childContexts.put(operands, result);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic join(x: PredictionContext, y: PredictionContext): PredictionContext {\r\n\t\tif (!this.enableCache) {\r\n\t\t\treturn PredictionContext.join(x, y, this);\r\n\t\t}\r\n\r\n\t\tlet operands: PredictionContextCache.IdentityCommutativePredictionContextOperands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);\r\n\t\tlet result = this.joinContexts.get(operands);\r\n\t\tif (result) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tresult = PredictionContext.join(x, y, this);\r\n\t\tresult = this.getAsCached(result);\r\n\t\tthis.joinContexts.put(operands, result);\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nexport namespace PredictionContextCache {\r\n\texport class PredictionContextAndInt {\r\n\t\tprivate obj: PredictionContext;\r\n\t\tprivate value: number;\r\n\r\n\t\tconstructor(obj: PredictionContext, value: number) {\r\n\t\t\tthis.obj = obj;\r\n\t\t\tthis.value = value;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(obj: any): boolean {\r\n\t\t\tif (!(obj instanceof PredictionContextAndInt)) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if (obj === this) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tlet other: PredictionContextAndInt = obj;\r\n\t\t\treturn this.value === other.value\r\n\t\t\t\t&& (this.obj === other.obj || (this.obj != null && this.obj.equals(other.obj)));\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\tlet hashCode: number = 5;\r\n\t\t\thashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);\r\n\t\t\thashCode = 7 * hashCode + this.value;\r\n\t\t\treturn hashCode;\r\n\t\t}\r\n\t}\r\n\r\n\texport class IdentityCommutativePredictionContextOperands {\r\n\t\tprivate _x: PredictionContext;\r\n\t\tprivate _y: PredictionContext;\r\n\r\n\t\tconstructor(x: PredictionContext, y: PredictionContext) {\r\n\t\t\tassert(x != null);\r\n\t\t\tassert(y != null);\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t}\r\n\r\n\t\tget x(): PredictionContext {\r\n\t\t\treturn this._x;\r\n\t\t}\r\n\r\n\t\tget y(): PredictionContext {\r\n\t\t\treturn this._y;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(o: any): boolean {\r\n\t\t\tif (!(o instanceof IdentityCommutativePredictionContextOperands)) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if (this === o) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tlet other: IdentityCommutativePredictionContextOperands = o;\r\n\t\t\treturn (this._x === other._x && this._y === other._y) || (this._x === other._y && this._y === other._x);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\treturn this._x.hashCode() ^ this._y.hashCode();\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:35.3812636-07:00\r\n\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { Arrays } from \"../misc/Arrays\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { Equatable, JavaSet } from \"../misc/Stubs\";\r\nimport { PredictionContextCache } from \"./PredictionContextCache\";\r\nimport { Recognizer } from \"../Recognizer\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\nconst INITIAL_HASH: number = 1;\r\n\r\nexport abstract class PredictionContext implements Equatable {\r\n\t/**\r\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\r\n\t * code is computed in parts to match the following reference algorithm.\r\n\t *\r\n\t * ```\r\n\t * private int referenceHashCode() {\r\n\t *   int hash = {@link MurmurHash#initialize MurmurHash.initialize}({@link #INITIAL_HASH});\r\n\t *\r\n\t *   for (int i = 0; i &lt; this.size; i++) {\r\n\t *     hash = {@link MurmurHash#update MurmurHash.update}(hash, {@link #getParent getParent}(i));\r\n\t *   }\r\n\t *\r\n\t *   for (int i = 0; i &lt; this.size; i++) {\r\n\t *     hash = {@link MurmurHash#update MurmurHash.update}(hash, {@link #getReturnState getReturnState}(i));\r\n\t *   }\r\n\t *\r\n\t *   hash = {@link MurmurHash#finish MurmurHash.finish}(hash, 2 * this.size);\r\n\t *   return hash;\r\n\t * }\r\n\t * ```\r\n\t */\r\n\tprivate readonly cachedHashCode: number;\r\n\r\n\tconstructor(cachedHashCode: number) {\r\n\t\tthis.cachedHashCode = cachedHashCode;\r\n\t}\r\n\r\n\tprotected static calculateEmptyHashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\r\n\t\thash = MurmurHash.finish(hash, 0);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\tprotected static calculateSingleHashCode(parent: PredictionContext, returnState: number): number {\r\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\r\n\t\thash = MurmurHash.update(hash, parent);\r\n\t\thash = MurmurHash.update(hash, returnState);\r\n\t\thash = MurmurHash.finish(hash, 2);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\tprotected static calculateHashCode(parents: PredictionContext[], returnStates: number[]): number {\r\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\r\n\r\n\t\tfor (let parent of parents) {\r\n\t\t\thash = MurmurHash.update(hash, parent);\r\n\t\t}\r\n\r\n\t\tfor (let returnState of returnStates) {\r\n\t\t\thash = MurmurHash.update(hash, returnState);\r\n\t\t}\r\n\r\n\t\thash = MurmurHash.finish(hash, 2 * parents.length);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\tpublic abstract readonly size: number;\r\n\r\n\tpublic abstract getReturnState(index: number): number;\r\n\r\n\tpublic abstract findReturnState(returnState: number): number;\r\n\r\n\t// @NotNull\r\n\tpublic abstract getParent(index: number): PredictionContext;\r\n\r\n\tprotected abstract addEmptyContext(): PredictionContext;\r\n\r\n\tprotected abstract removeEmptyContext(): PredictionContext;\r\n\r\n\tpublic static fromRuleContext(atn: ATN, outerContext: RuleContext, fullContext: boolean = true): PredictionContext {\r\n\t\tif (outerContext.isEmpty) {\r\n\t\t\treturn fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\r\n\t\t}\r\n\r\n\t\tlet parent: PredictionContext;\r\n\t\tif (outerContext._parent) {\r\n\t\t\tparent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);\r\n\t\t} else {\r\n\t\t\tparent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\r\n\t\t}\r\n\r\n\t\tlet state: ATNState = atn.states[outerContext.invokingState];\r\n\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\r\n\t\treturn parent.getChild(transition.followState.stateNumber);\r\n\t}\r\n\r\n\tprivate static addEmptyContext(context: PredictionContext): PredictionContext {\r\n\t\treturn context.addEmptyContext();\r\n\t}\r\n\r\n\tprivate static removeEmptyContext(context: PredictionContext): PredictionContext {\r\n\t\treturn context.removeEmptyContext();\r\n\t}\r\n\r\n\tpublic static join(@NotNull context0: PredictionContext, @NotNull context1: PredictionContext, @NotNull contextCache: PredictionContextCache = PredictionContextCache.UNCACHED): PredictionContext {\r\n\t\tif (context0 === context1) {\r\n\t\t\treturn context0;\r\n\t\t}\r\n\r\n\t\tif (context0.isEmpty) {\r\n\t\t\treturn PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);\r\n\t\t} else if (context1.isEmpty) {\r\n\t\t\treturn PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);\r\n\t\t}\r\n\r\n\t\tlet context0size: number = context0.size;\r\n\t\tlet context1size: number = context1.size;\r\n\t\tif (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {\r\n\t\t\tlet merged: PredictionContext = contextCache.join(context0.getParent(0), context1.getParent(0));\r\n\t\t\tif (merged === context0.getParent(0)) {\r\n\t\t\t\treturn context0;\r\n\t\t\t} else if (merged === context1.getParent(0)) {\r\n\t\t\t\treturn context1;\r\n\t\t\t} else {\r\n\t\t\t\treturn merged.getChild(context0.getReturnState(0));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet count: number = 0;\r\n\t\tlet parentsList: PredictionContext[] = new Array<PredictionContext>(context0size + context1size);\r\n\t\tlet returnStatesList: number[] = new Array<number>(parentsList.length);\r\n\t\tlet leftIndex: number = 0;\r\n\t\tlet rightIndex: number = 0;\r\n\t\tlet canReturnLeft: boolean = true;\r\n\t\tlet canReturnRight: boolean = true;\r\n\t\twhile (leftIndex < context0size && rightIndex < context1size) {\r\n\t\t\tif (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {\r\n\t\t\t\tparentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));\r\n\t\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\r\n\t\t\t\tcanReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);\r\n\t\t\t\tcanReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);\r\n\t\t\t\tleftIndex++;\r\n\t\t\t\trightIndex++;\r\n\t\t\t} else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {\r\n\t\t\t\tparentsList[count] = context0.getParent(leftIndex);\r\n\t\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\r\n\t\t\t\tcanReturnRight = false;\r\n\t\t\t\tleftIndex++;\r\n\t\t\t} else {\r\n\t\t\t\tassert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));\r\n\t\t\t\tparentsList[count] = context1.getParent(rightIndex);\r\n\t\t\t\treturnStatesList[count] = context1.getReturnState(rightIndex);\r\n\t\t\t\tcanReturnLeft = false;\r\n\t\t\t\trightIndex++;\r\n\t\t\t}\r\n\r\n\t\t\tcount++;\r\n\t\t}\r\n\r\n\t\twhile (leftIndex < context0size) {\r\n\t\t\tparentsList[count] = context0.getParent(leftIndex);\r\n\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\r\n\t\t\tleftIndex++;\r\n\t\t\tcanReturnRight = false;\r\n\t\t\tcount++;\r\n\t\t}\r\n\r\n\t\twhile (rightIndex < context1size) {\r\n\t\t\tparentsList[count] = context1.getParent(rightIndex);\r\n\t\t\treturnStatesList[count] = context1.getReturnState(rightIndex);\r\n\t\t\trightIndex++;\r\n\t\t\tcanReturnLeft = false;\r\n\t\t\tcount++;\r\n\t\t}\r\n\r\n\t\tif (canReturnLeft) {\r\n\t\t\treturn context0;\r\n\t\t} else if (canReturnRight) {\r\n\t\t\treturn context1;\r\n\t\t}\r\n\r\n\t\tif (count < parentsList.length) {\r\n\t\t\tparentsList = parentsList.slice(0, count);\r\n\t\t\treturnStatesList = returnStatesList.slice(0, count);\r\n\t\t}\r\n\r\n\t\tif (parentsList.length === 0) {\r\n\t\t\t// if one of them was EMPTY_LOCAL, it would be empty and handled at the beginning of the method\r\n\t\t\treturn PredictionContext.EMPTY_FULL;\r\n\t\t} else if (parentsList.length === 1) {\r\n\t\t\treturn new SingletonPredictionContext(parentsList[0], returnStatesList[0]);\r\n\t\t} else {\r\n\t\t\treturn new ArrayPredictionContext(parentsList, returnStatesList);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static isEmptyLocal(context: PredictionContext): boolean {\r\n\t\treturn context === PredictionContext.EMPTY_LOCAL;\r\n\t}\r\n\r\n\tpublic static getCachedContext(\r\n\t\t@NotNull context: PredictionContext,\r\n\t\t@NotNull contextCache: Array2DHashMap<PredictionContext, PredictionContext>,\r\n\t\t@NotNull visited: PredictionContext.IdentityHashMap): PredictionContext {\r\n\t\tif (context.isEmpty) {\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\tlet existing = visited.get(context);\r\n\t\tif (existing) {\r\n\t\t\treturn existing;\r\n\t\t}\r\n\r\n\t\texisting = contextCache.get(context);\r\n\t\tif (existing) {\r\n\t\t\tvisited.put(context, existing);\r\n\t\t\treturn existing;\r\n\t\t}\r\n\r\n\t\tlet changed: boolean = false;\r\n\t\tlet parents: PredictionContext[] = new Array<PredictionContext>(context.size);\r\n\t\tfor (let i = 0; i < parents.length; i++) {\r\n\t\t\tlet parent: PredictionContext = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);\r\n\t\t\tif (changed || parent !== context.getParent(i)) {\r\n\t\t\t\tif (!changed) {\r\n\t\t\t\t\tparents = new Array<PredictionContext>(context.size);\r\n\t\t\t\t\tfor (let j = 0; j < context.size; j++) {\r\n\t\t\t\t\t\tparents[j] = context.getParent(j);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparents[i] = parent;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!changed) {\r\n\t\t\texisting = contextCache.putIfAbsent(context, context);\r\n\t\t\tvisited.put(context, existing != null ? existing : context);\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\t// We know parents.length>0 because context.isEmpty is checked at the beginning of the method.\r\n\t\tlet updated: PredictionContext;\r\n\t\tif (parents.length === 1) {\r\n\t\t\tupdated = new SingletonPredictionContext(parents[0], context.getReturnState(0));\r\n\t\t} else {\r\n\t\t\tlet returnStates: number[] = new Array<number>(context.size);\r\n\t\t\tfor (let i = 0; i < context.size; i++) {\r\n\t\t\t\treturnStates[i] = context.getReturnState(i);\r\n\t\t\t}\r\n\r\n\t\t\tupdated = new ArrayPredictionContext(parents, returnStates, context.hashCode());\r\n\t\t}\r\n\r\n\t\texisting = contextCache.putIfAbsent(updated, updated);\r\n\t\tvisited.put(updated, existing || updated);\r\n\t\tvisited.put(context, existing || updated);\r\n\r\n\t\treturn updated;\r\n\t}\r\n\r\n\tpublic appendSingleContext(returnContext: number, contextCache: PredictionContextCache): PredictionContext {\r\n\t\treturn this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);\r\n\t}\r\n\r\n\tpublic abstract appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext;\r\n\r\n\tpublic getChild(returnState: number): PredictionContext {\r\n\t\treturn new SingletonPredictionContext(this, returnState);\r\n\t}\r\n\r\n\tpublic abstract readonly isEmpty: boolean;\r\n\r\n\tpublic abstract readonly hasEmpty: boolean;\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\treturn this.cachedHashCode;\r\n\t}\r\n\r\n\t// @Override\r\n\tpublic abstract equals(o: any): boolean;\r\n\r\n\tpublic toStrings(recognizer: Recognizer<any, any> | undefined, currentState: number, stop: PredictionContext = PredictionContext.EMPTY_FULL): string[] {\r\n\t\tlet result: string[] = [];\r\n\r\n\t\touter:\r\n\t\tfor (let perm = 0; ; perm++) {\r\n\t\t\tlet offset: number = 0;\r\n\t\t\tlet last: boolean = true;\r\n\t\t\tlet p: PredictionContext = this;\r\n\t\t\tlet stateNumber: number = currentState;\r\n\t\t\tlet localBuffer: string = \"\";\r\n\t\t\tlocalBuffer += \"[\";\r\n\t\t\twhile (!p.isEmpty && p !== stop) {\r\n\t\t\t\tlet index: number = 0;\r\n\t\t\t\tif (p.size > 0) {\r\n\t\t\t\t\tlet bits: number = 1;\r\n\t\t\t\t\twhile (((1 << bits) >>> 0) < p.size) {\r\n\t\t\t\t\t\tbits++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet mask: number = ((1 << bits) >>> 0) - 1;\r\n\t\t\t\t\tindex = (perm >> offset) & mask;\r\n\t\t\t\t\tlast = last && index >= p.size - 1;\r\n\t\t\t\t\tif (index >= p.size) {\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toffset += bits;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (recognizer) {\r\n\t\t\t\t\tif (localBuffer.length > 1) {\r\n\t\t\t\t\t\t// first char is '[', if more than that this isn't the first rule\r\n\t\t\t\t\t\tlocalBuffer += \" \";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet atn: ATN = recognizer.atn;\r\n\t\t\t\t\tlet s: ATNState = atn.states[stateNumber];\r\n\t\t\t\t\tlet ruleName: string = recognizer.ruleNames[s.ruleIndex];\r\n\t\t\t\t\tlocalBuffer += ruleName;\r\n\t\t\t\t} else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\t\tif (!p.isEmpty) {\r\n\t\t\t\t\t\tif (localBuffer.length > 1) {\r\n\t\t\t\t\t\t\t// first char is '[', if more than that this isn't the first rule\r\n\t\t\t\t\t\t\tlocalBuffer += \" \";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlocalBuffer += p.getReturnState(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstateNumber = p.getReturnState(index);\r\n\t\t\t\tp = p.getParent(index);\r\n\t\t\t}\r\n\r\n\t\t\tlocalBuffer += \"]\";\r\n\t\t\tresult.push(localBuffer);\r\n\r\n\t\t\tif (last) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nclass EmptyPredictionContext extends PredictionContext {\r\n\tprivate fullContext: boolean;\r\n\r\n\tconstructor(fullContext: boolean) {\r\n\t\tsuper(PredictionContext.calculateEmptyHashCode());\r\n\t\tthis.fullContext = fullContext;\r\n\t}\r\n\r\n\tget isFullContext(): boolean {\r\n\t\treturn this.fullContext;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected addEmptyContext(): PredictionContext {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected removeEmptyContext(): PredictionContext {\r\n\t\tthrow new Error(\"Cannot remove the empty context from itself.\");\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getParent(index: number): PredictionContext {\r\n\t\tthrow new Error(\"index out of bounds\");\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getReturnState(index: number): number {\r\n\t\tthrow new Error(\"index out of bounds\");\r\n\t}\r\n\r\n\t@Override\r\n\tpublic findReturnState(returnState: number): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic appendSingleContext(returnContext: number, contextCache: PredictionContextCache): PredictionContext {\r\n\t\treturn contextCache.getChild(this, returnContext);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\r\n\t\treturn suffix;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEmpty(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tget hasEmpty(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\treturn this === o;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toStrings(recognizer: any, currentState: number, stop?: PredictionContext): string[] {\r\n\t\treturn [\"[]\"];\r\n\t}\r\n\r\n}\r\n\r\nclass ArrayPredictionContext extends PredictionContext {\r\n\t@NotNull\r\n\tpublic parents: PredictionContext[];\r\n\r\n\t@NotNull\r\n\tpublic returnStates: number[];\r\n\r\n\tconstructor( @NotNull parents: PredictionContext[], returnStates: number[], hashCode?: number) {\r\n\t\tsuper(hashCode || PredictionContext.calculateHashCode(parents, returnStates));\r\n\t\tassert(parents.length === returnStates.length);\r\n\t\tassert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, \"Should be using PredictionContext.EMPTY instead.\");\r\n\r\n\t\tthis.parents = parents;\r\n\t\tthis.returnStates = returnStates;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getParent(index: number): PredictionContext {\r\n\t\treturn this.parents[index];\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getReturnState(index: number): number {\r\n\t\treturn this.returnStates[index];\r\n\t}\r\n\r\n\t@Override\r\n\tpublic findReturnState(returnState: number): number {\r\n\t\treturn Arrays.binarySearch(this.returnStates, returnState);\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn this.returnStates.length;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEmpty(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tget hasEmpty(): boolean {\r\n\t\treturn this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected addEmptyContext(): PredictionContext {\r\n\t\tif (this.hasEmpty) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tlet parents2: PredictionContext[] = this.parents.slice(0);\r\n\t\tlet returnStates2: number[] = this.returnStates.slice(0);\r\n\t\tparents2.push(PredictionContext.EMPTY_FULL);\r\n\t\treturnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);\r\n\t\treturn new ArrayPredictionContext(parents2, returnStates2);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected removeEmptyContext(): PredictionContext {\r\n\t\tif (!this.hasEmpty) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (this.returnStates.length === 2) {\r\n\t\t\treturn new SingletonPredictionContext(this.parents[0], this.returnStates[0]);\r\n\t\t} else {\r\n\t\t\tlet parents2: PredictionContext[] = this.parents.slice(0, this.parents.length - 1);\r\n\t\t\tlet returnStates2: number[] = this.returnStates.slice(0, this.returnStates.length - 1);\r\n\t\t\treturn new ArrayPredictionContext(parents2, returnStates2);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\r\n\t\treturn ArrayPredictionContext.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());\r\n\t}\r\n\r\n\tprivate static appendContextImpl(context: PredictionContext, suffix: PredictionContext, visited: PredictionContext.IdentityHashMap): PredictionContext {\r\n\t\tif (suffix.isEmpty) {\r\n\t\t\tif (PredictionContext.isEmptyLocal(suffix)) {\r\n\t\t\t\tif (context.hasEmpty) {\r\n\t\t\t\t\treturn PredictionContext.EMPTY_LOCAL;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow new Error(\"what to do here?\");\r\n\t\t\t}\r\n\r\n\t\t\treturn context;\r\n\t\t}\r\n\r\n\t\tif (suffix.size !== 1) {\r\n\t\t\tthrow new Error(\"Appending a tree suffix is not yet supported.\");\r\n\t\t}\r\n\r\n\t\tlet result = visited.get(context);\r\n\t\tif (!result) {\r\n\t\t\tif (context.isEmpty) {\r\n\t\t\t\tresult = suffix;\r\n\t\t\t} else {\r\n\t\t\t\tlet parentCount: number = context.size;\r\n\t\t\t\tif (context.hasEmpty) {\r\n\t\t\t\t\tparentCount--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet updatedParents: PredictionContext[] = new Array<PredictionContext>(parentCount);\r\n\t\t\t\tlet updatedReturnStates: number[] = new Array<number>(parentCount);\r\n\t\t\t\tfor (let i = 0; i < parentCount; i++) {\r\n\t\t\t\t\tupdatedReturnStates[i] = context.getReturnState(i);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let i = 0; i < parentCount; i++) {\r\n\t\t\t\t\tupdatedParents[i] = ArrayPredictionContext.appendContextImpl(context.getParent(i), suffix, visited);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (updatedParents.length === 1) {\r\n\t\t\t\t\tresult = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(updatedParents.length > 1);\r\n\t\t\t\t\tresult = new ArrayPredictionContext(updatedParents, updatedReturnStates);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (context.hasEmpty) {\r\n\t\t\t\t\tresult = PredictionContext.join(result, suffix);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvisited.put(context, result);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (this === o) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(o instanceof ArrayPredictionContext)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this.hashCode() !== o.hashCode()) {\r\n\t\t\t// can't be same if hash is different\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet other: ArrayPredictionContext = o;\r\n\t\treturn this.equalsImpl(other, new Array2DHashSet<PredictionContextCache.IdentityCommutativePredictionContextOperands>());\r\n\t}\r\n\r\n\tprivate equalsImpl(other: ArrayPredictionContext, visited: JavaSet<PredictionContextCache.IdentityCommutativePredictionContextOperands>): boolean {\r\n\t\tlet selfWorkList: PredictionContext[] = [];\r\n\t\tlet otherWorkList: PredictionContext[] = [];\r\n\t\tselfWorkList.push(this);\r\n\t\totherWorkList.push(other);\r\n\t\twhile (true) {\r\n\t\t\tlet currentSelf = selfWorkList.pop();\r\n\t\t\tlet currentOther = otherWorkList.pop();\r\n\t\t\tif (!currentSelf || !currentOther) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tlet operands: PredictionContextCache.IdentityCommutativePredictionContextOperands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);\r\n\t\t\tif (!visited.add(operands)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet selfSize: number = operands.x.size;\r\n\t\t\tif (selfSize === 0) {\r\n\t\t\t\tif (!operands.x.equals(operands.y)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet otherSize: number = operands.y.size;\r\n\t\t\tif (selfSize !== otherSize) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < selfSize; i++) {\r\n\t\t\t\tif (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet selfParent: PredictionContext = operands.x.getParent(i);\r\n\t\t\t\tlet otherParent: PredictionContext = operands.y.getParent(i);\r\n\t\t\t\tif (selfParent.hashCode() !== otherParent.hashCode()) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (selfParent !== otherParent) {\r\n\t\t\t\t\tselfWorkList.push(selfParent);\r\n\t\t\t\t\totherWorkList.push(otherParent);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nexport class SingletonPredictionContext extends PredictionContext {\r\n\r\n\t@NotNull\r\n\tpublic parent: PredictionContext;\r\n\tpublic returnState: number;\r\n\r\n\tconstructor(@NotNull parent: PredictionContext, returnState: number) {\r\n\t\tsuper(PredictionContext.calculateSingleHashCode(parent, returnState));\r\n\t\t// assert(returnState != PredictionContext.EMPTY_FULL_STATE_KEY && returnState != PredictionContext.EMPTY_LOCAL_STATE_KEY);\r\n\t\tthis.parent = parent;\r\n\t\tthis.returnState = returnState;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getParent(index: number): PredictionContext {\r\n\t\t// assert(index == 0);\r\n\t\treturn this.parent;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic getReturnState(index: number): number {\r\n\t\t// assert(index == 0);\r\n\t\treturn this.returnState;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic findReturnState(returnState: number): number {\r\n\t\treturn this.returnState === returnState ? 0 : -1;\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEmpty(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tget hasEmpty(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\r\n\t\treturn contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected addEmptyContext(): PredictionContext {\r\n\t\tlet parents: PredictionContext[] = [this.parent, PredictionContext.EMPTY_FULL];\r\n\t\tlet returnStates: number[] = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];\r\n\t\treturn new ArrayPredictionContext(parents, returnStates);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected removeEmptyContext(): PredictionContext {\r\n\t\treturn this;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (o === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(o instanceof SingletonPredictionContext)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet other: SingletonPredictionContext = o;\r\n\t\tif (this.hashCode() !== other.hashCode()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.returnState === other.returnState\r\n\t\t\t&& this.parent.equals(other.parent);\r\n\t}\r\n}\r\n\r\nexport namespace PredictionContext {\r\n\texport const EMPTY_LOCAL: PredictionContext = new EmptyPredictionContext(false);\r\n\texport const EMPTY_FULL: PredictionContext = new EmptyPredictionContext(true);\r\n\texport const EMPTY_LOCAL_STATE_KEY: number = -((1 << 31) >>> 0);\r\n\texport const EMPTY_FULL_STATE_KEY: number = ((1 << 31) >>> 0) - 1;\r\n\r\n\texport class IdentityHashMap extends Array2DHashMap<PredictionContext, PredictionContext> {\r\n\t\tconstructor() {\r\n\t\t\tsuper(IdentityEqualityComparator.INSTANCE);\r\n\t\t}\r\n\t}\r\n\r\n\texport class IdentityEqualityComparator implements EqualityComparator<PredictionContext> {\r\n\t\tpublic static readonly INSTANCE: IdentityEqualityComparator = new IdentityEqualityComparator();\r\n\r\n\t\tprivate IdentityEqualityComparator() {\r\n\t\t\t// intentionally empty\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(obj: PredictionContext): number {\r\n\t\t\treturn obj.hashCode();\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(a: PredictionContext, b: PredictionContext): boolean {\r\n\t\t\treturn a === b;\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:25.2796692-07:00\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { Equatable } from \"../misc/Stubs\";\r\nimport { LexerActionExecutor } from \"./LexerActionExecutor\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { PredictionContextCache } from \"./PredictionContextCache\";\r\nimport { Recognizer } from \"../Recognizer\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\n/**\r\n * This field stores the bit mask for implementing the\r\n * {@link #isPrecedenceFilterSuppressed} property as a bit within the\r\n * existing {@link #altAndOuterContextDepth} field.\r\n */\r\nconst SUPPRESS_PRECEDENCE_FILTER: number = 0x80000000;\r\n\r\n/**\r\n * Represents a location with context in an ATN. The location is identified by the following values:\r\n *\r\n * * The current ATN state\r\n * * The predicted alternative\r\n * * The semantic context which must be true for this configuration to be enabled\r\n * * The syntactic context, which is represented as a graph-structured stack whose path(s) lead to the root of the rule\r\n *   invocations leading to this state\r\n *\r\n * In addition to these values, `ATNConfig` stores several properties about paths taken to get to the location which\r\n * were added over time to help with performance, correctness, and/or debugging.\r\n *\r\n * * `reachesIntoOuterContext`:: Used to ensure semantic predicates are not evaluated in the wrong context.\r\n * * `hasPassedThroughNonGreedyDecision`: Used for enabling first-match-wins instead of longest-match-wins after\r\n *   crossing a non-greedy decision.\r\n * * `lexerActionExecutor`: Used for tracking the lexer action(s) to execute should this instance be selected during\r\n *   lexing.\r\n * * `isPrecedenceFilterSuppressed`: A state variable for one of the dynamic disambiguation strategies employed by\r\n *   `ParserATNSimulator.applyPrecedenceFilter`.\r\n *\r\n * Due to the use of a graph-structured stack, a single `ATNConfig` is capable of representing many individual ATN\r\n * configurations which reached the same location in an ATN by following different paths.\r\n *\r\n * PERF: To conserve memory, `ATNConfig` is split into several different concrete types. `ATNConfig` itself stores the\r\n * minimum amount of information typically used to define an `ATNConfig` instance. Various derived types provide\r\n * additional storage space for cases where a non-default value is used for some of the object properties. The\r\n * `ATNConfig.create` and `ATNConfig.transform` methods automatically select the smallest concrete type capable of\r\n * representing the unique information for any given `ATNConfig`.\r\n */\r\nexport class ATNConfig implements Equatable {\r\n\t/** The ATN state associated with this configuration */\r\n\t@NotNull\r\n\tprivate _state: ATNState;\r\n\r\n\t/**\r\n\t * This is a bit-field currently containing the following values.\r\n\t *\r\n\t * * 0x00FFFFFF: Alternative\r\n\t * * 0x7F000000: Outer context depth\r\n\t * * 0x80000000: Suppress precedence filter\r\n\t */\r\n\tprivate altAndOuterContextDepth: number;\r\n\r\n\t/** The stack of invoking states leading to the rule/states associated\r\n\t *  with this config.  We track only those contexts pushed during\r\n\t *  execution of the ATN simulator.\r\n\t */\r\n\t@NotNull\r\n\tprivate _context: PredictionContext;\r\n\r\n\tconstructor(/*@NotNull*/ state: ATNState, alt: number, /*@NotNull*/ context: PredictionContext);\r\n\tconstructor(/*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, /*@NotNull*/ context: PredictionContext);\r\n\r\n\tconstructor(@NotNull state: ATNState, altOrConfig: number | ATNConfig, @NotNull context: PredictionContext) {\r\n\t\tif (typeof altOrConfig === \"number\") {\r\n\t\t\tassert((altOrConfig & 0xFFFFFF) === altOrConfig);\r\n\t\t\tthis._state = state;\r\n\t\t\tthis.altAndOuterContextDepth = altOrConfig;\r\n\t\t\tthis._context = context;\r\n\t\t} else {\r\n\t\t\tthis._state = state;\r\n\t\t\tthis.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;\r\n\t\t\tthis._context = context;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext): ATNConfig;\r\n\r\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, /*@NotNull*/ semanticContext: SemanticContext): ATNConfig;\r\n\r\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, /*@*/ semanticContext: SemanticContext, lexerActionExecutor: LexerActionExecutor | undefined): ATNConfig;\r\n\r\n\tpublic static create(@NotNull state: ATNState, alt: number, context: PredictionContext, @NotNull semanticContext: SemanticContext = SemanticContext.NONE, lexerActionExecutor?: LexerActionExecutor): ATNConfig {\r\n\t\tif (semanticContext !== SemanticContext.NONE) {\r\n\t\t\tif (lexerActionExecutor != null) {\r\n\t\t\t\treturn new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn new SemanticContextATNConfig(semanticContext, state, alt, context);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (lexerActionExecutor != null) {\r\n\t\t\treturn new ActionATNConfig(lexerActionExecutor, state, alt, context, false);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn new ATNConfig(state, alt, context);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Gets the ATN state associated with this configuration */\r\n\t@NotNull\r\n\tget state(): ATNState {\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\t/** What alt (or lexer rule) is predicted by this configuration */\r\n\tget alt(): number {\r\n\t\treturn this.altAndOuterContextDepth & 0x00FFFFFF;\r\n\t}\r\n\r\n\t@NotNull\r\n\tget context(): PredictionContext {\r\n\t\treturn this._context;\r\n\t}\r\n\r\n\tset context(@NotNull context: PredictionContext) {\r\n\t\tthis._context = context;\r\n\t}\r\n\r\n\tget reachesIntoOuterContext(): boolean {\r\n\t\treturn this.outerContextDepth !== 0;\r\n\t}\r\n\r\n\t/**\r\n\t * We cannot execute predicates dependent upon local context unless\r\n\t * we know for sure we are in the correct context. Because there is\r\n\t * no way to do this efficiently, we simply cannot evaluate\r\n\t * dependent predicates unless we are in the rule that initially\r\n\t * invokes the ATN simulator.\r\n\t *\r\n\t * closure() tracks the depth of how far we dip into the outer context:\r\n\t * depth &gt; 0.  Note that it may not be totally accurate depth since I\r\n\t * don't ever decrement. TODO: make it a boolean then\r\n\t */\r\n\tget outerContextDepth(): number {\r\n\t\treturn (this.altAndOuterContextDepth >>> 24) & 0x7F;\r\n\t}\r\n\r\n\tset outerContextDepth(outerContextDepth: number) {\r\n\t\tassert(outerContextDepth >= 0);\r\n\t\t// saturate at 0x7F - everything but zero/positive is only used for debug information anyway\r\n\t\touterContextDepth = Math.min(outerContextDepth, 0x7F);\r\n\t\tthis.altAndOuterContextDepth = ((outerContextDepth << 24) | (this.altAndOuterContextDepth & ~0x7F000000) >>> 0);\r\n\t}\r\n\r\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t@NotNull\r\n\tget semanticContext(): SemanticContext {\r\n\t\treturn SemanticContext.NONE;\r\n\t}\r\n\r\n\tget hasPassedThroughNonGreedyDecision(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic clone(): ATNConfig {\r\n\t\treturn this.transform(this.state, false);\r\n\t}\r\n\r\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean): ATNConfig;\r\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, /*@NotNull*/ semanticContext: SemanticContext): ATNConfig;\r\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, context: PredictionContext): ATNConfig;\r\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, lexerActionExecutor: LexerActionExecutor): ATNConfig;\r\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, arg2?: SemanticContext | PredictionContext | LexerActionExecutor): ATNConfig {\r\n\t\tif (arg2 == null) {\r\n\t\t\treturn this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\r\n\t\t} else if (arg2 instanceof PredictionContext) {\r\n\t\t\treturn this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\r\n\t\t} else if (arg2 instanceof SemanticContext) {\r\n\t\t\treturn this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);\r\n\t\t} else {\r\n\t\t\treturn this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate transformImpl(@NotNull state: ATNState, context: PredictionContext, @NotNull semanticContext: SemanticContext, checkNonGreedy: boolean, lexerActionExecutor: LexerActionExecutor | undefined): ATNConfig {\r\n\t\tlet passedThroughNonGreedy: boolean = checkNonGreedy && ATNConfig.checkNonGreedyDecision(this, state);\r\n\t\tif (semanticContext !== SemanticContext.NONE) {\r\n\t\t\tif (lexerActionExecutor != null || passedThroughNonGreedy) {\r\n\t\t\t\treturn new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn new SemanticContextATNConfig(semanticContext, state, this, context);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (lexerActionExecutor != null || passedThroughNonGreedy) {\r\n\t\t\treturn new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn new ATNConfig(state, this, context);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate static checkNonGreedyDecision(source: ATNConfig, target: ATNState): boolean {\r\n\t\treturn source.hasPassedThroughNonGreedyDecision\r\n\t\t\t|| target instanceof DecisionState && target.nonGreedy;\r\n\t}\r\n\r\n\tpublic appendContext(context: number, contextCache: PredictionContextCache): ATNConfig;\r\n\tpublic appendContext(context: PredictionContext, contextCache: PredictionContextCache): ATNConfig;\r\n\tpublic appendContext(context: number | PredictionContext, contextCache: PredictionContextCache): ATNConfig {\r\n\t\tif (typeof context === \"number\") {\r\n\t\t\tlet appendedContext: PredictionContext = this.context.appendSingleContext(context, contextCache);\r\n\t\t\tlet result: ATNConfig = this.transform(this.state, false, appendedContext);\r\n\t\t\treturn result;\r\n\t\t} else {\r\n\t\t\tlet appendedContext: PredictionContext = this.context.appendContext(context, contextCache);\r\n\t\t\tlet result: ATNConfig = this.transform(this.state, false, appendedContext);\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if this `ATNConfig` fully contains another `ATNConfig`.\r\n\t *\r\n\t * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores\r\n\t * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which\r\n\t * are all in the same \"location\" but have different contexts. These `ATNConfig` instances are again merged when\r\n\t * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a\r\n\t * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.\r\n\t *\r\n\t * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:\r\n\t *\r\n\t * * The configurations are in the same state (`state`)\r\n\t * * The configurations predict the same alternative (`alt`)\r\n\t * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)\r\n\t * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_\r\n\t *\r\n\t * This method implements a conservative approximation of containment. As a result, when this method returns `true`\r\n\t * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized\r\n\t * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic\r\n\t * contexts, no assumptions can be made about the relationship between the configurations when this method returns\r\n\t * `false`.\r\n\t *\r\n\t * @param subconfig The sub configuration.\r\n\t * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.\r\n\t */\r\n\tpublic contains(subconfig: ATNConfig): boolean {\r\n\t\tif (this.state.stateNumber !== subconfig.state.stateNumber\r\n\t\t\t|| this.alt !== subconfig.alt\r\n\t\t\t|| !this.semanticContext.equals(subconfig.semanticContext)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet leftWorkList: PredictionContext[] = [];\r\n\t\tlet rightWorkList: PredictionContext[] = [];\r\n\t\tleftWorkList.push(this.context);\r\n\t\trightWorkList.push(subconfig.context);\r\n\t\twhile (true) {\r\n\t\t\tlet left = leftWorkList.pop();\r\n\t\t\tlet right = rightWorkList.pop();\r\n\t\t\tif (!left || !right) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (left === right) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (left.size < right.size) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (right.isEmpty) {\r\n\t\t\t\treturn left.hasEmpty;\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < right.size; i++) {\r\n\t\t\t\t\tlet index: number = left.findReturnState(right.getReturnState(i));\r\n\t\t\t\t\tif (index < 0) {\r\n\t\t\t\t\t\t// assumes invokingStates has no duplicate entries\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftWorkList.push(left.getParent(index));\r\n\t\t\t\t\trightWorkList.push(right.getParent(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget isPrecedenceFilterSuppressed(): boolean {\r\n\t\treturn (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;\r\n\t}\r\n\r\n\tset isPrecedenceFilterSuppressed(value: boolean) {\r\n\t\tif (value) {\r\n\t\t\tthis.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;\r\n\t\t}\r\n\t}\r\n\r\n\t/** An ATN configuration is equal to another if both have\r\n\t *  the same state, they predict the same alternative, and\r\n\t *  syntactic/semantic contexts are the same.\r\n\t */\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (this === o) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(o instanceof ATNConfig)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.state.stateNumber === o.state.stateNumber\r\n\t\t\t&& this.alt === o.alt\r\n\t\t\t&& this.reachesIntoOuterContext === o.reachesIntoOuterContext\r\n\t\t\t&& this.context.equals(o.context)\r\n\t\t\t&& this.semanticContext.equals(o.semanticContext)\r\n\t\t\t&& this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed\r\n\t\t\t&& this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision\r\n\t\t\t&& ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hashCode: number = MurmurHash.initialize(7);\r\n\t\thashCode = MurmurHash.update(hashCode, this.state.stateNumber);\r\n\t\thashCode = MurmurHash.update(hashCode, this.alt);\r\n\t\thashCode = MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);\r\n\t\thashCode = MurmurHash.update(hashCode, this.context);\r\n\t\thashCode = MurmurHash.update(hashCode, this.semanticContext);\r\n\t\thashCode = MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);\r\n\t\thashCode = MurmurHash.update(hashCode, this.lexerActionExecutor);\r\n\t\thashCode = MurmurHash.finish(hashCode, 7);\r\n\t\treturn hashCode;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a\r\n\t * **.dot** file and then rendered to an image using Graphviz.\r\n\t *\r\n\t * @returns A Graphviz graph representing the current `ATNConfig`.\r\n\t *\r\n\t * @see http://www.graphviz.org/\r\n\t */\r\n\tpublic toDotString(): string {\r\n\t\tlet builder = \"\";\r\n\t\tbuilder += (\"digraph G {\\n\");\r\n\t\tbuilder += (\"rankdir=LR;\\n\");\r\n\r\n\t\tlet visited = new Array2DHashMap<PredictionContext, number>(PredictionContext.IdentityEqualityComparator.INSTANCE);\r\n\t\tlet workList: PredictionContext[] = [];\r\n\t\tfunction getOrAddContext(context: PredictionContext): number {\r\n\t\t\tlet newNumber = visited.size;\r\n\t\t\tlet result = visited.putIfAbsent(context, newNumber);\r\n\t\t\tif (result != null) {\r\n\t\t\t\t// Already saw this context\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\tworkList.push(context);\r\n\t\t\treturn newNumber;\r\n\t\t}\r\n\r\n\t\tworkList.push(this.context);\r\n\t\tvisited.put(this.context, 0);\r\n\t\twhile (true) {\r\n\t\t\tlet current = workList.pop();\r\n\t\t\tif (!current) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < current.size; i++) {\r\n\t\t\t\tbuilder += (\"  s\") + (getOrAddContext(current));\r\n\t\t\t\tbuilder += (\"->\");\r\n\t\t\t\tbuilder += (\"s\") + (getOrAddContext(current.getParent(i)));\r\n\t\t\t\tbuilder += (\"[label=\\\"\") + (current.getReturnState(i)) + (\"\\\"];\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbuilder += (\"}\\n\");\r\n\t\treturn builder.toString();\r\n\t}\r\n\r\n\tpublic toString(): string;\r\n\tpublic toString(recog: Recognizer<any, any> | undefined, showAlt: boolean): string;\r\n\tpublic toString(recog: Recognizer<any, any> | undefined, showAlt: boolean, showContext: boolean): string;\r\n\tpublic toString(recog?: Recognizer<any, any>, showAlt?: boolean, showContext?: boolean): string {\r\n\t\t// Must check showContext before showAlt to preserve original overload behavior\r\n\t\tif (showContext == null) {\r\n\t\t\tshowContext = showAlt != null;\r\n\t\t}\r\n\r\n\t\tif (showAlt == null) {\r\n\t\t\tshowAlt = true;\r\n\t\t}\r\n\r\n\t\tlet buf = \"\";\r\n\t\t// if (this.state.ruleIndex >= 0) {\r\n\t\t// \tif (recog != null) {\r\n\t\t// \t\tbuf += (recog.ruleNames[this.state.ruleIndex] + \":\");\r\n\t\t// \t} else {\r\n\t\t// \t\tbuf += (this.state.ruleIndex + \":\");\r\n\t\t// \t}\r\n\t\t// }\r\n\t\tlet contexts: string[];\r\n\t\tif (showContext) {\r\n\t\t\tcontexts = this.context.toStrings(recog, this.state.stateNumber);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcontexts = [\"?\"];\r\n\t\t}\r\n\r\n\t\tlet first: boolean = true;\r\n\t\tfor (let contextDesc of contexts) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbuf += (\", \");\r\n\t\t\t}\r\n\r\n\t\t\tbuf += (\"(\");\r\n\t\t\tbuf += (this.state);\r\n\t\t\tif (showAlt) {\r\n\t\t\t\tbuf += (\",\");\r\n\t\t\t\tbuf += (this.alt);\r\n\t\t\t}\r\n\t\t\tif (this.context) {\r\n\t\t\t\tbuf += (\",\");\r\n\t\t\t\tbuf += (contextDesc);\r\n\t\t\t}\r\n\t\t\tif (this.semanticContext !== SemanticContext.NONE) {\r\n\t\t\t\tbuf += (\",\");\r\n\t\t\t\tbuf += (this.semanticContext);\r\n\t\t\t}\r\n\t\t\tif (this.reachesIntoOuterContext) {\r\n\t\t\t\tbuf += (\",up=\") + (this.outerContextDepth);\r\n\t\t\t}\r\n\t\t\tbuf += (\")\");\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n}\r\n\r\n/**\r\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\r\n * with a non-default semantic context.\r\n *\r\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\r\n * types.\r\n */\r\nclass SemanticContextATNConfig extends ATNConfig {\r\n\t@NotNull\r\n\tprivate _semanticContext: SemanticContext;\r\n\r\n\tconstructor(semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext);\r\n\tconstructor(semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext);\r\n\tconstructor(semanticContext: SemanticContext, @NotNull state: ATNState, @NotNull altOrConfig: number | ATNConfig, context: PredictionContext) {\r\n\t\tif (typeof altOrConfig === \"number\") {\r\n\t\t\tsuper(state, altOrConfig, context);\r\n\t\t} else {\r\n\t\t\tsuper(state, altOrConfig, context);\r\n\t\t}\r\n\r\n\t\tthis._semanticContext = semanticContext;\r\n\t}\r\n\r\n\t@Override\r\n\tget semanticContext(): SemanticContext {\r\n\t\treturn this._semanticContext;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\r\n * with a lexer action.\r\n *\r\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\r\n * types.\r\n */\r\nclass ActionATNConfig extends ATNConfig {\r\n\tprivate _lexerActionExecutor?: LexerActionExecutor;\r\n\tprivate passedThroughNonGreedyDecision: boolean;\r\n\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull state: ATNState, @NotNull altOrConfig: number | ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean) {\r\n\t\tif (typeof altOrConfig === \"number\") {\r\n\t\t\tsuper(state, altOrConfig, context);\r\n\t\t} else {\r\n\t\t\tsuper(state, altOrConfig, context);\r\n\t\t\tif (altOrConfig.semanticContext !== SemanticContext.NONE) {\r\n\t\t\t\tthrow new Error(\"Not supported\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._lexerActionExecutor = lexerActionExecutor;\r\n\t\tthis.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\r\n\t}\r\n\r\n\t@Override\r\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\r\n\t\treturn this._lexerActionExecutor;\r\n\t}\r\n\r\n\t@Override\r\n\tget hasPassedThroughNonGreedyDecision(): boolean {\r\n\t\treturn this.passedThroughNonGreedyDecision;\r\n\t}\r\n}\r\n\r\n/**\r\n * This class was derived from `SemanticContextATNConfig` purely as a memory optimization. It allows for the creation of\r\n * an `ATNConfig` with both a lexer action and a non-default semantic context.\r\n *\r\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\r\n * types.\r\n */\r\nclass ActionSemanticContextATNConfig extends SemanticContextATNConfig {\r\n\tprivate _lexerActionExecutor?: LexerActionExecutor;\r\n\tprivate passedThroughNonGreedyDecision: boolean;\r\n\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\r\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull semanticContext: SemanticContext, @NotNull state: ATNState, altOrConfig: number | ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean) {\r\n\t\tif (typeof altOrConfig === \"number\") {\r\n\t\t\tsuper(semanticContext, state, altOrConfig, context);\r\n\t\t} else {\r\n\t\t\tsuper(semanticContext, state, altOrConfig, context);\r\n\t\t}\r\n\r\n\t\tthis._lexerActionExecutor = lexerActionExecutor;\r\n\t\tthis.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\r\n\t}\r\n\r\n\t@Override\r\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\r\n\t\treturn this._lexerActionExecutor;\r\n\t}\r\n\r\n\t@Override\r\n\tget hasPassedThroughNonGreedyDecision(): boolean {\r\n\t\treturn this.passedThroughNonGreedyDecision;\r\n\t}\r\n}\r\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport * as assert from \"assert\";\r\nimport * as util from \"util\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\n\r\n/**\r\n * Private empty array used to construct empty BitSets\r\n */\r\nconst EMPTY_DATA: Uint16Array = new Uint16Array(0);\r\n\r\n/**\r\n * Gets the word index of the `UInt16` element in `BitSet.data` containing the bit with the specified index.\r\n */\r\nfunction getIndex(bitNumber: number) {\r\n\treturn bitNumber >>> 4;\r\n}\r\n\r\n/**\r\n * Convert a word index into the bit index of the LSB of that word\r\n */\r\n\r\nfunction unIndex(n: number) {\r\n\treturn n * 16;\r\n}\r\n\r\n/**\r\n * Get's the bit number of the least signficant bit set LSB which is set in a word non-zero word;\r\n * Bit numbers run from LSB to MSB starting with 0.\r\n */\r\nfunction findLSBSet(word: number) {\r\n\tlet bit = 1;\r\n\tfor (let i = 0; i < 16; i++) {\r\n\t\tif ((word & bit) !== 0) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t\tbit = (bit << 1) >>> 0;\r\n\t}\r\n\tthrow new RangeError(\"No specified bit found\");\r\n}\r\n\r\nfunction findMSBSet(word: number) {\r\n\tlet bit = (1 << 15) >>> 0;\r\n\tfor (let i = 15; i >= 0; i--) {\r\n\t\tif ((word & bit) !== 0) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t\tbit = bit >>> 1;\r\n\t}\r\n\tthrow new RangeError(\"No specified bit found\");\r\n}\r\n\r\n/**\r\n * Gets a 16-bit mask with bit numbers fromBit to toBit (inclusive) set.\r\n * Bit numbers run from LSB to MSB starting with 0.\r\n */\r\nfunction bitsFor(fromBit: number, toBit: number): number {\r\n\tfromBit &= 0xF;\r\n\ttoBit &= 0xF;\r\n\tif (fromBit === toBit) {\r\n\t\treturn (1 << fromBit) >>> 0;\r\n\t}\r\n\treturn ((0xFFFF >>> (15 - toBit)) ^ (0xFFFF >>> (16 - fromBit)));\r\n}\r\n\r\n/**\r\n * A lookup table for number of set bits in a 16-bit integer.   This is used to quickly count the cardinality (number of unique elements) of a BitSet.\r\n */\r\nconst POP_CNT: Uint8Array = new Uint8Array(65536);\r\nfor (let i = 0; i < 16; i++) {\r\n\tconst stride = (1 << i) >>> 0;\r\n\tlet index = 0;\r\n\twhile (index < POP_CNT.length) {\r\n\t\t// skip the numbers where the bit isn't set\r\n\t\tindex += stride;\r\n\r\n\t\t// increment the ones where the bit is set\r\n\t\tfor (let j = 0; j < stride; j++) {\r\n\t\t\tPOP_CNT[index]++;\r\n\t\t\tindex++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class BitSet implements Iterable<number>{\r\n\tprivate data: Uint16Array;\r\n\r\n\t/**\r\n\t * Creates a new bit set. All bits are initially `false`.\r\n\t */\r\n\tconstructor();\r\n\r\n\t/**\r\n\t * Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range `0`\r\n\t * through `nbits-1`. All bits are initially `false`.\r\n\t */\r\n\tconstructor(nbits: number);\r\n\r\n\t/**\r\n\t * Creates a bit set from a iterable list of numbers (including another BitSet);\r\n\t */\r\n\tconstructor(numbers: Iterable<number>);\r\n\r\n\t/*\r\n\t** constructor implementation\r\n\t*/\r\n\tconstructor(arg?: number | Iterable<number>) {\r\n\t\tif (!arg) {\r\n\t\t\t// covering the case of unspecified and nbits===0\r\n\t\t\tthis.data = EMPTY_DATA;\r\n\t\t} else if (typeof arg === \"number\") {\r\n\t\t\tif (arg < 0) {\r\n\t\t\t\tthrow new RangeError(\"nbits cannot be negative\");\r\n\t\t\t} else {\r\n\t\t\t\tthis.data = new Uint16Array(getIndex(arg - 1) + 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (arg instanceof BitSet) {\r\n\t\t\t\tthis.data = arg.data.slice(0); // Clone the data\r\n\t\t\t} else {\r\n\t\t\t\tlet max = -1;\r\n\t\t\t\tfor (let v of arg) {\r\n\t\t\t\t\tif (max < v) {\r\n\t\t\t\t\t\tmax = v;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.data = new Uint16Array(getIndex(max - 1) + 1);\r\n\t\t\t\tfor (let v of arg) {\r\n\t\t\t\t\tthis.set(v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that\r\n\t * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding\r\n\t * bit in the bit set argument also had the value `true`.\r\n\t */\r\n\tpublic and(set: BitSet): void {\r\n\t\tconst data = this.data;\r\n\t\tconst other = set.data;\r\n\t\tconst words = Math.min(data.length, other.length);\r\n\r\n\t\tlet lastWord = -1;\t// Keep track of index of last non-zero word\r\n\r\n\t\tfor (let i = 0; i < words; i++) {\r\n\t\t\tlet value = data[i] &= other[i];\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lastWord === -1) {\r\n\t\t\tthis.data = EMPTY_DATA;\r\n\t\t}\r\n\r\n\t\tif (lastWord < data.length - 1) {\r\n\t\t\tthis.data = data.slice(0, lastWord + 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.\r\n\t */\r\n\tpublic andNot(set: BitSet): void {\r\n\t\tconst data = this.data;\r\n\t\tconst other = set.data;\r\n\t\tconst words = Math.min(data.length, other.length);\r\n\r\n\t\tlet lastWord = -1;\t// Keep track of index of last non-zero word\r\n\r\n\t\tfor (let i = 0; i < words; i++) {\r\n\t\t\tlet value = data[i] &= (other[i] ^ 0xFFFF);\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lastWord === -1) {\r\n\t\t\tthis.data = EMPTY_DATA;\r\n\t\t}\r\n\r\n\t\tif (lastWord < data.length - 1) {\r\n\t\t\tthis.data = data.slice(0, lastWord + 1);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the number of bits set to `true` in this `BitSet`.\r\n\t */\r\n\tpublic cardinality(): number {\r\n\t\tif (this.isEmpty) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tconst data = this.data;\r\n\t\tconst length = data.length;\r\n\t\tlet result = 0;\r\n\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tresult += POP_CNT[data[i]];\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets all of the bits in this `BitSet` to `false`.\r\n\t */\r\n\tpublic clear(): void;\r\n\r\n\t/**\r\n\t * Sets the bit specified by the index to `false`.\r\n\t *\r\n\t * @param bitIndex the index of the bit to be cleared\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic clear(bitIndex: number): void;\r\n\r\n\t/**\r\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to `false`.\r\n\t *\r\n\t * @param fromIndex index of the first bit to be cleared\r\n\t * @param toIndex index after the last bit to be cleared\r\n\t *\r\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\r\n\t */\r\n\tpublic clear(fromIndex: number, toIndex: number): void;\r\n\tpublic clear(fromIndex?: number, toIndex?: number): void {\r\n\t\tif (fromIndex == null) {\r\n\t\t\tthis.data.fill(0);\r\n\t\t} else if (toIndex == null) {\r\n\t\t\tthis.set(fromIndex, false);\r\n\t\t} else {\r\n\t\t\tthis.set(fromIndex, toIndex, false);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the bit at the specified index to the complement of its current value.\r\n\t *\r\n\t * @param bitIndex the index of the bit to flip\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic flip(bitIndex: number): void;\r\n\r\n\t/**\r\n\t * Sets each bit from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to the complement\r\n\t * of its current value.\r\n\t *\r\n\t * @param fromIndex index of the first bit to flip\r\n\t * @param toIndex index after the last bit to flip\r\n\t *\r\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\r\n\t */\r\n\tpublic flip(fromIndex: number, toIndex: number): void;\r\n\tpublic flip(fromIndex: number, toIndex?: number): void {\r\n\t\tif (toIndex == null) {\r\n\t\t\ttoIndex = fromIndex;\r\n\t\t}\r\n\t\tif (fromIndex < 0 || toIndex < fromIndex) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tconst lastWord = getIndex(toIndex);\r\n\r\n\t\tif (word === lastWord) {\r\n\t\t\tthis.data[word] ^= bitsFor(fromIndex, toIndex);\r\n\t\t} else {\r\n\t\t\tthis.data[word++] ^= bitsFor(fromIndex, 15);\r\n\t\t\twhile (word < lastWord) {\r\n\t\t\t\tthis.data[word++] ^= 0xFFFF;\r\n\t\t\t}\r\n\t\t\tthis.data[word++] ^= bitsFor(0, toIndex);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`\r\n\t * is currently set in this `BitSet`; otherwise, the result is `false`.\r\n\t *\r\n\t * @param bitIndex the bit index\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic get(bitIndex: number): boolean;\r\n\r\n\t/**\r\n\t * Returns a new `BitSet` composed of bits from this `BitSet` from `fromIndex` (inclusive) to `toIndex` (exclusive).\r\n\t *\r\n\t * @param fromIndex index of the first bit to include\r\n\t * @param toIndex index after the last bit to include\r\n\t *\r\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\r\n\t */\r\n\tpublic get(fromIndex: number, toIndex: number): BitSet;\r\n\tpublic get(fromIndex: number, toIndex?: number): boolean | BitSet {\r\n\t\tif (toIndex === undefined) {\r\n\t\t\treturn !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));\r\n\t\t} else {\r\n\t\t\t// return a BitSet\r\n\t\t\tlet result = new BitSet(toIndex + 1);\r\n\t\t\tfor (let i = fromIndex; i <= toIndex; i++) {\r\n\t\t\t\tresult.set(i, this.get(i));\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.\r\n\t *\r\n\t * @param set `BitSet` to intersect with\r\n\t */\r\n\tpublic intersects(set: BitSet): boolean {\r\n\t\tlet smallerLength = Math.min(this.length(), set.length());\r\n\t\tif (smallerLength === 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet bound = getIndex(smallerLength - 1);\r\n\t\tfor (let i = 0; i <= bound; i++) {\r\n\t\t\tif ((this.data[i] & set.data[i]) !== 0) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if this `BitSet` contains no bits that are set to `true`.\r\n\t */\r\n\tget isEmpty(): boolean {\r\n\t\treturn this.length() === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the \"logical size\" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns\r\n\t * zero if the `BitSet` contains no set bits.\r\n\t */\r\n\tpublic length(): number {\r\n\t\tif (!this.data.length) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn this.previousSetBit(unIndex(this.data.length) - 1) + 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,\r\n\t * If no such bit exists then `-1` is returned.\r\n\t *\r\n\t * @param fromIndex the index to start checking from (inclusive)\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic nextClearBit(fromIndex: number): number {\r\n\t\tif (fromIndex < 0) {\r\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\r\n\t\t}\r\n\r\n\t\tconst data = this.data;\r\n\t\tconst length = data.length;\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tif (word > length) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tlet ignore = 0xFFFF ^ bitsFor(fromIndex, 15);\r\n\r\n\t\tif ((data[word] | ignore) === 0xFFFF) {\r\n\t\t\tword++;\r\n\t\t\tignore = 0;\r\n\t\t\tfor (; word < length; word++) {\r\n\t\t\t\tif (data[word] !== 0xFFFF) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (word === length) {\r\n\t\t\t\t// Hit the end\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn unIndex(word) + findLSBSet((data[word] | ignore) ^ 0xFFFF);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.\r\n\t * If no such bit exists then `-1` is returned.\r\n\t *\r\n\t * To iterate over the `true` bits in a `BitSet`, use the following loop:\r\n\t *\r\n\t * ```\r\n\t * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\r\n\t *   // operate on index i here\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param fromIndex the index to start checking from (inclusive)\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic nextSetBit(fromIndex: number): number {\r\n\t\tif (fromIndex < 0) {\r\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\r\n\t\t}\r\n\r\n\t\tconst data = this.data;\r\n\t\tconst length = data.length;\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tif (word > length) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tlet mask = bitsFor(fromIndex, 15);\r\n\r\n\t\tif ((data[word] & mask) === 0) {\r\n\t\t\tword++;\r\n\t\t\tmask = 0xFFFF;\r\n\t\t\tfor (; word < length; word++) {\r\n\t\t\t\tif (data[word] !== 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (word >= length) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn unIndex(word) + findLSBSet(data[word] & mask);\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it\r\n\t * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit\r\n\t * set argument has the value `true`.\r\n\t */\r\n\tpublic or(set: BitSet): void {\r\n\t\tconst data = this.data;\r\n\t\tconst other = set.data;\r\n\t\tconst minWords = Math.min(data.length, other.length);\r\n\t\tconst words = Math.max(data.length, other.length);\r\n\t\tconst dest = data.length === words ? data : new Uint16Array(words);\r\n\r\n\t\tlet lastWord = -1;\r\n\r\n\t\t// Or those words both sets have in common\r\n\r\n\t\tfor (let i = 0; i < minWords; i++) {\r\n\t\t\tlet value = dest[i] = data[i] | other[i];\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Copy words from larger set (if there is one)\r\n\r\n\t\tconst longer = data.length > other.length ? data : other;\r\n\t\tfor (let i = minWords; i < words; i++) {\r\n\t\t\tlet value = dest[i] = longer[i];\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lastWord === -1) {\r\n\t\t\tthis.data = EMPTY_DATA;\r\n\t\t} else if (dest.length === lastWord + 1) {\r\n\t\t\tthis.data = dest;\r\n\t\t} else {\r\n\t\t\tthis.data = dest.slice(0, lastWord);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting\r\n\t * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\r\n\t *\r\n\t * @param fromIndex the index to start checking from (inclusive)\r\n\t *\r\n\t * @throws RangeError if the specified index is less than `-1`\r\n\t */\r\n\tpublic previousClearBit(fromIndex: number): number {\r\n\t\tif (fromIndex < 0) {\r\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\r\n\t\t}\r\n\r\n\t\tconst data = this.data;\r\n\t\tconst length = data.length;\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tif (word >= length) {\r\n\t\t\tword = length - 1;\r\n\t\t}\r\n\r\n\t\tlet ignore = 0xFFFF ^ bitsFor(0, fromIndex);\r\n\r\n\t\tif ((data[word] | ignore) === 0xFFFF) {\r\n\t\t\tignore = 0;\r\n\t\t\tword--;\r\n\t\t\tfor (; word >= 0; word--) {\r\n\t\t\t\tif (data[word] !== 0xFFFF) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (word < 0) {\r\n\t\t\t\t// Hit the end\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn unIndex(word) + findMSBSet((data[word] | ignore) ^ 0xFFFF);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.\r\n\t * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\r\n\t *\r\n\t * To iterate over the `true` bits in a `BitSet`, use the following loop:\r\n\t *\r\n\t * ```\r\n\t * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\r\n\t *   // operate on index i here\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param fromIndex the index to start checking from (inclusive)\r\n\t *\r\n\t * @throws RangeError if the specified index is less than `-1`\r\n\t */\r\n\tpublic previousSetBit(fromIndex: number): number {\r\n\t\tif (fromIndex < 0) {\r\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\r\n\t\t}\r\n\r\n\t\tconst data = this.data;\r\n\t\tconst length = data.length;\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tif (word >= length) {\r\n\t\t\tword = length - 1;\r\n\t\t}\r\n\r\n\t\tlet mask = bitsFor(0, fromIndex);\r\n\r\n\t\tif ((data[word] & mask) === 0) {\r\n\t\t\tword--;\r\n\t\t\tmask = 0xFFFF;\r\n\t\t\tfor (; word >= 0; word--) {\r\n\t\t\t\tif (data[word] !== 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (word < 0) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn unIndex(word) + findMSBSet(data[word] & mask);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the bit at the specified index to `true`.\r\n\t *\r\n\t * @param bitIndex a bit index\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic set(bitIndex: number): void;\r\n\r\n\t/**\r\n\t * Sets the bit at the specified index to the specified value.\r\n\t *\r\n\t * @param bitIndex a bit index\r\n\t * @param value a boolean value to set\r\n\t *\r\n\t * @throws RangeError if the specified index is negative\r\n\t */\r\n\tpublic set(bitIndex: number, value: boolean): void;\r\n\r\n\t/**\r\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to `true`.\r\n\t *\r\n\t * @param fromIndex index of the first bit to be set\r\n\t * @param toIndex index after the last bit to be set\r\n\t *\r\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\r\n\t */\r\n\tpublic set(fromIndex: number, toIndex: number): void;\r\n\r\n\t/**\r\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to the specified\r\n\t * value.\r\n\t *\r\n\t * @param fromIndex index of the first bit to be set\r\n\t * @param toIndex index after the last bit to be set\r\n\t * @param value value to set the selected bits to\r\n\t *\r\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\r\n\t */\r\n\tpublic set(fromIndex: number, toIndex: number, value: boolean): void;\r\n\tpublic set(fromIndex: number, toIndex?: boolean | number, value?: boolean): void {\r\n\t\tif (toIndex === undefined) {\r\n\t\t\ttoIndex = fromIndex;\r\n\t\t\tvalue = true;\r\n\t\t} else if (typeof toIndex === \"boolean\") {\r\n\t\t\tvalue = toIndex;\r\n\t\t\ttoIndex = fromIndex;\r\n\t\t}\r\n\r\n\t\tif (value === undefined) {\r\n\t\t\tvalue = true;\r\n\t\t}\r\n\r\n\t\tif (fromIndex < 0 || fromIndex > toIndex) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\tlet word = getIndex(fromIndex);\r\n\t\tlet lastWord = getIndex(toIndex);\r\n\r\n\t\tif (value && lastWord >= this.data.length) {\r\n\t\t\t// Grow array \"just enough\" for bits we need to set\r\n\t\t\tlet temp = new Uint16Array(lastWord + 1);\r\n\t\t\tthis.data.forEach((value, index) => temp[index] = value);\r\n\t\t\tthis.data = temp;\r\n\t\t} else if (!value) {\r\n\t\t\t// But there is no need to grow array to clear bits.\r\n\t\t\tif (word >= this.data.length) {\r\n\t\t\t\t// Early exit\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (lastWord >= this.data.length) {\r\n\t\t\t\t// Adjust work to fit array\r\n\t\t\t\tlastWord = this.data.length - 1;\r\n\t\t\t\ttoIndex = this.data.length * 16 - 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (word === lastWord) {\r\n\t\t\tthis._setBits(word, value, bitsFor(fromIndex, toIndex));\r\n\t\t} else {\r\n\t\t\tthis._setBits(word++, value, bitsFor(fromIndex, 15));\r\n\t\t\twhile (word < lastWord) {\r\n\t\t\t\tthis.data[word++] = value ? 0xFFFF : 0;\r\n\t\t\t}\r\n\t\t\tthis._setBits(word, value, bitsFor(0, toIndex));\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _setBits(word: number, value: boolean, mask: number) {\r\n\t\tif (value) {\r\n\t\t\tthis.data[word] |= mask;\r\n\t\t} else {\r\n\t\t\tthis.data[word] &= 0xFFFF ^ mask;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element\r\n\t * in the set is the size - 1st element.\r\n\t */\r\n\tget size(): number {\r\n\t\treturn this.data.byteLength * 8;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new byte array containing all the bits in this bit set.\r\n\t *\r\n\t * More precisely, if\r\n\t * `let bytes = s.toByteArray();`\r\n\t * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all\r\n\t * `n < 8 * bytes.length`.\r\n\t */\r\n\t// toByteArray(): Int8Array {\r\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\r\n\t// }\r\n\r\n\t/**\r\n\t * Returns a new integer array containing all the bits in this bit set.\r\n\t *\r\n\t * More precisely, if\r\n\t * `let integers = s.toIntegerArray();`\r\n\t * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all\r\n\t * `n < 32 * integers.length`.\r\n\t */\r\n\t// toIntegerArray(): Int32Array {\r\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\r\n\t// }\r\n\r\n\tpublic hashCode(): number {\r\n\t\treturn MurmurHash.hashCode(this.data, 22);\r\n\t}\r\n\r\n\t/**\r\n\t * Compares this object against the specified object. The result is `true` if and only if the argument is not\r\n\t * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That\r\n\t * is, for every nonnegative index `k`,\r\n\t *\r\n\t * ```\r\n\t * ((BitSet)obj).get(k) == this.get(k)\r\n\t * ```\r\n\t *\r\n\t * must be true. The current sizes of the two bit sets are not compared.\r\n\t */\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof BitSet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst len = this.length();\r\n\r\n\t\tif (len !== obj.length()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (len === 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tlet bound = getIndex(len - 1);\r\n\t\tfor (let i = 0; i <= bound; i++) {\r\n\t\t\tif (this.data[i] !== obj.data[i]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the\r\n\t * set state, the decimal representation of that index is included in the result. Such indices are listed in order\r\n\t * from lowest to highest, separated by \", \" (a comma and a space) and surrounded by braces, resulting in the usual\r\n\t * mathematical notation for a set of integers.\r\n\t *\r\n\t * Example:\r\n\t *\r\n\t *     BitSet drPepper = new BitSet();\r\n\t *\r\n\t * Now `drPepper.toString()` returns `\"{}\"`.\r\n\t *\r\n\t *     drPepper.set(2);\r\n\t *\r\n\t * Now `drPepper.toString()` returns `\"{2}\"`.\r\n\t *\r\n\t *     drPepper.set(4);\r\n\t *     drPepper.set(10);\r\n\t *\r\n\t * Now `drPepper.toString()` returns `\"{2, 4, 10}\"`.\r\n\t */\r\n\tpublic toString(): string {\r\n\t\tlet result = \"{\";\r\n\r\n\t\tlet first = true;\r\n\t\tfor (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tresult += \", \";\r\n\t\t\t}\r\n\r\n\t\t\tresult += i;\r\n\t\t}\r\n\r\n\t\tresult += \"}\";\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// static valueOf(bytes: Int8Array): BitSet;\r\n\t// static valueOf(buffer: ArrayBuffer): BitSet;\r\n\t// static valueOf(integers: Int32Array): BitSet;\r\n\t// static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {\r\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\r\n\t// }\r\n\r\n\t/**\r\n\t * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in\r\n\t * it has the value `true` if and only if one of the following statements holds:\r\n\t *\r\n\t * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.\r\n\t * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.\r\n\t */\r\n\tpublic xor(set: BitSet): void {\r\n\t\tconst data = this.data;\r\n\t\tconst other = set.data;\r\n\t\tconst minWords = Math.min(data.length, other.length);\r\n\t\tconst words = Math.max(data.length, other.length);\r\n\t\tconst dest = data.length === words ? data : new Uint16Array(words);\r\n\r\n\t\tlet lastWord = -1;\r\n\r\n\t\t// Xor those words both sets have in common\r\n\r\n\t\tfor (let i = 0; i < minWords; i++) {\r\n\t\t\tlet value = dest[i] = data[i] ^ other[i];\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Copy words from larger set (if there is one)\r\n\r\n\t\tconst longer = data.length > other.length ? data : other;\r\n\t\tfor (let i = minWords; i < words; i++) {\r\n\t\t\tlet value = dest[i] = longer[i];\r\n\t\t\tif (value !== 0) {\r\n\t\t\t\tlastWord = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lastWord === -1) {\r\n\t\t\tthis.data = EMPTY_DATA;\r\n\t\t} else if (dest.length === lastWord + 1) {\r\n\t\t\tthis.data = dest;\r\n\t\t} else {\r\n\t\t\tthis.data = dest.slice(0, lastWord + 1);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic clone() {\r\n\t\treturn new BitSet(this);\r\n\t}\r\n\r\n\tpublic [Symbol.iterator](): IterableIterator<number> {\r\n\t\treturn new BitSetIterator(this.data);\r\n\t}\r\n\r\n\t// Overrides formatting for nodejs assert etc.\r\n\tpublic [(util.inspect as any).custom](): string {\r\n\t\treturn \"BitSet \" + this.toString();\r\n\t}\r\n}\r\n\r\nclass BitSetIterator implements IterableIterator<number>{\r\n\tprivate index = 0;\r\n\tprivate mask = 0xFFFF;\r\n\r\n\tconstructor(private data: Uint16Array) { }\r\n\r\n\tpublic next() {\r\n\t\twhile (this.index < this.data.length) {\r\n\t\t\tconst bits = this.data[this.index] & this.mask;\r\n\t\t\tif (bits !== 0) {\r\n\t\t\t\tconst bitNumber = unIndex(this.index) + findLSBSet(bits);\r\n\t\t\t\tthis.mask = bitsFor(bitNumber + 1, 15);\r\n\t\t\t\treturn { done: false, value: bitNumber };\r\n\t\t\t}\r\n\t\t\tthis.index++;\r\n\t\t\tthis.mask = 0xFFFF;\r\n\t\t}\r\n\t\treturn { done: true, value: -1 };\r\n\t}\r\n\r\n\tpublic [Symbol.iterator](): IterableIterator<number> { return this; }\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:25.5488013-07:00\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNSimulator } from \"./ATNSimulator\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { ConflictInfo } from \"./ConflictInfo\";\r\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\r\nimport { JavaSet } from \"../misc/Stubs\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { PredictionContextCache } from \"./PredictionContextCache\";\r\nimport { SemanticContext } from \"./SemanticContext\";\r\n\r\nimport * as assert from \"assert\";\r\nimport * as Utils from \"../misc/Utils\";\r\n\r\ninterface KeyType { state: number; alt: number; }\r\n\r\nclass KeyTypeEqualityComparer implements EqualityComparator<KeyType> {\r\n\tpublic hashCode(key: KeyType) {\r\n\t\treturn key.state ^ key.alt;\r\n\t}\r\n\r\n\tpublic equals(a: KeyType, b: KeyType) {\r\n\t\treturn a.state === b.state && a.alt === b.alt;\r\n\t}\r\n\r\n\tpublic static readonly INSTANCE = new KeyTypeEqualityComparer();\r\n}\r\n\r\nfunction NewKeyedConfigMap(map?: Array2DHashMap<KeyType, ATNConfig>) {\r\n\tif (map) {\r\n\t\treturn new Array2DHashMap<KeyType, ATNConfig>(map);\r\n\t} else {\r\n\t\treturn new Array2DHashMap<KeyType, ATNConfig>(KeyTypeEqualityComparer.INSTANCE);\r\n\t}\r\n}\r\n\r\n/**\r\n * Represents a set of ATN configurations (see `ATNConfig`). As configurations are added to the set, they are merged\r\n * with other `ATNConfig` instances already in the set when possible using the graph-structured stack.\r\n *\r\n * An instance of this class represents the complete set of positions (with context) in an ATN which would be associated\r\n * with a single DFA state. Its internal representation is more complex than traditional state used for NFA to DFA\r\n * conversion due to performance requirements (both improving speed and reducing memory overhead) as well as supporting\r\n * features such as semantic predicates and non-greedy operators in a form to support ANTLR's prediction algorithm.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ATNConfigSet implements JavaSet<ATNConfig> {\r\n\t/**\r\n\t * This maps (state, alt) -> merged {@link ATNConfig}. The key does not account for\r\n\t * the {@link ATNConfig#getSemanticContext} of the value, which is only a problem if a single\r\n\t * `ATNConfigSet` contains two configs with the same state and alternative\r\n\t * but different semantic contexts. When this case arises, the first config\r\n\t * added to this map stays, and the remaining configs are placed in {@link #unmerged}.\r\n\t *\r\n\t * This map is only used for optimizing the process of adding configs to the set,\r\n\t * and is `undefined` for read-only sets stored in the DFA.\r\n\t */\r\n\tprivate mergedConfigs?: Array2DHashMap<KeyType, ATNConfig>;\r\n\r\n\t/**\r\n\t * This is an \"overflow\" list holding configs which cannot be merged with one\r\n\t * of the configs in {@link #mergedConfigs} but have a colliding key. This\r\n\t * occurs when two configs in the set have the same state and alternative but\r\n\t * different semantic contexts.\r\n\t *\r\n\t * This list is only used for optimizing the process of adding configs to the set,\r\n\t * and is `undefined` for read-only sets stored in the DFA.\r\n\t */\r\n\tprivate unmerged?: ATNConfig[];\r\n\r\n\t/**\r\n\t * This is a list of all configs in this set.\r\n\t */\r\n\tprivate configs: ATNConfig[];\r\n\r\n\tprivate _uniqueAlt: number = 0;\r\n\tprivate _conflictInfo?: ConflictInfo;\r\n\t// Used in parser and lexer. In lexer, it indicates we hit a pred\r\n\t// while computing a closure operation.  Don't make a DFA state from this.\r\n\tprivate _hasSemanticContext: boolean = false;\r\n\tprivate _dipsIntoOuterContext: boolean = false;\r\n\t/**\r\n\t * When `true`, this config set represents configurations where the entire\r\n\t * outer context has been consumed by the ATN interpreter. This prevents the\r\n\t * {@link ParserATNSimulator#closure} from pursuing the global FOLLOW when a\r\n\t * rule stop state is reached with an empty prediction context.\r\n\t *\r\n\t * Note: `outermostConfigSet` and {@link #dipsIntoOuterContext} should never\r\n\t * be true at the same time.\r\n\t */\r\n\tprivate outermostConfigSet: boolean = false;\r\n\r\n\tprivate cachedHashCode: number = -1;\r\n\r\n\tconstructor();\r\n\tconstructor(set: ATNConfigSet, readonly: boolean);\r\n\tconstructor(set?: ATNConfigSet, readonly?: boolean) {\r\n\t\tif (!set) {\r\n\t\t\tthis.mergedConfigs = NewKeyedConfigMap();\r\n\t\t\tthis.unmerged = [];\r\n\t\t\tthis.configs = [];\r\n\r\n\t\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\r\n\t\t} else {\r\n\r\n\t\t\tif (readonly) {\r\n\t\t\t\tthis.mergedConfigs = undefined;\r\n\t\t\t\tthis.unmerged = undefined;\r\n\t\t\t} else if (!set.isReadOnly) {\r\n\t\t\t\tthis.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);\r\n\t\t\t\tthis.unmerged = (set.unmerged as ATNConfig[]).slice(0);\r\n\t\t\t} else {\r\n\t\t\t\tthis.mergedConfigs = NewKeyedConfigMap();\r\n\t\t\t\tthis.unmerged = [];\r\n\t\t\t}\r\n\r\n\t\t\tthis.configs = set.configs.slice(0);\r\n\r\n\t\t\tthis._dipsIntoOuterContext = set._dipsIntoOuterContext;\r\n\t\t\tthis._hasSemanticContext = set._hasSemanticContext;\r\n\t\t\tthis.outermostConfigSet = set.outermostConfigSet;\r\n\r\n\t\t\tif (readonly || !set.isReadOnly) {\r\n\t\t\t\tthis._uniqueAlt = set._uniqueAlt;\r\n\t\t\t\tthis._conflictInfo = set._conflictInfo;\r\n\t\t\t}\r\n\r\n\t\t\t// if (!readonly && set.isReadOnly) -> addAll is called from clone()\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the set of all alternatives represented by configurations in this\r\n\t * set.\r\n\t */\r\n\t@NotNull\r\n\tpublic getRepresentedAlternatives(): BitSet {\r\n\t\tif (this._conflictInfo != null) {\r\n\t\t\treturn this._conflictInfo.conflictedAlts.clone();\r\n\t\t}\r\n\r\n\t\tlet alts: BitSet = new BitSet();\r\n\t\tfor (let config of this) {\r\n\t\t\talts.set(config.alt);\r\n\t\t}\r\n\r\n\t\treturn alts;\r\n\t}\r\n\r\n\tget isReadOnly(): boolean {\r\n\t\treturn this.mergedConfigs == null;\r\n\t}\r\n\r\n\tget isOutermostConfigSet(): boolean {\r\n\t\treturn this.outermostConfigSet;\r\n\t}\r\n\r\n\tset isOutermostConfigSet(outermostConfigSet: boolean) {\r\n\t\tif (this.outermostConfigSet && !outermostConfigSet) {\r\n\t\t\tthrow new Error(\"IllegalStateException\");\r\n\t\t}\r\n\r\n\t\tassert(!outermostConfigSet || !this._dipsIntoOuterContext);\r\n\t\tthis.outermostConfigSet = outermostConfigSet;\r\n\t}\r\n\r\n\tpublic getStates(): Array2DHashSet<ATNState> {\r\n\t\tlet states = new Array2DHashSet<ATNState>(ObjectEqualityComparator.INSTANCE);\r\n\t\tfor (let c of this.configs) {\r\n\t\t\tstates.add(c.state);\r\n\t\t}\r\n\r\n\t\treturn states;\r\n\t}\r\n\r\n\tpublic optimizeConfigs(interpreter: ATNSimulator): void {\r\n\t\tif (this.configs.length === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (let config of this.configs) {\r\n\t\t\tconfig.context = interpreter.atn.getCachedContext(config.context);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic clone(readonly: boolean): ATNConfigSet {\r\n\t\tlet copy: ATNConfigSet = new ATNConfigSet(this, readonly);\r\n\t\tif (!readonly && this.isReadOnly) {\r\n\t\t\tcopy.addAll(this.configs);\r\n\t\t}\r\n\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn this.configs.length;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEmpty(): boolean {\r\n\t\treturn this.configs.length === 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic contains(o: any): boolean {\r\n\t\tif (!(o instanceof ATNConfig)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this.mergedConfigs && this.unmerged) {\r\n\t\t\tlet config: ATNConfig = o;\r\n\t\t\tlet configKey = this.getKey(config);\r\n\t\t\tlet mergedConfig = this.mergedConfigs.get(configKey);\r\n\t\t\tif (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {\r\n\t\t\t\treturn mergedConfig.contains(config);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let c of this.unmerged) {\r\n\t\t\t\tif (c.contains(o)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (let c of this.configs) {\r\n\t\t\t\tif (c.contains(o)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic *[Symbol.iterator](): IterableIterator<ATNConfig> {\r\n\t\tyield* this.configs;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toArray(): ATNConfig[] {\r\n\t\treturn this.configs;\r\n\t}\r\n\r\n\tpublic add(e: ATNConfig): boolean;\r\n\tpublic add(e: ATNConfig, contextCache: PredictionContextCache | undefined): boolean;\r\n\tpublic add(e: ATNConfig, contextCache?: PredictionContextCache): boolean {\r\n\t\tthis.ensureWritable();\r\n\t\tif (!this.mergedConfigs || !this.unmerged) {\r\n\t\t\tthrow new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\r\n\t\t}\r\n\r\n\t\tassert(!this.outermostConfigSet || !e.reachesIntoOuterContext);\r\n\r\n\t\tif (contextCache == null) {\r\n\t\t\tcontextCache = PredictionContextCache.UNCACHED;\r\n\t\t}\r\n\r\n\t\tlet addKey: boolean;\r\n\t\tlet key = this.getKey(e);\r\n\t\tlet mergedConfig = this.mergedConfigs.get(key);\r\n\t\taddKey = (mergedConfig == null);\r\n\t\tif (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {\r\n\t\t\tmergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);\r\n\t\t\tif (e.isPrecedenceFilterSuppressed) {\r\n\t\t\t\tmergedConfig.isPrecedenceFilterSuppressed = true;\r\n\t\t\t}\r\n\r\n\t\t\tlet joined: PredictionContext = PredictionContext.join(mergedConfig.context, e.context, contextCache);\r\n\t\t\tthis.updatePropertiesForMergedConfig(e);\r\n\t\t\tif (mergedConfig.context === joined) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tmergedConfig.context = joined;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < this.unmerged.length; i++) {\r\n\t\t\tlet unmergedConfig: ATNConfig = this.unmerged[i];\r\n\t\t\tif (this.canMerge(e, key, unmergedConfig)) {\r\n\t\t\t\tunmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);\r\n\t\t\t\tif (e.isPrecedenceFilterSuppressed) {\r\n\t\t\t\t\tunmergedConfig.isPrecedenceFilterSuppressed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet joined: PredictionContext = PredictionContext.join(unmergedConfig.context, e.context, contextCache);\r\n\t\t\t\tthis.updatePropertiesForMergedConfig(e);\r\n\t\t\t\tif (unmergedConfig.context === joined) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tunmergedConfig.context = joined;\r\n\r\n\t\t\t\tif (addKey) {\r\n\t\t\t\t\tthis.mergedConfigs.put(key, unmergedConfig);\r\n\t\t\t\t\tthis.unmerged.splice(i, 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.configs.push(e);\r\n\t\tif (addKey) {\r\n\t\t\tthis.mergedConfigs.put(key, e);\r\n\t\t} else {\r\n\t\t\tthis.unmerged.push(e);\r\n\t\t}\r\n\r\n\t\tthis.updatePropertiesForAddedConfig(e);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate updatePropertiesForMergedConfig(config: ATNConfig): void {\r\n\t\t// merged configs can't change the alt or semantic context\r\n\t\tthis._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\r\n\t\tassert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\r\n\t}\r\n\r\n\tprivate updatePropertiesForAddedConfig(config: ATNConfig): void {\r\n\t\tif (this.configs.length === 1) {\r\n\t\t\tthis._uniqueAlt = config.alt;\r\n\t\t} else if (this._uniqueAlt !== config.alt) {\r\n\t\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\r\n\t\t}\r\n\r\n\t\tthis._hasSemanticContext = this._hasSemanticContext || !SemanticContext.NONE.equals(config.semanticContext);\r\n\t\tthis._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\r\n\t\tassert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\r\n\t}\r\n\r\n\tprotected canMerge(left: ATNConfig, leftKey: { state: number, alt: number }, right: ATNConfig): boolean {\r\n\t\tif (left.state.stateNumber !== right.state.stateNumber) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (leftKey.alt !== right.alt) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn left.semanticContext.equals(right.semanticContext);\r\n\t}\r\n\r\n\tprotected getKey(e: ATNConfig): { state: number, alt: number } {\r\n\t\treturn { state: e.state.stateNumber, alt: e.alt };\r\n\t}\r\n\r\n\t@Override\r\n\tpublic containsAll(c: Iterable<any>): boolean {\r\n\t\tfor (let o of c) {\r\n\t\t\tif (!(o instanceof ATNConfig)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.contains(o)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic addAll(c: Iterable<ATNConfig>): boolean;\r\n\tpublic addAll(c: Iterable<ATNConfig>, contextCache: PredictionContextCache): boolean;\r\n\tpublic addAll(c: Iterable<ATNConfig>, contextCache?: PredictionContextCache): boolean {\r\n\t\tthis.ensureWritable();\r\n\r\n\t\tlet changed: boolean = false;\r\n\t\tfor (let group of c) {\r\n\t\t\tif (this.add(group, contextCache)) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic clear(): void {\r\n\t\tthis.ensureWritable();\r\n\t\tif (!this.mergedConfigs || !this.unmerged) {\r\n\t\t\tthrow new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\r\n\t\t}\r\n\r\n\t\tthis.mergedConfigs.clear();\r\n\t\tthis.unmerged.length = 0;\r\n\t\tthis.configs.length = 0;\r\n\r\n\t\tthis._dipsIntoOuterContext = false;\r\n\t\tthis._hasSemanticContext = false;\r\n\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\r\n\t\tthis._conflictInfo = undefined;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (this === obj) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (!(obj instanceof ATNConfigSet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.outermostConfigSet === obj.outermostConfigSet\r\n\t\t\t&& Utils.equals(this._conflictInfo, obj._conflictInfo)\r\n\t\t\t&& ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tif (this.isReadOnly && this.cachedHashCode !== -1) {\r\n\t\t\treturn this.cachedHashCode;\r\n\t\t}\r\n\r\n\t\tlet hashCode: number = 1;\r\n\t\thashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);\r\n\t\thashCode = 5 * hashCode ^ ArrayEqualityComparator.INSTANCE.hashCode(this.configs);\r\n\r\n\t\tif (this.isReadOnly) {\r\n\t\t\tthis.cachedHashCode = hashCode;\r\n\t\t}\r\n\r\n\t\treturn hashCode;\r\n\t}\r\n\r\n\tpublic toString(): string;\r\n\tpublic toString(showContext: boolean): string;\r\n\tpublic toString(showContext?: boolean): string {\r\n\t\tif (showContext == null) {\r\n\t\t\tshowContext = false;\r\n\t\t}\r\n\r\n\t\tlet buf = \"\";\r\n\t\tlet sortedConfigs = this.configs.slice(0);\r\n\t\tsortedConfigs.sort((o1, o2) => {\r\n\t\t\tif (o1.alt !== o2.alt) {\r\n\t\t\t\treturn o1.alt - o2.alt;\r\n\t\t\t}\r\n\t\t\telse if (o1.state.stateNumber !== o2.state.stateNumber) {\r\n\t\t\t\treturn o1.state.stateNumber - o2.state.stateNumber;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tbuf += (\"[\");\r\n\t\tfor (let i = 0; i < sortedConfigs.length; i++) {\r\n\t\t\tif (i > 0) {\r\n\t\t\t\tbuf += (\", \");\r\n\t\t\t}\r\n\t\t\tbuf += (sortedConfigs[i].toString(undefined, true, showContext));\r\n\t\t}\r\n\t\tbuf += (\"]\");\r\n\r\n\t\tif (this._hasSemanticContext) {\r\n\t\t\tbuf += (\",hasSemanticContext=\") + (this._hasSemanticContext);\r\n\t\t}\r\n\t\tif (this._uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\r\n\t\t\tbuf += (\",uniqueAlt=\") + (this._uniqueAlt);\r\n\t\t}\r\n\t\tif (this._conflictInfo != null) {\r\n\t\t\tbuf += (\",conflictingAlts=\") + (this._conflictInfo.conflictedAlts);\r\n\t\t\tif (!this._conflictInfo.isExact) {\r\n\t\t\t\tbuf += (\"*\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this._dipsIntoOuterContext) {\r\n\t\t\tbuf += (\",dipsIntoOuterContext\");\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\r\n\tget uniqueAlt(): number {\r\n\t\treturn this._uniqueAlt;\r\n\t}\r\n\r\n\tget hasSemanticContext(): boolean {\r\n\t\treturn this._hasSemanticContext;\r\n\t}\r\n\r\n\tset hasSemanticContext(value: boolean) {\r\n\t\tthis.ensureWritable();\r\n\t\tthis._hasSemanticContext = value;\r\n\t}\r\n\r\n\tget conflictInfo(): ConflictInfo | undefined {\r\n\t\treturn this._conflictInfo;\r\n\t}\r\n\r\n\tset conflictInfo(conflictInfo: ConflictInfo | undefined) {\r\n\t\tthis.ensureWritable();\r\n\t\tthis._conflictInfo = conflictInfo;\r\n\t}\r\n\r\n\tget conflictingAlts(): BitSet | undefined {\r\n\t\tif (this._conflictInfo == null) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this._conflictInfo.conflictedAlts;\r\n\t}\r\n\r\n\tget isExactConflict(): boolean {\r\n\t\tif (this._conflictInfo == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._conflictInfo.isExact;\r\n\t}\r\n\r\n\tget dipsIntoOuterContext(): boolean {\r\n\t\treturn this._dipsIntoOuterContext;\r\n\t}\r\n\r\n\tpublic get(index: number): ATNConfig {\r\n\t\treturn this.configs[index];\r\n\t}\r\n\r\n\tprotected ensureWritable(): void {\r\n\t\tif (this.isReadOnly) {\r\n\t\t\tthrow new Error(\"This ATNConfigSet is read only.\");\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:38.7771056-07:00\r\n\r\nimport { AcceptStateInfo } from \"./AcceptStateInfo\";\r\nimport { ATN } from \"../atn/ATN\";\r\nimport { ATNConfigSet } from \"../atn/ATNConfigSet\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { LexerActionExecutor } from \"../atn/LexerActionExecutor\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { PredictionContext } from \"../atn/PredictionContext\";\r\nimport { SemanticContext } from \"../atn/SemanticContext\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\n/** A DFA state represents a set of possible ATN configurations.\r\n *  As Aho, Sethi, Ullman p. 117 says \"The DFA uses its state\r\n *  to keep track of all possible states the ATN can be in after\r\n *  reading each input symbol.  That is to say, after reading\r\n *  input a1a2..an, the DFA is in a state that represents the\r\n *  subset T of the states of the ATN that are reachable from the\r\n *  ATN's start state along some path labeled a1a2..an.\"\r\n *  In conventional NFA&rarr;DFA conversion, therefore, the subset T\r\n *  would be a bitset representing the set of states the\r\n *  ATN could be in.  We need to track the alt predicted by each\r\n *  state as well, however.  More importantly, we need to maintain\r\n *  a stack of states, tracking the closure operations as they\r\n *  jump from rule to rule, emulating rule invocations (method calls).\r\n *  I have to add a stack to simulate the proper lookahead sequences for\r\n *  the underlying LL grammar from which the ATN was derived.\r\n *\r\n *  I use a set of ATNConfig objects not simple states.  An ATNConfig\r\n *  is both a state (ala normal conversion) and a RuleContext describing\r\n *  the chain of rules (if any) followed to arrive at that state.\r\n *\r\n *  A DFA state may have multiple references to a particular state,\r\n *  but with different ATN contexts (with same or different alts)\r\n *  meaning that state was reached via a different set of rule invocations.\r\n */\r\nexport class DFAState {\r\n\tpublic stateNumber: number = -1;\r\n\r\n\t@NotNull\r\n\tpublic configs: ATNConfigSet;\r\n\r\n\t/** `edges.get(symbol)` points to target of symbol.\r\n\t */\r\n\t@NotNull\r\n\tprivate readonly edges: Map<number, DFAState>;\r\n\r\n\tprivate _acceptStateInfo: AcceptStateInfo | undefined;\r\n\r\n\t/** These keys for these edges are the top level element of the global context. */\r\n\t@NotNull\r\n\tprivate readonly contextEdges: Map<number, DFAState>;\r\n\r\n\t/** Symbols in this set require a global context transition before matching an input symbol. */\r\n\tprivate contextSymbols: BitSet | undefined;\r\n\r\n\t/**\r\n\t * This list is computed by {@link ParserATNSimulator#predicateDFAState}.\r\n\t */\r\n\tpublic predicates: DFAState.PredPrediction[] | undefined;\r\n\r\n\t/**\r\n\t * Constructs a new `DFAState`.\r\n\t *\r\n\t * @param configs The set of ATN configurations defining this state.\r\n\t */\r\n\tconstructor(configs: ATNConfigSet) {\r\n\t\tthis.configs = configs;\r\n\t\tthis.edges = new Map<number, DFAState>();\r\n\t\tthis.contextEdges = new Map<number, DFAState>();\r\n\t}\r\n\r\n\tget isContextSensitive(): boolean {\r\n\t\treturn !!this.contextSymbols;\r\n\t}\r\n\r\n\tpublic isContextSymbol(symbol: number): boolean {\r\n\t\tif (!this.isContextSensitive) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.contextSymbols!.get(symbol);\r\n\t}\r\n\r\n\tpublic setContextSymbol(symbol: number): void {\r\n\t\tassert(this.isContextSensitive);\r\n\t\tthis.contextSymbols!.set(symbol);\r\n\t}\r\n\r\n\tpublic setContextSensitive(atn: ATN): void {\r\n\t\tassert(!this.configs.isOutermostConfigSet);\r\n\t\tif (this.isContextSensitive) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!this.contextSymbols) {\r\n\t\t\tthis.contextSymbols = new BitSet();\r\n\t\t}\r\n\t}\r\n\r\n\tget acceptStateInfo(): AcceptStateInfo | undefined {\r\n\t\treturn this._acceptStateInfo;\r\n\t}\r\n\r\n\tset acceptStateInfo(acceptStateInfo: AcceptStateInfo | undefined) {\r\n\t\tthis._acceptStateInfo = acceptStateInfo;\r\n\t}\r\n\r\n\tget isAcceptState(): boolean {\r\n\t\treturn !!this._acceptStateInfo;\r\n\t}\r\n\r\n\tget prediction(): number {\r\n\t\tif (!this._acceptStateInfo) {\r\n\t\t\treturn ATN.INVALID_ALT_NUMBER;\r\n\t\t}\r\n\r\n\t\treturn this._acceptStateInfo.prediction;\r\n\t}\r\n\r\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\r\n\t\tif (!this._acceptStateInfo) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this._acceptStateInfo.lexerActionExecutor;\r\n\t}\r\n\r\n\tpublic getTarget(symbol: number): DFAState | undefined {\r\n\t\treturn this.edges.get(symbol);\r\n\t}\r\n\r\n\tpublic setTarget(symbol: number, target: DFAState): void {\r\n\t\tthis.edges.set(symbol, target);\r\n\t}\r\n\r\n\tpublic getEdgeMap(): Map<number, DFAState> {\r\n\t\treturn this.edges;\r\n\t}\r\n\r\n\tpublic getContextTarget(invokingState: number): DFAState | undefined {\r\n\t\tif (invokingState === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\tinvokingState = -1;\r\n\t\t}\r\n\r\n\t\treturn this.contextEdges.get(invokingState);\r\n\t}\r\n\r\n\tpublic setContextTarget(invokingState: number, target: DFAState): void {\r\n\t\tif (!this.isContextSensitive) {\r\n\t\t\tthrow new Error(\"The state is not context sensitive.\");\r\n\t\t}\r\n\r\n\t\tif (invokingState === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\tinvokingState = -1;\r\n\t\t}\r\n\r\n\t\tthis.contextEdges.set(invokingState, target);\r\n\t}\r\n\r\n\tpublic getContextEdgeMap(): Map<number, DFAState> {\r\n\t\tlet map = new Map<number, DFAState>(this.contextEdges);\r\n\t\tlet existing = map.get(-1);\r\n\t\tif (existing !== undefined) {\r\n\t\t\tif (map.size === 1) {\r\n\t\t\t\tlet result = new Map<number, DFAState>();\r\n\t\t\t\tresult.set(PredictionContext.EMPTY_FULL_STATE_KEY, existing);\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmap.delete(-1);\r\n\t\t\t\tmap.set(PredictionContext.EMPTY_FULL_STATE_KEY, existing);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize(7);\r\n\t\thash = MurmurHash.update(hash, this.configs.hashCode());\r\n\t\thash = MurmurHash.finish(hash, 1);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/**\r\n\t * Two {@link DFAState} instances are equal if their ATN configuration sets\r\n\t * are the same. This method is used to see if a state already exists.\r\n\t *\r\n\t * Because the number of alternatives and number of ATN configurations are\r\n\t * finite, there is a finite number of DFA states that can be processed.\r\n\t * This is necessary to show that the algorithm terminates.\r\n\t *\r\n\t * Cannot test the DFA state numbers here because in\r\n\t * {@link ParserATNSimulator#addDFAState} we need to know if any other state\r\n\t * exists that has this exact set of ATN configurations. The\r\n\t * {@link #stateNumber} is irrelevant.\r\n\t */\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\t// compare set of ATN configurations in this set with other\r\n\t\tif (this === o) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (!(o instanceof DFAState)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlet other: DFAState = o;\r\n\t\tlet sameSet: boolean = this.configs.equals(other.configs);\r\n//\t\tSystem.out.println(\"DFAState.equals: \"+configs+(sameSet?\"==\":\"!=\")+other.configs);\r\n\t\treturn sameSet;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tlet buf = \"\";\r\n\t\tbuf += (this.stateNumber) + (\":\") + (this.configs);\r\n\t\tif (this.isAcceptState) {\r\n\t\t\tbuf += (\"=>\");\r\n\t\t\tif (this.predicates) {\r\n\t\t\t\tbuf += this.predicates;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbuf += (this.prediction);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n}\r\n\r\nexport namespace DFAState {\r\n\t/** Map a predicate to a predicted alternative. */\r\n\texport class PredPrediction {\r\n\t\t@NotNull\r\n\t\tpublic pred: SemanticContext;  // never null; at least SemanticContext.NONE\r\n\t\tpublic alt: number;\r\n\t\tconstructor(@NotNull pred: SemanticContext, alt: number) {\r\n\t\t\tthis.alt = alt;\r\n\t\t\tthis.pred = pred;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic toString(): string {\r\n\t\t\treturn \"(\" + this.pred + \", \" + this.alt + \")\";\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.3184311-07:00\r\n\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { DFAState } from \"../dfa/DFAState\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\n\r\nexport abstract class ATNSimulator {\r\n\t/** Must distinguish between missing edge and edge we know leads nowhere */\r\n\tprivate static _ERROR: DFAState;\r\n\t@NotNull\r\n\tstatic get ERROR(): DFAState {\r\n\t\tif (!ATNSimulator._ERROR) {\r\n\t\t\tATNSimulator._ERROR = new DFAState(new ATNConfigSet());\r\n\t\t\tATNSimulator._ERROR.stateNumber = PredictionContext.EMPTY_FULL_STATE_KEY;\r\n\t\t}\r\n\r\n\t\treturn ATNSimulator._ERROR;\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic atn: ATN;\r\n\r\n\tconstructor(@NotNull atn: ATN) {\r\n\t\tthis.atn = atn;\r\n\t}\r\n\r\n\tpublic abstract reset(): void;\r\n\r\n\t/**\r\n\t * Clear the DFA cache used by the current instance. Since the DFA cache may\r\n\t * be shared by multiple ATN simulators, this method may affect the\r\n\t * performance (but not accuracy) of other parsers which are being used\r\n\t * concurrently.\r\n\t *\r\n\t * @ if the current instance does not\r\n\t * support clearing the DFA.\r\n\t *\r\n\t * @since 4.3\r\n\t */\r\n\tpublic clearDFA(): void {\r\n\t\tthis.atn.clearDFA();\r\n\t}\r\n}\r\n\r\nexport namespace ATNSimulator {\r\n\tconst RULE_VARIANT_DELIMITER: string = \"$\";\r\n\tconst RULE_LF_VARIANT_MARKER: string = \"$lf$\";\r\n\tconst RULE_NOLF_VARIANT_MARKER: string = \"$nolf$\";\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:50.5479602-07:00\r\n\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ConsoleErrorListener implements ANTLRErrorListener<any> {\r\n\t/**\r\n\t * Provides a default instance of {@link ConsoleErrorListener}.\r\n\t */\r\n\tpublic static readonly INSTANCE: ConsoleErrorListener = new ConsoleErrorListener();\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation prints messages to {@link System#err} containing the\r\n\t * values of `line`, `charPositionInLine`, and `msg` using\r\n\t * the following format.\r\n\t *\r\n\t * <pre>\r\n\t * line *line*:*charPositionInLine* *msg*\r\n\t * </pre>\r\n\t */\r\n\tpublic syntaxError<T>(\r\n\t\trecognizer: Recognizer<T, any>,\r\n\t\toffendingSymbol: T,\r\n\t\tline: number,\r\n\t\tcharPositionInLine: number,\r\n\t\tmsg: string,\r\n\t\te: RecognitionException | undefined): void {\r\n\t\tconsole.error(`line ${line}:${charPositionInLine} ${msg}`);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:56.8126690-07:00\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { Override, NotNull } from \"./Decorators\";\r\n\r\n/**\r\n * This implementation of {@link ANTLRErrorListener} dispatches all calls to a\r\n * collection of delegate listeners. This reduces the effort required to support multiple\r\n * listeners.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ProxyErrorListener<TSymbol, TListener extends ANTLRErrorListener<TSymbol>> implements ANTLRErrorListener<TSymbol> {\r\n\r\n\tconstructor(private delegates: TListener[]) {\r\n\t\tif (!delegates) {\r\n\t\t\tthrow new Error(\"Invalid delegates\");\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getDelegates(): ReadonlyArray<TListener> {\r\n\t\treturn this.delegates;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic syntaxError<T extends TSymbol>(\r\n\t\t@NotNull recognizer: Recognizer<T, any>,\r\n\t\toffendingSymbol: T | undefined,\r\n\t\tline: number,\r\n\t\tcharPositionInLine: number,\r\n\t\t@NotNull msg: string,\r\n\t\te: RecognitionException | undefined): void {\r\n\t\tthis.delegates.forEach((listener) => {\r\n\t\t\tif (listener.syntaxError) {\r\n\t\t\t\tlistener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:57.1954441-07:00\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { ATN } from \"./atn/ATN\";\r\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\r\nimport { ConsoleErrorListener } from \"./ConsoleErrorListener\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { ParseInfo } from \"./atn/ParseInfo\";\r\nimport { ProxyErrorListener } from \"./ProxyErrorListener\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { RuleContext } from \"./RuleContext\";\r\nimport { SuppressWarnings, NotNull } from \"./Decorators\";\r\nimport { Token } from \"./Token\";\r\nimport { Vocabulary } from \"./Vocabulary\";\r\nimport { VocabularyImpl } from \"./VocabularyImpl\";\r\n\r\nimport * as Utils from \"./misc/Utils\";\r\n\r\nexport abstract class Recognizer<TSymbol, ATNInterpreter extends ATNSimulator> {\r\n\tpublic static readonly EOF: number = -1;\r\n\r\n\tprivate static tokenTypeMapCache =\r\n\t\tnew WeakMap<Vocabulary, ReadonlyMap<string, number>>();\r\n\tprivate static ruleIndexMapCache =\r\n\t\tnew WeakMap<string[], ReadonlyMap<string, number>>();\r\n\r\n\t@SuppressWarnings(\"serial\")\r\n\t@NotNull\r\n\tprivate readonly _listeners: Array<ANTLRErrorListener<TSymbol>> = [ConsoleErrorListener.INSTANCE];\r\n\r\n\tprotected _interp!: ATNInterpreter;\r\n\r\n\tprivate _stateNumber = -1;\r\n\r\n\tpublic abstract readonly ruleNames: string[];\r\n\r\n\t/**\r\n\t * Get the vocabulary used by the recognizer.\r\n\t *\r\n\t * @returns A {@link Vocabulary} instance providing information about the\r\n\t * vocabulary used by the grammar.\r\n\t */\r\n\tpublic abstract readonly vocabulary: Vocabulary;\r\n\r\n\t/**\r\n\t * Get a map from token names to token types.\r\n\t *\r\n\t * Used for XPath and tree pattern compilation.\r\n\t */\r\n\t@NotNull\r\n\tpublic getTokenTypeMap(): ReadonlyMap<string, number> {\r\n\t\tlet vocabulary: Vocabulary = this.vocabulary;\r\n\t\tlet result = Recognizer.tokenTypeMapCache.get(vocabulary);\r\n\t\tif (result == null) {\r\n\t\t\tlet intermediateResult = new Map<string, number>();\r\n\t\t\tfor (let i = 0; i <= this.atn.maxTokenType; i++) {\r\n\t\t\t\tlet literalName = vocabulary.getLiteralName(i);\r\n\t\t\t\tif (literalName != null) {\r\n\t\t\t\t\tintermediateResult.set(literalName, i);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet symbolicName = vocabulary.getSymbolicName(i);\r\n\t\t\t\tif (symbolicName != null) {\r\n\t\t\t\t\tintermediateResult.set(symbolicName, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tintermediateResult.set(\"EOF\", Token.EOF);\r\n\t\t\tresult = intermediateResult;\r\n\t\t\tRecognizer.tokenTypeMapCache.set(vocabulary, result);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a map from rule names to rule indexes.\r\n\t *\r\n\t * Used for XPath and tree pattern compilation.\r\n\t */\r\n\t@NotNull\r\n\tpublic getRuleIndexMap(): ReadonlyMap<string, number> {\r\n\t\tlet ruleNames: string[] = this.ruleNames;\r\n\t\tif (ruleNames == null) {\r\n\t\t\tthrow new Error(\"The current recognizer does not provide a list of rule names.\");\r\n\t\t}\r\n\r\n\t\tlet result: ReadonlyMap<string, number> | undefined = Recognizer.ruleIndexMapCache.get(ruleNames);\r\n\t\tif (result == null) {\r\n\t\t\tresult = Utils.toMap(ruleNames);\r\n\t\t\tRecognizer.ruleIndexMapCache.set(ruleNames, result);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tpublic getTokenType(tokenName: string): number {\r\n\t\tlet ttype = this.getTokenTypeMap().get(tokenName);\r\n\t\tif (ttype != null) {\r\n\t\t\treturn ttype;\r\n\t\t}\r\n\t\treturn Token.INVALID_TYPE;\r\n\t}\r\n\r\n\t/**\r\n\t * If this recognizer was generated, it will have a serialized ATN\r\n\t * representation of the grammar.\r\n\t *\r\n\t * For interpreters, we don't know their serialized ATN despite having\r\n\t * created the interpreter from it.\r\n\t */\r\n\t@NotNull\r\n\tget serializedATN(): string {\r\n\t\tthrow new Error(\"there is no serialized ATN\");\r\n\t}\r\n\r\n\t/** For debugging and other purposes, might want the grammar name.\r\n\t *  Have ANTLR generate an implementation for this method.\r\n\t */\r\n\tpublic abstract readonly grammarFileName: string;\r\n\r\n\t/**\r\n\t * Get the {@link ATN} used by the recognizer for prediction.\r\n\t *\r\n\t * @returns The {@link ATN} used by the recognizer for prediction.\r\n\t */\r\n\t@NotNull\r\n\tget atn(): ATN {\r\n\t\treturn this._interp.atn;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the ATN interpreter used by the recognizer for prediction.\r\n\t *\r\n\t * @returns The ATN interpreter used by the recognizer for prediction.\r\n\t */\r\n\t@NotNull\r\n\tget interpreter(): ATNInterpreter {\r\n\t\treturn this._interp;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the ATN interpreter used by the recognizer for prediction.\r\n\t *\r\n\t * @param interpreter The ATN interpreter used by the recognizer for\r\n\t * prediction.\r\n\t */\r\n\tset interpreter(@NotNull interpreter: ATNInterpreter) {\r\n\t\tthis._interp = interpreter;\r\n\t}\r\n\r\n\t/** If profiling during the parse/lex, this will return DecisionInfo records\r\n\t *  for each decision in recognizer in a ParseInfo object.\r\n\t *\r\n\t * @since 4.3\r\n\t */\r\n\tget parseInfo(): Promise<ParseInfo | undefined> {\r\n\t\treturn Promise.resolve(undefined);\r\n\t}\r\n\r\n\t/** What is the error header, normally line/character position information? */\r\n\t@NotNull\r\n\tpublic getErrorHeader(@NotNull e: RecognitionException): string {\r\n\t\tlet token = e.getOffendingToken();\r\n\t\tif (!token) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\tlet line = token.line;\r\n\t\tlet charPositionInLine: number = token.charPositionInLine;\r\n\t\treturn \"line \" + line + \":\" + charPositionInLine;\r\n\t}\r\n\r\n\t/**\r\n\t * @exception NullPointerException if `listener` is `undefined`.\r\n\t */\r\n\tpublic addErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\r\n\t\tif (!listener) {\r\n\t\t\tthrow new TypeError(\"listener must not be null\");\r\n\t\t}\r\n\t\tthis._listeners.push(listener);\r\n\t}\r\n\r\n\tpublic removeErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\r\n\t\tlet position = this._listeners.indexOf(listener);\r\n\t\tif (position !== -1) {\r\n\t\t\tthis._listeners.splice(position, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic removeErrorListeners(): void {\r\n\t\tthis._listeners.length = 0;\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getErrorListeners(): Array<ANTLRErrorListener<TSymbol>> {\r\n\t\treturn this._listeners.slice(0);\r\n\t}\r\n\r\n\tpublic getErrorListenerDispatch(): ANTLRErrorListener<TSymbol> {\r\n\t\treturn new ProxyErrorListener<TSymbol, ANTLRErrorListener<TSymbol>>(this.getErrorListeners());\r\n\t}\r\n\r\n\t// subclass needs to override these if there are sempreds or actions\r\n\t// that the ATN interp needs to execute\r\n\tpublic sempred(\r\n\t\t_localctx: RuleContext | undefined,\r\n\t\truleIndex: number,\r\n\t\tactionIndex: number): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic precpred(\r\n\t\tlocalctx: RuleContext | undefined,\r\n\t\tprecedence: number): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tpublic action(\r\n\t\t_localctx: RuleContext | undefined,\r\n\t\truleIndex: number,\r\n\t\tactionIndex: number): void {\r\n\t\t// intentionally empty\r\n\t}\r\n\r\n\tget state(): number {\r\n\t\treturn this._stateNumber;\r\n\t}\r\n\r\n\t/** Indicate that the recognizer has changed internal state that is\r\n\t *  consistent with the ATN state passed in.  This way we always know\r\n\t *  where we are in the ATN as the parser goes along. The rule\r\n\t *  context objects form a stack that lets us see the stack of\r\n\t *  invoking rules. Combine this and we have complete ATN\r\n\t *  configuration information.\r\n\t */\r\n\tset state(atnState: number) {\r\n//\t\tSystem.err.println(\"setState \"+atnState);\r\n\t\tthis._stateNumber = atnState;\r\n//\t\tif ( traceATNStates ) _ctx.trace(atnState);\r\n\t}\r\n\r\n\tpublic abstract readonly inputStream: IntStream | undefined;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:38.5097925-07:00\r\n\r\nimport { ATN } from \"../atn/ATN\";\r\nimport { ATNSimulator } from \"../atn/ATNSimulator\";\r\nimport { ATNState } from \"../atn/ATNState\";\r\nimport { DFA } from \"./DFA\";\r\nimport { DFAState } from \"./DFAState\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { PredictionContext } from \"../atn/PredictionContext\";\r\nimport { Recognizer } from \"../Recognizer\";\r\nimport { Vocabulary } from \"../Vocabulary\";\r\nimport { VocabularyImpl } from \"../VocabularyImpl\";\r\n\r\n/** A DFA walker that knows how to dump them to serialized strings. */\r\nexport class DFASerializer {\r\n\t@NotNull\r\n\tprivate dfa: DFA;\r\n\t@NotNull\r\n\tprivate vocabulary: Vocabulary;\r\n\r\n\tpublic ruleNames?: string[];\r\n\r\n\tpublic atn?: ATN;\r\n\r\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@NotNull*/ vocabulary: Vocabulary);\r\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@Nullable*/ parser: Recognizer<any, any> | undefined);\r\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@NotNull*/ vocabulary: Vocabulary, /*@Nullable*/ ruleNames: string[] | undefined, /*@Nullable*/ atn: ATN | undefined);\r\n\tconstructor(dfa: DFA, vocabulary: Vocabulary | Recognizer<any, any> | undefined, ruleNames?: string[], atn?: ATN) {\r\n\t\tif (vocabulary instanceof Recognizer) {\r\n\t\t\truleNames = vocabulary.ruleNames;\r\n\t\t\tatn = vocabulary.atn;\r\n\t\t\tvocabulary = vocabulary.vocabulary;\r\n\t\t} else if (!vocabulary) {\r\n\t\t\tvocabulary = VocabularyImpl.EMPTY_VOCABULARY;\r\n\t\t}\r\n\r\n\t\tthis.dfa = dfa;\r\n\t\tthis.vocabulary = vocabulary;\r\n\t\tthis.ruleNames = ruleNames;\r\n\t\tthis.atn = atn;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tif (!this.dfa.s0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet buf = \"\";\r\n\r\n\t\tif (this.dfa.states) {\r\n\t\t\tlet states: DFAState[] = new Array<DFAState>(...this.dfa.states.toArray());\r\n\t\t\tstates.sort((o1, o2) => o1.stateNumber - o2.stateNumber);\r\n\r\n\t\t\tfor (let s of states) {\r\n\t\t\t\tlet edges: Map<number, DFAState> = s.getEdgeMap();\r\n\t\t\t\tlet edgeKeys = [...edges.keys()].sort((a, b) => a - b);\r\n\t\t\t\tlet contextEdges: Map<number, DFAState> = s.getContextEdgeMap();\r\n\t\t\t\tlet contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);\r\n\t\t\t\tfor (let entry of edgeKeys) {\r\n\t\t\t\t\tlet value = edges.get(entry);\r\n\t\t\t\t\tif ((value == null || value === ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet contextSymbol: boolean = false;\r\n\t\t\t\t\tbuf += (this.getStateString(s)) + (\"-\") + (this.getEdgeLabel(entry)) + (\"->\");\r\n\t\t\t\t\tif (s.isContextSymbol(entry)) {\r\n\t\t\t\t\t\tbuf += (\"!\");\r\n\t\t\t\t\t\tcontextSymbol = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet t: DFAState | undefined = value;\r\n\t\t\t\t\tif (t && t.stateNumber !== ATNSimulator.ERROR.stateNumber) {\r\n\t\t\t\t\t\tbuf += (this.getStateString(t)) + (\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (contextSymbol) {\r\n\t\t\t\t\t\tbuf += (\"ctx\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (s.isContextSensitive) {\r\n\t\t\t\t\tfor (let entry of contextEdgeKeys) {\r\n\t\t\t\t\t\tbuf += (this.getStateString(s))\r\n\t\t\t\t\t\t\t+ (\"-\")\r\n\t\t\t\t\t\t\t+ (this.getContextLabel(entry))\r\n\t\t\t\t\t\t\t+ (\"->\")\r\n\t\t\t\t\t\t\t+ (this.getStateString(contextEdges.get(entry)!))\r\n\t\t\t\t\t\t\t+ (\"\\n\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet output: string = buf;\r\n\t\tif (output.length === 0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t\t//return Utils.sortLinesInString(output);\r\n\t\treturn output;\r\n\t}\r\n\r\n\tprotected getContextLabel(i: number): string {\r\n\t\tif (i === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\treturn \"ctx:EMPTY_FULL\";\r\n\t\t}\r\n\t\telse if (i === PredictionContext.EMPTY_LOCAL_STATE_KEY) {\r\n\t\t\treturn \"ctx:EMPTY_LOCAL\";\r\n\t\t}\r\n\r\n\t\tif (this.atn && i > 0 && i <= this.atn.states.length) {\r\n\t\t\tlet state: ATNState = this.atn.states[i];\r\n\t\t\tlet ruleIndex: number = state.ruleIndex;\r\n\t\t\tif (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {\r\n\t\t\t\treturn \"ctx:\" + String(i) + \"(\" + this.ruleNames[ruleIndex] + \")\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn \"ctx:\" + String(i);\r\n\t}\r\n\r\n\tprotected getEdgeLabel(i: number): string {\r\n\t\treturn this.vocabulary.getDisplayName(i);\r\n\t}\r\n\r\n\tpublic getStateString(s: DFAState): string {\r\n\t\tif (s === ATNSimulator.ERROR) {\r\n\t\t\treturn \"ERROR\";\r\n\t\t}\r\n\r\n\t\tlet n: number = s.stateNumber;\r\n\t\tlet stateStr: string = \"s\" + n;\r\n\t\tif (s.isAcceptState) {\r\n\t\t\tif (s.predicates) {\r\n\t\t\t\tstateStr = \":s\" + n + \"=>\" + s.predicates;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstateStr = \":s\" + n + \"=>\" + s.prediction;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (s.isContextSensitive) {\r\n\t\t\tstateStr += \"*\";\r\n\t\t\tfor (let config of s.configs) {\r\n\t\t\t\tif (config.reachesIntoOuterContext) {\r\n\t\t\t\t\tstateStr += \"*\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stateStr;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:39.2167238-07:00\r\n\r\nimport { DFA } from \"./DFA\";\r\nimport { DFASerializer } from \"./DFASerializer\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { VocabularyImpl } from \"../VocabularyImpl\";\r\n\r\nexport class LexerDFASerializer extends DFASerializer {\r\n\tconstructor( @NotNull dfa: DFA) {\r\n\t\tsuper(dfa, VocabularyImpl.EMPTY_VOCABULARY);\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tprotected getEdgeLabel(i: number): string {\r\n\t\treturn \"'\" + String.fromCodePoint(i) + \"'\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.4734328-07:00\r\n\r\nexport enum ATNStateType {\r\n\tINVALID_TYPE = 0,\r\n\tBASIC = 1,\r\n\tRULE_START = 2,\r\n\tBLOCK_START = 3,\r\n\tPLUS_BLOCK_START = 4,\r\n\tSTAR_BLOCK_START = 5,\r\n\tTOKEN_START = 6,\r\n\tRULE_STOP = 7,\r\n\tBLOCK_END = 8,\r\n\tSTAR_LOOP_BACK = 9,\r\n\tSTAR_LOOP_ENTRY = 10,\r\n\tPLUS_LOOP_BACK = 11,\r\n\tLOOP_END = 12,\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.7099201-07:00\r\n\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { Override } from \"../Decorators\";\r\nimport { StarLoopbackState } from \"./StarLoopbackState\";\r\n\r\nexport class StarLoopEntryState extends DecisionState {\r\n\t// This is always set during ATN deserialization\r\n\tpublic loopBackState!: StarLoopbackState;\r\n\r\n\t/**\r\n\t * Indicates whether this state can benefit from a precedence DFA during SLL\r\n\t * decision making.\r\n\t *\r\n\t * This is a computed property that is calculated during ATN deserialization\r\n\t * and stored for use in {@link ParserATNSimulator} and\r\n\t * {@link ParserInterpreter}.\r\n\t *\r\n\t * @see `DFA.isPrecedenceDfa`\r\n\t */\r\n\tpublic precedenceRuleDecision: boolean = false;\r\n\r\n\t/**\r\n\t * For precedence decisions, this set marks states *S* which have all\r\n\t * of the following characteristics:\r\n\t *\r\n\t * * One or more invocation sites of the current rule returns to\r\n\t *   *S*.\r\n\t * * The closure from *S* includes the current decision without\r\n\t *   passing through any rule invocations or stepping out of the current\r\n\t *   rule.\r\n\t *\r\n\t * This field is not used when {@link #precedenceRuleDecision} is\r\n\t * `false`.\r\n\t */\r\n\tpublic precedenceLoopbackStates: BitSet = new BitSet();\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.STAR_LOOP_ENTRY;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:38.3567094-07:00\r\n\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { ATN } from \"../atn/ATN\";\r\nimport { ATNConfigSet } from \"../atn/ATNConfigSet\";\r\nimport { ATNState } from \"../atn/ATNState\";\r\nimport { ATNType } from \"../atn/ATNType\";\r\nimport { DecisionState } from \"../atn/DecisionState\";\r\nimport { DFASerializer } from \"./DFASerializer\";\r\nimport { DFAState } from \"./DFAState\";\r\nimport { LexerATNSimulator } from \"../atn/LexerATNSimulator\";\r\nimport { LexerDFASerializer } from \"./LexerDFASerializer\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { StarLoopEntryState } from \"../atn/StarLoopEntryState\";\r\nimport { Token } from \"../Token\";\r\nimport { TokensStartState } from \"../atn/TokensStartState\";\r\nimport { Vocabulary } from \"../Vocabulary\";\r\nimport { VocabularyImpl } from \"../VocabularyImpl\";\r\n\r\nexport class DFA {\r\n\t/**\r\n\t * A set of all states in the `DFA`.\r\n\t *\r\n\t * Note that this collection of states holds the DFA states for both SLL and LL prediction. Only the start state\r\n\t * needs to be differentiated for these cases, which is tracked by the `s0` and `s0full` fields.\r\n\t */\r\n\t@NotNull\r\n\tpublic readonly states: Array2DHashSet<DFAState> = new Array2DHashSet<DFAState>(ObjectEqualityComparator.INSTANCE);\r\n\r\n\tpublic s0: DFAState | undefined;\r\n\r\n\tpublic s0full: DFAState | undefined;\r\n\r\n\tpublic readonly decision: number;\r\n\r\n\t/** From which ATN state did we create this DFA? */\r\n\t@NotNull\r\n\tpublic atnStartState: ATNState;\r\n\t/**\r\n\t * Note: this field is accessed as `atnStartState.atn` in other targets. The TypeScript target keeps a separate copy\r\n\t * to avoid a number of additional null/undefined checks each time the ATN is accessed.\r\n\t */\r\n\t@NotNull\r\n\tpublic atn: ATN;\r\n\r\n\tprivate nextStateNumber: number = 0;\r\n\r\n\t/**\r\n\t * `true` if this DFA is for a precedence decision; otherwise,\r\n\t * `false`. This is the backing field for {@link #isPrecedenceDfa}.\r\n\t */\r\n\tprivate precedenceDfa: boolean;\r\n\r\n\t/**\r\n\t * Constructs a `DFA` instance associated with a lexer mode.\r\n\t *\r\n\t * The start state for a `DFA` constructed with this constructor should be a `TokensStartState`, which is the start\r\n\t * state for a lexer mode. The prediction made by this DFA determines the lexer rule which matches the current\r\n\t * input.\r\n\t *\r\n\t * @param atnStartState The start state for the mode.\r\n\t */\r\n\tconstructor(atnStartState: TokensStartState);\r\n\t/**\r\n\t * Constructs a `DFA` instance associated with a decision.\r\n\t *\r\n\t * @param atnStartState The decision associated with this DFA.\r\n\t * @param decision The decision number.\r\n\t */\r\n\tconstructor(atnStartState: DecisionState, decision: number);\r\n\tconstructor(@NotNull atnStartState: ATNState, decision: number = 0) {\r\n\t\tif (!atnStartState.atn) {\r\n\t\t\tthrow new Error(\"The ATNState must be associated with an ATN\");\r\n\t\t}\r\n\r\n\t\tthis.atnStartState = atnStartState;\r\n\t\tthis.atn = atnStartState.atn;\r\n\t\tthis.decision = decision;\r\n\r\n\t\t// Precedence DFAs are associated with the special precedence decision created for left-recursive rules which\r\n\t\t// evaluate their alternatives using a precedence hierarchy. When such a decision is encountered, we mark this\r\n\t\t// DFA instance as a precedence DFA and initialize the initial states s0 and s0full to special DFAState\r\n\t\t// instances which use outgoing edges to link to the actual start state used for each precedence level.\r\n\t\tlet isPrecedenceDfa: boolean = false;\r\n\t\tif (atnStartState instanceof StarLoopEntryState) {\r\n\t\t\tif (atnStartState.precedenceRuleDecision) {\r\n\t\t\t\tisPrecedenceDfa = true;\r\n\t\t\t\tthis.s0 = new DFAState(new ATNConfigSet());\r\n\t\t\t\tthis.s0full = new DFAState(new ATNConfigSet());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.precedenceDfa = isPrecedenceDfa;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\r\n\t * start state {@link #s0} which is not stored in {@link #states}. The\r\n\t * {@link DFAState#edges} array for this start state contains outgoing edges\r\n\t * supplying individual start states corresponding to specific precedence\r\n\t * values.\r\n\t *\r\n\t * @returns `true` if this is a precedence DFA; otherwise,\r\n\t * `false`.\r\n\t * @see Parser.precedence\r\n\t */\r\n\tget isPrecedenceDfa(): boolean {\r\n\t\treturn this.precedenceDfa;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the start state for a specific precedence value.\r\n\t *\r\n\t * @param precedence The current precedence.\r\n\t * @returns The start state corresponding to the specified precedence, or\r\n\t * `undefined` if no start state exists for the specified precedence.\r\n\t *\r\n\t * @ if this is not a precedence DFA.\r\n\t * @see `isPrecedenceDfa`\r\n\t */\r\n\tpublic getPrecedenceStartState(precedence: number, fullContext: boolean): DFAState | undefined {\r\n\t\tif (!this.isPrecedenceDfa) {\r\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\r\n\t\t}\r\n\r\n\t\t// s0 and s0full are never null for a precedence DFA\r\n\t\tif (fullContext) {\r\n\t\t\treturn (this.s0full as DFAState).getTarget(precedence);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn (this.s0 as DFAState).getTarget(precedence);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set the start state for a specific precedence value.\r\n\t *\r\n\t * @param precedence The current precedence.\r\n\t * @param startState The start state corresponding to the specified\r\n\t * precedence.\r\n\t *\r\n\t * @ if this is not a precedence DFA.\r\n\t * @see `isPrecedenceDfa`\r\n\t */\r\n\tpublic setPrecedenceStartState(precedence: number, fullContext: boolean, startState: DFAState): void {\r\n\t\tif (!this.isPrecedenceDfa) {\r\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\r\n\t\t}\r\n\r\n\t\tif (precedence < 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (fullContext) {\r\n\t\t\t// s0full is never null for a precedence DFA\r\n\t\t\t(this.s0full as DFAState).setTarget(precedence, startState);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// s0 is never null for a precedence DFA\r\n\t\t\t(this.s0 as DFAState).setTarget(precedence, startState);\r\n\t\t}\r\n\t}\r\n\r\n\tget isEmpty(): boolean {\r\n\t\tif (this.isPrecedenceDfa) {\r\n\t\t\t// s0 and s0full are never null for a precedence DFA\r\n\t\t\treturn this.s0!.getEdgeMap().size === 0 && this.s0full!.getEdgeMap().size === 0;\r\n\t\t}\r\n\r\n\t\treturn this.s0 == null && this.s0full == null;\r\n\t}\r\n\r\n\tget isContextSensitive(): boolean {\r\n\t\tif (this.isPrecedenceDfa) {\r\n\t\t\t// s0full is never null for a precedence DFA\r\n\t\t\treturn (this.s0full as DFAState).getEdgeMap().size > 0;\r\n\t\t}\r\n\r\n\t\treturn this.s0full != null;\r\n\t}\r\n\r\n\tpublic addState(state: DFAState): DFAState {\r\n\t\tstate.stateNumber = this.nextStateNumber++;\r\n\t\treturn this.states.getOrAdd(state);\r\n\t}\r\n\r\n\tpublic toString(): string;\r\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary): string;\r\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary, ruleNames: string[] | undefined): string;\r\n\tpublic toString(vocabulary?: Vocabulary, ruleNames?: string[]): string {\r\n\t\tif (!vocabulary) {\r\n\t\t\tvocabulary = VocabularyImpl.EMPTY_VOCABULARY;\r\n\t\t}\r\n\r\n\t\tif (!this.s0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet serializer: DFASerializer;\r\n\t\tif (ruleNames) {\r\n\t\t\tserializer = new DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);\r\n\t\t} else {\r\n\t\t\tserializer = new DFASerializer(this, vocabulary);\r\n\t\t}\r\n\r\n\t\treturn serializer.toString();\r\n\t}\r\n\r\n\tpublic toLexerString(): string {\r\n\t\tif (!this.s0) {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet serializer: DFASerializer = new LexerDFASerializer(this);\r\n\t\treturn serializer.toString();\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:40.5099429-07:00\r\n\r\nimport { Arrays } from \"./Arrays\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { JavaCollection } from \"./Stubs\";\r\n\r\nconst EMPTY_DATA: Int32Array = new Int32Array(0);\r\n\r\nconst INITIAL_SIZE: number = 4;\r\nconst MAX_ARRAY_SIZE: number = (((1 << 31) >>> 0) - 1) - 8;\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class IntegerList {\r\n\t@NotNull\r\n\tprivate _data: Int32Array;\r\n\r\n\tprivate _size: number;\r\n\r\n\tconstructor(arg?: number | IntegerList | Iterable<number>) {\r\n\t\tif (!arg) {\r\n\t\t\tthis._data = EMPTY_DATA;\r\n\t\t\tthis._size = 0;\r\n\t\t} else if (arg instanceof IntegerList) {\r\n\t\t\tthis._data = arg._data.slice(0);\r\n\t\t\tthis._size = arg._size;\r\n\t\t} else if (typeof arg === \"number\") {\r\n\t\t\tif (arg === 0) {\r\n\t\t\t\tthis._data = EMPTY_DATA;\r\n\t\t\t\tthis._size = 0;\r\n\t\t\t} else {\r\n\t\t\t\tthis._data = new Int32Array(arg);\r\n\t\t\t\tthis._size = 0;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// arg is Iterable<number>\r\n\t\t\tthis._data = EMPTY_DATA;\r\n\t\t\tthis._size = 0;\r\n\t\t\tfor (let value of arg) {\r\n\t\t\t\tthis.add(value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic add(value: number): void {\r\n\t\tif (this._data.length === this._size) {\r\n\t\t\tthis.ensureCapacity(this._size + 1);\r\n\t\t}\r\n\r\n\t\tthis._data[this._size] = value;\r\n\t\tthis._size++;\r\n\t}\r\n\r\n\tpublic addAll(list: number[] | IntegerList | JavaCollection<number>): void {\r\n\t\tif (Array.isArray(list)) {\r\n\t\t\tthis.ensureCapacity(this._size + list.length);\r\n\t\t\tthis._data.subarray(this._size, this._size + list.length).set(list);\r\n\t\t\tthis._size += list.length;\r\n\t\t} else if (list instanceof IntegerList) {\r\n\t\t\tthis.ensureCapacity(this._size + list._size);\r\n\t\t\tthis._data.subarray(this._size, this._size + list.size).set(list._data);\r\n\t\t\tthis._size += list._size;\r\n\t\t} else {\r\n\t\t\t// list is JavaCollection<number>\r\n\t\t\tthis.ensureCapacity(this._size + list.size);\r\n\t\t\tlet current: number = 0;\r\n\t\t\tfor (let xi of list) {\r\n\t\t\t\tthis._data[this._size + current] = xi;\r\n\t\t\t\tcurrent++;\r\n\t\t\t}\r\n\r\n\t\t\tthis._size += list.size;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic get(index: number): number {\r\n\t\tif (index < 0 || index >= this._size) {\r\n\t\t\tthrow RangeError();\r\n\t\t}\r\n\r\n\t\treturn this._data[index];\r\n\t}\r\n\r\n\tpublic contains(value: number): boolean {\r\n\t\tfor (let i = 0; i < this._size; i++) {\r\n\t\t\tif (this._data[i] === value) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic set(index: number, value: number): number {\r\n\t\tif (index < 0 || index >= this._size) {\r\n\t\t\tthrow RangeError();\r\n\t\t}\r\n\r\n\t\tlet previous: number = this._data[index];\r\n\t\tthis._data[index] = value;\r\n\t\treturn previous;\r\n\t}\r\n\r\n\tpublic removeAt(index: number): number {\r\n\t\tlet value: number = this.get(index);\r\n\t\tthis._data.copyWithin(index, index + 1, this._size);\r\n\t\tthis._data[this._size - 1] = 0;\r\n\t\tthis._size--;\r\n\t\treturn value;\r\n\t}\r\n\r\n\tpublic removeRange(fromIndex: number, toIndex: number): void {\r\n\t\tif (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\r\n\t\t\tthrow RangeError();\r\n\t\t}\r\n\r\n\t\tif (fromIndex > toIndex) {\r\n\t\t\tthrow RangeError();\r\n\t\t}\r\n\r\n\t\tthis._data.copyWithin(toIndex, fromIndex, this._size);\r\n\t\tthis._data.fill(0, this._size - (toIndex - fromIndex), this._size);\r\n\t\tthis._size -= (toIndex - fromIndex);\r\n\t}\r\n\r\n\tget isEmpty(): boolean {\r\n\t\treturn this._size === 0;\r\n\t}\r\n\r\n\tget size(): number {\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tpublic trimToSize(): void {\r\n\t\tif (this._data.length === this._size) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._data = this._data.slice(0, this._size);\r\n\t}\r\n\r\n\tpublic clear(): void {\r\n\t\tthis._data.fill(0, 0, this._size);\r\n\t\tthis._size = 0;\r\n\t}\r\n\r\n\tpublic toArray(): number[] {\r\n\t\tif (this._size === 0) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\r\n\t\treturn Array.from(this._data.subarray(0, this._size));\r\n\t}\r\n\r\n\tpublic sort(): void {\r\n\t\tthis._data.subarray(0, this._size).sort();\r\n\t}\r\n\r\n\t/**\r\n\t * Compares the specified object with this list for equality.  Returns\r\n\t * `true` if and only if the specified object is also an {@link IntegerList},\r\n\t * both lists have the same size, and all corresponding pairs of elements in\r\n\t * the two lists are equal.  In other words, two lists are defined to be\r\n\t * equal if they contain the same elements in the same order.\r\n\t *\r\n\t * This implementation first checks if the specified object is this\r\n\t * list. If so, it returns `true`; if not, it checks if the\r\n\t * specified object is an {@link IntegerList}. If not, it returns `false`;\r\n\t * if so, it checks the size of both lists. If the lists are not the same size,\r\n\t * it returns `false`; otherwise it iterates over both lists, comparing\r\n\t * corresponding pairs of elements.  If any comparison returns `false`,\r\n\t * this method returns `false`.\r\n\t *\r\n\t * @param o the object to be compared for equality with this list\r\n\t * @returns `true` if the specified object is equal to this list\r\n\t */\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (o === this) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (!(o instanceof IntegerList)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (this._size !== o._size) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < this._size; i++) {\r\n\t\t\tif (this._data[i] !== o._data[i]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the hash code value for this list.\r\n\t *\r\n\t * This implementation uses exactly the code that is used to define the\r\n\t * list hash function in the documentation for the {@link List#hashCode}\r\n\t * method.\r\n\t *\r\n\t * @returns the hash code value for this list\r\n\t */\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hashCode: number = 1;\r\n\t\tfor (let i = 0; i < this._size; i++) {\r\n\t\t\thashCode = 31 * hashCode + this._data[i];\r\n\t\t}\r\n\r\n\t\treturn hashCode;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a string representation of this list.\r\n\t */\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this._data.toString();\r\n\t}\r\n\r\n\tpublic binarySearch(key: number, fromIndex?: number, toIndex?: number): number {\r\n\t\tif (fromIndex === undefined) {\r\n\t\t\tfromIndex = 0;\r\n\t\t}\r\n\r\n\t\tif (toIndex === undefined) {\r\n\t\t\ttoIndex = this._size;\r\n\t\t}\r\n\r\n\t\tif (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\tif (fromIndex > toIndex) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\treturn Arrays.binarySearch(this._data, key, fromIndex, toIndex);\r\n\t}\r\n\r\n\tprivate ensureCapacity(capacity: number): void {\r\n\t\tif (capacity < 0 || capacity > MAX_ARRAY_SIZE) {\r\n\t\t\tthrow new RangeError();\r\n\t\t}\r\n\r\n\t\tlet newLength: number;\r\n\t\tif (this._data.length === 0) {\r\n\t\t\tnewLength = INITIAL_SIZE;\r\n\t\t} else {\r\n\t\t\tnewLength = this._data.length;\r\n\t\t}\r\n\r\n\t\twhile (newLength < capacity) {\r\n\t\t\tnewLength = newLength * 2;\r\n\t\t\tif (newLength < 0 || newLength > MAX_ARRAY_SIZE) {\r\n\t\t\t\tnewLength = MAX_ARRAY_SIZE;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet tmp = new Int32Array(newLength);\r\n\t\ttmp.set(this._data);\r\n\t\tthis._data = tmp;\r\n\t}\r\n\r\n\t/** Convert the list to a UTF-16 encoded char array. If all values are less\r\n\t *  than the 0xFFFF 16-bit code point limit then this is just a char array\r\n\t *  of 16-bit char as usual. For values in the supplementary range, encode\r\n\t * them as two UTF-16 code units.\r\n\t */\r\n\tpublic toCharArray(): Uint16Array {\r\n\t\t// Optimize for the common case (all data values are < 0xFFFF) to avoid an extra scan\r\n\t\tlet resultArray: Uint16Array = new Uint16Array(this._size);\r\n\t\tlet resultIdx = 0;\r\n\t\tlet calculatedPreciseResultSize = false;\r\n\t\tfor (let i = 0; i < this._size; i++) {\r\n\t\t\tlet codePoint = this._data[i];\r\n\t\t\tif (codePoint >= 0 && codePoint < 0x10000) {\r\n\t\t\t\tresultArray[resultIdx] = codePoint;\r\n\t\t\t\tresultIdx++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate the precise result size if we encounter a code point > 0xFFFF\r\n\t\t\tif (!calculatedPreciseResultSize) {\r\n\t\t\t\tlet newResultArray = new Uint16Array(this.charArraySize());\r\n\t\t\t\tnewResultArray.set(resultArray, 0);\r\n\t\t\t\tresultArray = newResultArray;\r\n\t\t\t\tcalculatedPreciseResultSize = true;\r\n\t\t\t}\r\n\r\n\t\t\t// This will throw RangeError if the code point is not a valid Unicode code point\r\n\t\t\tlet pair = String.fromCodePoint(codePoint);\r\n\t\t\tresultArray[resultIdx] = pair.charCodeAt(0);\r\n\t\t\tresultArray[resultIdx + 1] = pair.charCodeAt(1);\r\n\t\t\tresultIdx += 2;\r\n\t\t}\r\n\t\treturn resultArray;\r\n\t}\r\n\r\n\tprivate charArraySize(): number {\r\n\t\tlet result = 0;\r\n\t\tfor (let i = 0; i < this._size; i++) {\r\n\t\t\tresult += this._data[i] >= 0x10000 ? 2 : 1;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:40.7402214-07:00\r\n\r\nimport { Override } from \"../Decorators\";\r\nimport { Equatable } from \"./Stubs\";\r\n\r\nconst INTERVAL_POOL_MAX_VALUE: number = 1000;\r\n\r\n/** An immutable inclusive interval a..b */\r\nexport class Interval implements Equatable {\r\n\tprivate static _INVALID: Interval = new Interval(-1, -2);\r\n\tstatic get INVALID(): Interval {\r\n\t\treturn Interval._INVALID;\r\n\t}\r\n\r\n\tprivate static readonly cache: Interval[] = new Array<Interval>(INTERVAL_POOL_MAX_VALUE + 1);\r\n\r\n\t/**\r\n\t * @param a The start of the interval\r\n\t * @param b The end of the interval (inclusive)\r\n\t */\r\n\tconstructor(public a: number, public b: number) {\r\n\t}\r\n\r\n\t/** Interval objects are used readonly so share all with the\r\n\t *  same single value a==b up to some max size.  Use an array as a perfect hash.\r\n\t *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new\r\n\t *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets\r\n\t *  have a..a (set with 1 element).\r\n\t */\r\n\tpublic static of(a: number, b: number): Interval {\r\n\t\t// cache just a..a\r\n\t\tif (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {\r\n\t\t\treturn new Interval(a, b);\r\n\t\t}\r\n\r\n\t\tif (Interval.cache[a] == null) {\r\n\t\t\tInterval.cache[a] = new Interval(a, a);\r\n\t\t}\r\n\r\n\t\treturn Interval.cache[a];\r\n\t}\r\n\r\n\t/** return number of elements between a and b inclusively. x..x is length 1.\r\n\t *  if b &lt; a, then length is 0.  9..10 has length 2.\r\n\t */\r\n\tget length(): number {\r\n\t\tif (this.b < this.a) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn this.b - this.a + 1;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (o === this) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (!(o instanceof Interval)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.a === o.a && this.b === o.b;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = 23;\r\n\t\thash = hash * 31 + this.a;\r\n\t\thash = hash * 31 + this.b;\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/** Does this start completely before other? Disjoint */\r\n\tpublic startsBeforeDisjoint(other: Interval): boolean {\r\n\t\treturn this.a < other.a && this.b < other.a;\r\n\t}\r\n\r\n\t/** Does this start at or before other? Nondisjoint */\r\n\tpublic startsBeforeNonDisjoint(other: Interval): boolean {\r\n\t\treturn this.a <= other.a && this.b >= other.a;\r\n\t}\r\n\r\n\t/** Does this.a start after other.b? May or may not be disjoint */\r\n\tpublic startsAfter(other: Interval): boolean {\r\n\t\treturn this.a > other.a;\r\n\t}\r\n\r\n\t/** Does this start completely after other? Disjoint */\r\n\tpublic startsAfterDisjoint(other: Interval): boolean {\r\n\t\treturn this.a > other.b;\r\n\t}\r\n\r\n\t/** Does this start after other? NonDisjoint */\r\n\tpublic startsAfterNonDisjoint(other: Interval): boolean {\r\n\t\treturn this.a > other.a && this.a <= other.b; // this.b>=other.b implied\r\n\t}\r\n\r\n\t/** Are both ranges disjoint? I.e., no overlap? */\r\n\tpublic disjoint(other: Interval): boolean {\r\n\t\treturn this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\r\n\t}\r\n\r\n\t/** Are two intervals adjacent such as 0..41 and 42..42? */\r\n\tpublic adjacent(other: Interval): boolean {\r\n\t\treturn this.a === other.b + 1 || this.b === other.a - 1;\r\n\t}\r\n\r\n\tpublic properlyContains(other: Interval): boolean {\r\n\t\treturn other.a >= this.a && other.b <= this.b;\r\n\t}\r\n\r\n\t/** Return the interval computed from combining this and other */\r\n\tpublic union(other: Interval): Interval {\r\n\t\treturn Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));\r\n\t}\r\n\r\n\t/** Return the interval in common between this and o */\r\n\tpublic intersection(other: Interval): Interval {\r\n\t\treturn Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));\r\n\t}\r\n\r\n\t/** Return the interval with elements from `this` not in `other`;\r\n\t *  `other` must not be totally enclosed (properly contained)\r\n\t *  within `this`, which would result in two disjoint intervals\r\n\t *  instead of the single one returned by this method.\r\n\t */\r\n\tpublic differenceNotProperlyContained(other: Interval): Interval | undefined {\r\n\t\tlet diff: Interval | undefined;\r\n\t\tif (other.startsBeforeNonDisjoint(this)) {\r\n\t\t\t// other.a to left of this.a (or same)\r\n\t\t\tdiff = Interval.of(Math.max(this.a, other.b + 1), this.b);\r\n\t\t} else if (other.startsAfterNonDisjoint(this)) {\r\n\t\t\t// other.a to right of this.a\r\n\t\t\tdiff = Interval.of(this.a, other.a - 1);\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn this.a + \"..\" + this.b;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:50.1614404-07:00\r\n\r\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { NotNull, Override } from \"./Decorators\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenSource } from \"./TokenSource\";\r\nimport { WritableToken } from \"./WritableToken\";\r\n\r\nexport class CommonToken implements WritableToken {\r\n\t/**\r\n\t * An empty {@link Tuple2} which is used as the default value of\r\n\t * {@link #source} for tokens that do not have a source.\r\n\t */\r\n\tprotected static readonly EMPTY_SOURCE: { source?: TokenSource, stream?: CharStream } =\r\n\t\t{ source: undefined, stream: undefined };\r\n\r\n\t/**\r\n\t * This is the backing field for `type`.\r\n\t */\r\n\tprivate _type: number;\r\n\t/**\r\n\t * This is the backing field for {@link #getLine} and {@link #setLine}.\r\n\t */\r\n\tprivate _line: number = 0;\r\n\t/**\r\n\t * This is the backing field for {@link #getCharPositionInLine} and\r\n\t * {@link #setCharPositionInLine}.\r\n\t */\r\n\tprivate _charPositionInLine: number = -1; // set to invalid position\r\n\t/**\r\n\t * This is the backing field for {@link #getChannel} and\r\n\t * {@link #setChannel}.\r\n\t */\r\n\tprivate _channel: number = Token.DEFAULT_CHANNEL;\r\n\t/**\r\n\t * This is the backing field for {@link #getTokenSource} and\r\n\t * {@link #getInputStream}.\r\n\t *\r\n\t * These properties share a field to reduce the memory footprint of\r\n\t * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from\r\n\t * the same source and input stream share a reference to the same\r\n\t * {@link Tuple2} containing these values.\r\n\t */\r\n\t@NotNull\r\n\tprotected source: { source?: TokenSource, stream?: CharStream };\r\n\r\n\t/**\r\n\t * This is the backing field for {@link #getText} when the token text is\r\n\t * explicitly set in the constructor or via {@link #setText}.\r\n\t *\r\n\t * @see `text`\r\n\t */\r\n\tprivate _text?: string;\r\n\r\n\t/**\r\n\t * This is the backing field for `tokenIndex`.\r\n\t */\r\n\tprotected index: number = -1;\r\n\r\n\t/**\r\n\t * This is the backing field for `startIndex`.\r\n\t */\r\n\tprotected start: number;\r\n\r\n\t/**\r\n\t * This is the backing field for `stopIndex`.\r\n\t */\r\n\tprivate stop: number;\r\n\r\n\tconstructor(type: number, text?: string, @NotNull source: { source?: TokenSource, stream?: CharStream } = CommonToken.EMPTY_SOURCE, channel: number = Token.DEFAULT_CHANNEL, start: number = 0, stop: number = 0) {\r\n\t\tthis._text = text;\r\n\t\tthis._type = type;\r\n\t\tthis.source = source;\r\n\t\tthis._channel = channel;\r\n\t\tthis.start = start;\r\n\t\tthis.stop = stop;\r\n\t\tif (source.source != null) {\r\n\t\t\tthis._line = source.source.line;\r\n\t\t\tthis._charPositionInLine = source.source.charPositionInLine;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\r\n\t *\r\n\t * If `oldToken` is also a {@link CommonToken} instance, the newly\r\n\t * constructed token will share a reference to the {@link #text} field and\r\n\t * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will\r\n\t * be assigned the result of calling {@link #getText}, and {@link #source}\r\n\t * will be constructed from the result of {@link Token#getTokenSource} and\r\n\t * {@link Token#getInputStream}.\r\n\t *\r\n\t * @param oldToken The token to copy.\r\n\t */\r\n\tpublic static fromToken(@NotNull oldToken: Token): CommonToken {\r\n\t\tlet result: CommonToken = new CommonToken(oldToken.type, undefined, CommonToken.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);\r\n\t\tresult._line = oldToken.line;\r\n\t\tresult.index = oldToken.tokenIndex;\r\n\t\tresult._charPositionInLine = oldToken.charPositionInLine;\r\n\r\n\t\tif (oldToken instanceof CommonToken) {\r\n\t\t\tresult._text = oldToken._text;\r\n\t\t\tresult.source = oldToken.source;\r\n\t\t} else {\r\n\t\t\tresult._text = oldToken.text;\r\n\t\t\tresult.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tget type(): number {\r\n\t\treturn this._type;\r\n\t}\r\n\r\n\t// @Override\r\n\tset type(type: number) {\r\n\t\tthis._type = type;\r\n\t}\r\n\r\n\t@Override\r\n\tget line(): number {\r\n\t\treturn this._line;\r\n\t}\r\n\r\n\t// @Override\r\n\tset line(line: number) {\r\n\t\tthis._line = line;\r\n\t}\r\n\r\n\t@Override\r\n\tget text(): string | undefined {\r\n\t\tif (this._text != null) {\r\n\t\t\treturn this._text;\r\n\t\t}\r\n\r\n\t\tlet input: CharStream | undefined = this.inputStream;\r\n\t\tif (input == null) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet n: number = input.size;\r\n\t\tif (this.start < n && this.stop < n) {\r\n\t\t\treturn input.getText(Interval.of(this.start, this.stop));\r\n\t\t} else {\r\n\t\t\treturn \"<EOF>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Explicitly set the text for this token. If {code text} is not\r\n\t * `undefined`, then {@link #getText} will return this value rather than\r\n\t * extracting the text from the input.\r\n\t *\r\n\t * @param text The explicit text of the token, or `undefined` if the text\r\n\t * should be obtained from the input along with the start and stop indexes\r\n\t * of the token.\r\n\t */\r\n\t// @Override\r\n\tset text(text: string | undefined) {\r\n\t\tthis._text = text;\r\n\t}\r\n\r\n\t@Override\r\n\tget charPositionInLine(): number {\r\n\t\treturn this._charPositionInLine;\r\n\t}\r\n\r\n\t// @Override\r\n\tset charPositionInLine(charPositionInLine: number) {\r\n\t\tthis._charPositionInLine = charPositionInLine;\r\n\t}\r\n\r\n\t@Override\r\n\tget channel(): number {\r\n\t\treturn this._channel;\r\n\t}\r\n\r\n\t// @Override\r\n\tset channel(channel: number) {\r\n\t\tthis._channel = channel;\r\n\t}\r\n\r\n\t@Override\r\n\tget startIndex(): number {\r\n\t\treturn this.start;\r\n\t}\r\n\r\n\tset startIndex(start: number) {\r\n\t\tthis.start = start;\r\n\t}\r\n\r\n\t@Override\r\n\tget stopIndex(): number {\r\n\t\treturn this.stop;\r\n\t}\r\n\r\n\tset stopIndex(stop: number) {\r\n\t\tthis.stop = stop;\r\n\t}\r\n\r\n\t@Override\r\n\tget tokenIndex(): number {\r\n\t\treturn this.index;\r\n\t}\r\n\r\n\t// @Override\r\n\tset tokenIndex(index: number) {\r\n\t\tthis.index = index;\r\n\t}\r\n\r\n\t@Override\r\n\tget tokenSource(): TokenSource | undefined {\r\n\t\treturn this.source.source;\r\n\t}\r\n\r\n\t@Override\r\n\tget inputStream(): CharStream | undefined {\r\n\t\treturn this.source.stream;\r\n\t}\r\n\r\n\tpublic toString(): string;\r\n\tpublic toString<TSymbol, ATNInterpreter extends ATNSimulator>(recognizer: Recognizer<TSymbol, ATNInterpreter> | undefined): string;\r\n\r\n\t@Override\r\n\tpublic toString<TSymbol, ATNInterpreter extends ATNSimulator>(recognizer?: Recognizer<TSymbol, ATNInterpreter>): string {\r\n\t\tlet channelStr: string = \"\";\r\n\t\tif (this._channel > 0) {\r\n\t\t\tchannelStr = \",channel=\" + this._channel;\r\n\t\t}\r\n\r\n\t\tlet txt: string | undefined = this.text;\r\n\t\tif (txt != null) {\r\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\");\r\n\t\t\ttxt = txt.replace(/\\r/g, \"\\\\r\");\r\n\t\t\ttxt = txt.replace(/\\t/g, \"\\\\t\");\r\n\t\t} else {\r\n\t\t\ttxt = \"<no text>\";\r\n\t\t}\r\n\r\n\t\tlet typeString = String(this._type);\r\n\t\tif (recognizer) {\r\n\t\t\ttypeString = recognizer.vocabulary.getDisplayName(this._type);\r\n\t\t}\r\n\r\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + typeString + \">\" + channelStr + \",\" + this._line + \":\" + this.charPositionInLine + \"]\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:50.3010112-07:00\r\n\r\nimport { CharStream } from \"./CharStream\";\r\nimport { CommonToken } from \"./CommonToken\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { Override } from \"./Decorators\";\r\nimport { TokenFactory } from \"./TokenFactory\";\r\nimport { TokenSource } from \"./TokenSource\";\r\n\r\n/**\r\n * This default implementation of {@link TokenFactory} creates\r\n * {@link CommonToken} objects.\r\n */\r\nexport class CommonTokenFactory implements TokenFactory {\r\n\t/**\r\n\t * Indicates whether {@link CommonToken#setText} should be called after\r\n\t * constructing tokens to explicitly set the text. This is useful for cases\r\n\t * where the input stream might not be able to provide arbitrary substrings\r\n\t * of text from the input after the lexer creates a token (e.g. the\r\n\t * implementation of {@link CharStream#getText} in\r\n\t * {@link UnbufferedCharStream}\r\n\t * {@link UnsupportedOperationException}). Explicitly setting the token text\r\n\t * allows {@link Token#getText} to be called at any time regardless of the\r\n\t * input stream implementation.\r\n\t *\r\n\t * The default value is `false` to avoid the performance and memory\r\n\t * overhead of copying text for every token unless explicitly requested.\r\n\t */\r\n\tprotected copyText: boolean;\r\n\r\n\t/**\r\n\t * Constructs a {@link CommonTokenFactory} with the specified value for\r\n\t * {@link #copyText}.\r\n\t *\r\n\t * When `copyText` is `false`, the {@link #DEFAULT} instance\r\n\t * should be used instead of constructing a new instance.\r\n\t *\r\n\t * @param copyText The value for {@link #copyText}.\r\n\t */\r\n\tconstructor(copyText: boolean = false) {\r\n\t\tthis.copyText = copyText;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic create(\r\n\t\tsource: { source?: TokenSource, stream?: CharStream },\r\n\t\ttype: number,\r\n\t\ttext: string | undefined,\r\n\t\tchannel: number,\r\n\t\tstart: number,\r\n\t\tstop: number,\r\n\t\tline: number,\r\n\t\tcharPositionInLine: number): CommonToken {\r\n\r\n\t\tlet t: CommonToken = new CommonToken(type, text, source, channel, start, stop);\r\n\t\tt.line = line;\r\n\t\tt.charPositionInLine = charPositionInLine;\r\n\t\tif (text == null && this.copyText && source.stream != null) {\r\n\t\t\tt.text = source.stream.getText(Interval.of(start, stop));\r\n\t\t}\r\n\r\n\t\treturn t;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic createSimple(type: number, text: string): CommonToken {\r\n\t\treturn new CommonToken(type, text);\r\n\t}\r\n}\r\n\r\nexport namespace CommonTokenFactory {\r\n\t/**\r\n\t * The default {@link CommonTokenFactory} instance.\r\n\t *\r\n\t * This token factory does not explicitly copy token text when constructing\r\n\t * tokens.\r\n\t */\r\n\texport const DEFAULT: TokenFactory = new CommonTokenFactory();\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:40.6647101-07:00\r\n\r\nimport { IntegerList } from \"./IntegerList\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class IntegerStack extends IntegerList {\r\n\r\n\tconstructor(arg?: number | IntegerStack) {\r\n\t\tsuper(arg);\r\n\t}\r\n\r\n\tpublic push(value: number): void {\r\n\t\tthis.add(value);\r\n\t}\r\n\r\n\tpublic pop(): number {\r\n\t\treturn this.removeAt(this.size - 1);\r\n\t}\r\n\r\n\tpublic peek(): number {\r\n\t\treturn this.get(this.size - 1);\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:38.1172076-07:00\r\n\r\nimport { LexerActionExecutor } from \"../atn/LexerActionExecutor\";\r\n\r\n/**\r\n * Stores information about a {@link DFAState} which is an accept state under\r\n * some condition. Certain settings, such as\r\n * {@link ParserATNSimulator#getPredictionMode()}, may be used in addition to\r\n * this information to determine whether or not a particular state is an accept\r\n * state.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class AcceptStateInfo {\r\n\tprivate readonly _prediction: number;\r\n\tprivate readonly _lexerActionExecutor?: LexerActionExecutor;\r\n\r\n\tconstructor(prediction: number);\r\n\tconstructor(prediction: number, lexerActionExecutor: LexerActionExecutor | undefined);\r\n\tconstructor(prediction: number, lexerActionExecutor?: LexerActionExecutor) {\r\n\t\tthis._prediction = prediction;\r\n\t\tthis._lexerActionExecutor = lexerActionExecutor;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the prediction made by this accept state. Note that this value\r\n\t * assumes the predicates, if any, in the {@link DFAState} evaluate to\r\n\t * `true`. If predicate evaluation is enabled, the final prediction of\r\n\t * the accept state will be determined by the result of predicate\r\n\t * evaluation.\r\n\t */\r\n\tget prediction(): number {\r\n\t\treturn this._prediction;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the {@link LexerActionExecutor} which can be used to execute actions\r\n\t * and/or commands after the lexer matches a token.\r\n\t */\r\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\r\n\t\treturn this._lexerActionExecutor;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.7613038-07:00\r\n\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerActionType } from \"./LexerActionType\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * This implementation of {@link LexerAction} is used for tracking input offsets\r\n * for position-dependent actions within a {@link LexerActionExecutor}.\r\n *\r\n * This action is not serialized as part of the ATN, and is only required for\r\n * position-dependent lexer actions which appear at a location other than the\r\n * end of a rule. For more information about DFA optimizations employed for\r\n * lexer actions, see {@link LexerActionExecutor#append} and\r\n * {@link LexerActionExecutor#fixOffsetBeforeMatch}.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerIndexedCustomAction implements LexerAction {\r\n\tprivate readonly _offset: number;\r\n\tprivate readonly _action: LexerAction;\r\n\r\n\t/**\r\n\t * Constructs a new indexed custom action by associating a character offset\r\n\t * with a {@link LexerAction}.\r\n\t *\r\n\t * Note: This class is only required for lexer actions for which\r\n\t * {@link LexerAction#isPositionDependent} returns `true`.\r\n\t *\r\n\t * @param offset The offset into the input {@link CharStream}, relative to\r\n\t * the token start index, at which the specified lexer action should be\r\n\t * executed.\r\n\t * @param action The lexer action to execute at a particular offset in the\r\n\t * input {@link CharStream}.\r\n\t */\r\n\tconstructor(offset: number, @NotNull action: LexerAction) {\r\n\t\tthis._offset = offset;\r\n\t\tthis._action = action;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the location in the input {@link CharStream} at which the lexer\r\n\t * action should be executed. The value is interpreted as an offset relative\r\n\t * to the token start index.\r\n\t *\r\n\t * @returns The location in the input {@link CharStream} at which the lexer\r\n\t * action should be executed.\r\n\t */\r\n\tget offset(): number {\r\n\t\treturn this._offset;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the lexer action to execute.\r\n\t *\r\n\t * @returns A {@link LexerAction} object which executes the lexer action.\r\n\t */\r\n\t@NotNull\r\n\tget action(): LexerAction {\r\n\t\treturn this._action;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * @returns This method returns the result of calling {@link #getActionType}\r\n\t * on the {@link LexerAction} returned by {@link #getAction}.\r\n\t */\r\n\t@Override\r\n\tget actionType(): LexerActionType {\r\n\t\treturn this._action.actionType;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @returns This method returns `true`.\r\n\t */\r\n\t@Override\r\n\tget isPositionDependent(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This method calls {@link #execute} on the result of {@link #getAction}\r\n\t * using the provided `lexer`.\r\n\t */\r\n\t@Override\r\n\tpublic execute(lexer: Lexer): void {\r\n\t\t// assume the input stream position was properly set by the calling code\r\n\t\tthis._action.execute(lexer);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\thash = MurmurHash.update(hash, this._offset);\r\n\t\thash = MurmurHash.update(hash, this._action);\r\n\t\treturn MurmurHash.finish(hash, 2);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerIndexedCustomAction)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this._offset === obj._offset\r\n\t\t\t&& this._action.equals(obj._action);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:28.8810453-07:00\r\n\r\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\r\nimport { CharStream } from \"../CharStream\";\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LexerIndexedCustomAction } from \"./LexerIndexedCustomAction\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\n\r\n/**\r\n * Represents an executor for a sequence of lexer actions which traversed during\r\n * the matching operation of a lexer rule (token).\r\n *\r\n * The executor tracks position information for position-dependent lexer actions\r\n * efficiently, ensuring that actions appearing only at the end of the rule do\r\n * not cause bloating of the {@link DFA} created for the lexer.\r\n *\r\n * @author Sam Harwell\r\n * @since 4.2\r\n */\r\nexport class LexerActionExecutor {\r\n\t@NotNull\r\n\tprivate _lexerActions: LexerAction[];\r\n\r\n\t/**\r\n\t * Caches the result of {@link #hashCode} since the hash code is an element\r\n\t * of the performance-critical {@link LexerATNConfig#hashCode} operation.\r\n\t */\r\n\tprivate cachedHashCode: number;\r\n\r\n\t/**\r\n\t * Constructs an executor for a sequence of {@link LexerAction} actions.\r\n\t * @param lexerActions The lexer actions to execute.\r\n\t */\r\n\tconstructor(@NotNull lexerActions: LexerAction[]) {\r\n\t\tthis._lexerActions = lexerActions;\r\n\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\tfor (let lexerAction of lexerActions) {\r\n\t\t\thash = MurmurHash.update(hash, lexerAction);\r\n\t\t}\r\n\r\n\t\tthis.cachedHashCode = MurmurHash.finish(hash, lexerActions.length);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\r\n\t * the input `lexerActionExecutor` followed by a specified\r\n\t * `lexerAction`.\r\n\t *\r\n\t * @param lexerActionExecutor The executor for actions already traversed by\r\n\t * the lexer while matching a token within a particular\r\n\t * {@link ATNConfig}. If this is `undefined`, the method behaves as though\r\n\t * it were an empty executor.\r\n\t * @param lexerAction The lexer action to execute after the actions\r\n\t * specified in `lexerActionExecutor`.\r\n\t *\r\n\t * @returns A {@link LexerActionExecutor} for executing the combine actions\r\n\t * of `lexerActionExecutor` and `lexerAction`.\r\n\t */\r\n\t@NotNull\r\n\tpublic static append(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull lexerAction: LexerAction): LexerActionExecutor {\r\n\t\tif (!lexerActionExecutor) {\r\n\t\t\treturn new LexerActionExecutor([lexerAction]);\r\n\t\t}\r\n\r\n\t\tlet lexerActions = lexerActionExecutor._lexerActions.slice(0);\r\n\t\tlexerActions.push(lexerAction);\r\n\t\treturn new LexerActionExecutor(lexerActions);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\r\n\t * for position-dependent lexer actions.\r\n\t *\r\n\t * Normally, when the executor encounters lexer actions where\r\n\t * {@link LexerAction#isPositionDependent} returns `true`, it calls\r\n\t * {@link IntStream#seek} on the input {@link CharStream} to set the input\r\n\t * position to the *end* of the current token. This behavior provides\r\n\t * for efficient DFA representation of lexer actions which appear at the end\r\n\t * of a lexer rule, even when the lexer rule matches a variable number of\r\n\t * characters.\r\n\t *\r\n\t * Prior to traversing a match transition in the ATN, the current offset\r\n\t * from the token start index is assigned to all position-dependent lexer\r\n\t * actions which have not already been assigned a fixed offset. By storing\r\n\t * the offsets relative to the token start index, the DFA representation of\r\n\t * lexer actions which appear in the middle of tokens remains efficient due\r\n\t * to sharing among tokens of the same length, regardless of their absolute\r\n\t * position in the input stream.\r\n\t *\r\n\t * If the current executor already has offsets assigned to all\r\n\t * position-dependent lexer actions, the method returns `this`.\r\n\t *\r\n\t * @param offset The current offset to assign to all position-dependent\r\n\t * lexer actions which do not already have offsets assigned.\r\n\t *\r\n\t * @returns A {@link LexerActionExecutor} which stores input stream offsets\r\n\t * for all position-dependent lexer actions.\r\n\t */\r\n\tpublic fixOffsetBeforeMatch(offset: number): LexerActionExecutor {\r\n\t\tlet updatedLexerActions: LexerAction[] | undefined;\r\n\t\tfor (let i = 0; i < this._lexerActions.length; i++) {\r\n\t\t\tif (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction)) {\r\n\t\t\t\tif (!updatedLexerActions) {\r\n\t\t\t\t\tupdatedLexerActions = this._lexerActions.slice(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset, this._lexerActions[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!updatedLexerActions) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\treturn new LexerActionExecutor(updatedLexerActions);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the lexer actions to be executed by this executor.\r\n\t * @returns The lexer actions to be executed by this executor.\r\n\t */\r\n\t@NotNull\r\n\tget lexerActions(): LexerAction[] {\r\n\t\treturn this._lexerActions;\r\n\t}\r\n\r\n\t/**\r\n\t * Execute the actions encapsulated by this executor within the context of a\r\n\t * particular {@link Lexer}.\r\n\t *\r\n\t * This method calls {@link IntStream#seek} to set the position of the\r\n\t * `input` {@link CharStream} prior to calling\r\n\t * {@link LexerAction#execute} on a position-dependent action. Before the\r\n\t * method returns, the input position will be restored to the same position\r\n\t * it was in when the method was invoked.\r\n\t *\r\n\t * @param lexer The lexer instance.\r\n\t * @param input The input stream which is the source for the current token.\r\n\t * When this method is called, the current {@link IntStream#index} for\r\n\t * `input` should be the start of the following token, i.e. 1\r\n\t * character past the end of the current token.\r\n\t * @param startIndex The token start index. This value may be passed to\r\n\t * {@link IntStream#seek} to set the `input` position to the beginning\r\n\t * of the token.\r\n\t */\r\n\tpublic execute(@NotNull lexer: Lexer, input: CharStream, startIndex: number): void {\r\n\t\tlet requiresSeek: boolean = false;\r\n\t\tlet stopIndex: number = input.index;\r\n\t\ttry {\r\n\t\t\tfor (let lexerAction of this._lexerActions) {\r\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\r\n\t\t\t\t\tlet offset: number = lexerAction.offset;\r\n\t\t\t\t\tinput.seek(startIndex + offset);\r\n\t\t\t\t\tlexerAction = lexerAction.action;\r\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\r\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\r\n\t\t\t\t\tinput.seek(stopIndex);\r\n\t\t\t\t\trequiresSeek = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlexerAction.execute(lexer);\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tif (requiresSeek) {\r\n\t\t\t\tinput.seek(stopIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\treturn this.cachedHashCode;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(obj: any): boolean {\r\n\t\tif (obj === this) {\r\n\t\t\treturn true;\r\n\t\t} else if (!(obj instanceof LexerActionExecutor)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.cachedHashCode === obj.cachedHashCode\r\n\t\t\t&& ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:52.0961136-07:00\r\n\r\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { NotNull, Override } from \"./Decorators\";\r\nimport { Lexer } from \"./Lexer\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport * as Utils from \"./misc/Utils\";\r\n\r\nexport class LexerNoViableAltException extends RecognitionException {\r\n\t//private static serialVersionUID: number =  -730999203913001726L;\r\n\r\n\t/** Matching attempted at what input index? */\r\n\tprivate _startIndex: number;\r\n\r\n\t/** Which configurations did we try at input.index that couldn't match input.LA(1)? */\r\n\tprivate _deadEndConfigs?: ATNConfigSet;\r\n\r\n\tconstructor(\r\n\t\tlexer: Lexer | undefined,\r\n\t\t@NotNull input: CharStream,\r\n\t\tstartIndex: number,\r\n\t\tdeadEndConfigs: ATNConfigSet | undefined) {\r\n\t\tsuper(lexer, input);\r\n\t\tthis._startIndex = startIndex;\r\n\t\tthis._deadEndConfigs = deadEndConfigs;\r\n\t}\r\n\r\n\tget startIndex(): number {\r\n\t\treturn this._startIndex;\r\n\t}\r\n\r\n\tget deadEndConfigs(): ATNConfigSet | undefined {\r\n\t\treturn this._deadEndConfigs;\r\n\t}\r\n\r\n\t@Override\r\n\tget inputStream(): CharStream {\r\n\t\treturn super.inputStream as CharStream;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tlet symbol = \"\";\r\n\t\tif (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {\r\n\t\t\tsymbol = this.inputStream.getText(Interval.of(this._startIndex, this._startIndex));\r\n\t\t\tsymbol = Utils.escapeWhitespace(symbol, false);\r\n\t\t}\r\n\r\n\t\t// return String.format(Locale.getDefault(), \"%s('%s')\", LexerNoViableAltException.class.getSimpleName(), symbol);\r\n\t\treturn `LexerNoViableAltException('${symbol}')`;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.9444556-07:00\r\n\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class OrderedATNConfigSet extends ATNConfigSet {\r\n\r\n\tconstructor();\r\n\tconstructor(set: ATNConfigSet, readonly: boolean);\r\n\tconstructor(set?: ATNConfigSet, readonly?: boolean) {\r\n\t\tif (set != null && readonly != null) {\r\n\t\t\tsuper(set, readonly);\r\n\t\t} else {\r\n\t\t\tsuper();\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic clone(readonly: boolean): ATNConfigSet {\r\n\t\tlet copy: OrderedATNConfigSet = new OrderedATNConfigSet(this, readonly);\r\n\t\tif (!readonly && this.isReadOnly) {\r\n\t\t\tcopy.addAll(this);\r\n\t\t}\r\n\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected getKey(e: ATNConfig): { state: number, alt: number } {\r\n\t\t// This is a specially crafted key to ensure configurations are only merged if they are equal\r\n\t\treturn { state: 0, alt: e.hashCode() };\r\n\t}\r\n\r\n\t@Override\r\n\tprotected canMerge(left: ATNConfig, leftKey: { state: number, alt: number }, right: ATNConfig): boolean {\r\n\t\treturn left.equals(right);\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.7513856-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/** The last node in the ATN for a rule, unless that rule is the start symbol.\r\n *  In that case, there is one transition to EOF. Later, we might encode\r\n *  references to all calls to this rule to compute FOLLOW sets for\r\n *  error handling.\r\n */\r\nexport class RuleStopState extends ATNState {\r\n\r\n\t@Override\r\n\tget nonStopStateNumber(): number {\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.RULE_STOP;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:29.1083066-07:00\r\n\r\nimport { AcceptStateInfo } from \"../dfa/AcceptStateInfo\";\r\nimport { ActionTransition } from \"./ActionTransition\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNConfigSet } from \"./ATNConfigSet\";\r\nimport { ATNSimulator } from \"./ATNSimulator\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { CharStream } from \"../CharStream\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { DFAState } from \"../dfa/DFAState\";\r\nimport { Interval } from \"../misc/Interval\";\r\nimport { IntStream } from \"../IntStream\";\r\nimport { Lexer } from \"../Lexer\";\r\nimport { LexerActionExecutor } from \"./LexerActionExecutor\";\r\nimport { LexerNoViableAltException } from \"../LexerNoViableAltException\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { OrderedATNConfigSet } from \"./OrderedATNConfigSet\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { PredicateTransition } from \"./PredicateTransition\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\nimport { Token } from \"../Token\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\nimport * as assert from \"assert\";\r\n\r\n/** \"dup\" of ParserInterpreter */\r\nexport class LexerATNSimulator extends ATNSimulator {\r\n\tpublic optimize_tail_calls: boolean = true;\r\n\r\n\tprotected recog: Lexer | undefined;\r\n\r\n\t/** The current token's starting index into the character stream.\r\n\t *  Shared across DFA to ATN simulation in case the ATN fails and the\r\n\t *  DFA did not have a previous accept state. In this case, we use the\r\n\t *  ATN-generated exception object.\r\n\t */\r\n\tprotected startIndex: number = -1;\r\n\r\n\t/** line number 1..n within the input */\r\n\tprivate _line: number = 1;\r\n\r\n\t/** The index of the character relative to the beginning of the line 0..n-1 */\r\n\tprivate _charPositionInLine: number = 0;\r\n\r\n\tprotected mode: number = Lexer.DEFAULT_MODE;\r\n\r\n\t/** Used during DFA/ATN exec to record the most recent accept configuration info */\r\n\t@NotNull\r\n\tprotected prevAccept: LexerATNSimulator.SimState = new LexerATNSimulator.SimState();\r\n\r\n\tconstructor(/*@NotNull*/ atn: ATN);\r\n\tconstructor(/*@NotNull*/ atn: ATN, recog: Lexer | undefined);\r\n\tconstructor(@NotNull atn: ATN, recog?: Lexer) {\r\n\t\tsuper(atn);\r\n\t\tthis.recog = recog;\r\n\t}\r\n\r\n\tpublic copyState(@NotNull simulator: LexerATNSimulator): void {\r\n\t\tthis._charPositionInLine = simulator.charPositionInLine;\r\n\t\tthis._line = simulator._line;\r\n\t\tthis.mode = simulator.mode;\r\n\t\tthis.startIndex = simulator.startIndex;\r\n\t}\r\n\r\n\tpublic match(@NotNull input: CharStream, mode: number): number {\r\n\t\tthis.mode = mode;\r\n\t\tlet mark: number = input.mark();\r\n\t\ttry {\r\n\t\t\tthis.startIndex = input.index;\r\n\t\t\tthis.prevAccept.reset();\r\n\t\t\tlet s0: DFAState | undefined = this.atn.modeToDFA[mode].s0;\r\n\t\t\tif (s0 == null) {\r\n\t\t\t\treturn this.matchATN(input);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.execATN(input, s0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tinput.release(mark);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic reset(): void {\r\n\t\tthis.prevAccept.reset();\r\n\t\tthis.startIndex = -1;\r\n\t\tthis._line = 1;\r\n\t\tthis._charPositionInLine = 0;\r\n\t\tthis.mode = Lexer.DEFAULT_MODE;\r\n\t}\r\n\r\n\tprotected matchATN(@NotNull input: CharStream): number {\r\n\t\tlet startState: ATNState = this.atn.modeToStartState[this.mode];\r\n\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(`matchATN mode ${this.mode} start: ${startState}`);\r\n\t\t}\r\n\r\n\t\tlet old_mode: number = this.mode;\r\n\r\n\t\tlet s0_closure: ATNConfigSet = this.computeStartState(input, startState);\r\n\t\tlet suppressEdge: boolean = s0_closure.hasSemanticContext;\r\n\t\tif (suppressEdge) {\r\n\t\t\ts0_closure.hasSemanticContext = false;\r\n\t\t}\r\n\r\n\t\tlet next: DFAState = this.addDFAState(s0_closure);\r\n\t\tif (!suppressEdge) {\r\n\t\t\tlet dfa = this.atn.modeToDFA[this.mode];\r\n\t\t\tif (!dfa.s0) {\r\n\t\t\t\tdfa.s0 = next;\r\n\t\t\t} else {\r\n\t\t\t\tnext = dfa.s0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet predict: number = this.execATN(input, next);\r\n\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);\r\n\t\t}\r\n\r\n\t\treturn predict;\r\n\t}\r\n\r\n\tprotected execATN(@NotNull input: CharStream, @NotNull ds0: DFAState): number {\r\n\t\t// console.log(\"enter exec index \"+input.index+\" from \"+ds0.configs);\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(`start state closure=${ds0.configs}`);\r\n\t\t}\r\n\r\n\t\tif (ds0.isAcceptState) {\r\n\t\t\t// allow zero-length tokens\r\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\r\n\t\t}\r\n\r\n\t\tlet t: number = input.LA(1);\r\n\t\t// @NotNull\r\n\t\tlet s: DFAState = ds0; // s is current/from DFA state\r\n\r\n\t\twhile (true) { // while more work\r\n\t\t\tif (LexerATNSimulator.debug) {\r\n\t\t\t\tconsole.log(`execATN loop starting closure: ${s.configs}`);\r\n\t\t\t}\r\n\r\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\r\n\t\t\t// avoid looking up the DFA state again, which is expensive.\r\n\t\t\t// If the previous target was already part of the DFA, we might\r\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\r\n\t\t\t// it means that semantic predicates didn't prevent us from\r\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\r\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\r\n\t\t\t// it's configuration set; there's no point in re-computing it.\r\n\t\t\t// This is kind of like doing DFA simulation within the ATN\r\n\t\t\t// simulation because DFA simulation is really just a way to avoid\r\n\t\t\t// computing reach/closure sets. Technically, once we know that\r\n\t\t\t// we have a previously added DFA state, we could jump over to\r\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\r\n\t\t\t// a lot and making things more complicated algorithmically.\r\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\r\n\t\t\t// A character will take us back to an existing DFA state\r\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\r\n\t\t\tlet target: DFAState | undefined = this.getExistingTargetState(s, t);\r\n\t\t\tif (target == null) {\r\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\r\n\t\t\t}\r\n\r\n\t\t\tif (target === ATNSimulator.ERROR) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// If this is a consumable input element, make sure to consume before\r\n\t\t\t// capturing the accept state so the input index, line, and char\r\n\t\t\t// position accurately reflect the state of the interpreter at the\r\n\t\t\t// end of the token.\r\n\t\t\tif (t !== IntStream.EOF) {\r\n\t\t\t\tthis.consume(input);\r\n\t\t\t}\r\n\r\n\t\t\tif (target.isAcceptState) {\r\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\r\n\t\t\t\tif (t === IntStream.EOF) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tt = input.LA(1);\r\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\r\n\t\t}\r\n\r\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\r\n\t}\r\n\r\n\t/**\r\n\t * Get an existing target state for an edge in the DFA. If the target state\r\n\t * for the edge has not yet been computed or is otherwise not available,\r\n\t * this method returns `undefined`.\r\n\t *\r\n\t * @param s The current DFA state\r\n\t * @param t The next input symbol\r\n\t * @returns The existing target DFA state for the given input symbol\r\n\t * `t`, or `undefined` if the target state for this edge is not\r\n\t * already cached\r\n\t */\r\n\tprotected getExistingTargetState(@NotNull s: DFAState, t: number): DFAState | undefined {\r\n\t\tlet target: DFAState | undefined = s.getTarget(t);\r\n\t\tif (LexerATNSimulator.debug && target != null) {\r\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber +\r\n\t\t\t\t\" edge to \" + target.stateNumber);\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\t/**\r\n\t * Compute a target state for an edge in the DFA, and attempt to add the\r\n\t * computed state and corresponding edge to the DFA.\r\n\t *\r\n\t * @param input The input stream\r\n\t * @param s The current DFA state\r\n\t * @param t The next input symbol\r\n\t *\r\n\t * @returns The computed target DFA state for the given input symbol\r\n\t * `t`. If `t` does not lead to a valid DFA state, this method\r\n\t * returns {@link #ERROR}.\r\n\t */\r\n\t@NotNull\r\n\tprotected computeTargetState(@NotNull input: CharStream, @NotNull s: DFAState, t: number): DFAState {\r\n\t\tlet reach: ATNConfigSet = new OrderedATNConfigSet();\r\n\r\n\t\t// if we don't find an existing DFA state\r\n\t\t// Fill reach starting from closure, following t transitions\r\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\r\n\r\n\t\tif (reach.isEmpty) { // we got nowhere on t from s\r\n\t\t\tif (!reach.hasSemanticContext) {\r\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\r\n\t\t\t\t// cause a failover from DFA later.\r\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\r\n\t\t\t}\r\n\r\n\t\t\t// stop when we can't match any more char\r\n\t\t\treturn ATNSimulator.ERROR;\r\n\t\t}\r\n\r\n\t\t// Add an edge from s to target DFA found/created for reach\r\n\t\treturn this.addDFAEdge(s, t, reach);\r\n\t}\r\n\r\n\tprotected failOrAccept(\r\n\t\tprevAccept: LexerATNSimulator.SimState, input: CharStream,\r\n\t\treach: ATNConfigSet, t: number): number {\r\n\t\tif (prevAccept.dfaState != null) {\r\n\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = prevAccept.dfaState.lexerActionExecutor;\r\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\r\n\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.charPos);\r\n\t\t\treturn prevAccept.dfaState.prediction;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// if no accept and EOF is first char, return EOF\r\n\t\t\tif (t === IntStream.EOF && input.index === this.startIndex) {\r\n\t\t\t\treturn Token.EOF;\r\n\t\t\t}\r\n\r\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Given a starting configuration set, figure out all ATN configurations\r\n\t *  we can reach upon input `t`. Parameter `reach` is a return\r\n\t *  parameter.\r\n\t */\r\n\tprotected getReachableConfigSet(@NotNull input: CharStream, @NotNull closure: ATNConfigSet, @NotNull reach: ATNConfigSet, t: number): void {\r\n\t\t// this is used to skip processing for configs which have a lower priority\r\n\t\t// than a config that already reached an accept state for the same rule\r\n\t\tlet skipAlt: number = ATN.INVALID_ALT_NUMBER;\r\n\t\tfor (let c of closure) {\r\n\t\t\tlet currentAltReachedAcceptState: boolean = c.alt === skipAlt;\r\n\t\t\tif (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (LexerATNSimulator.debug) {\r\n\t\t\t\tconsole.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);\r\n\t\t\t}\r\n\r\n\t\t\tlet n: number = c.state.numberOfOptimizedTransitions;\r\n\t\t\tfor (let ti = 0; ti < n; ti++) {               // for each optimized transition\r\n\t\t\t\tlet trans: Transition = c.state.getOptimizedTransition(ti);\r\n\t\t\t\tlet target: ATNState | undefined = this.getReachableTarget(trans, t);\r\n\t\t\t\tif (target != null) {\r\n\t\t\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = c.lexerActionExecutor;\r\n\t\t\t\t\tlet config: ATNConfig;\r\n\t\t\t\t\tif (lexerActionExecutor != null) {\r\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\r\n\t\t\t\t\t\tconfig = c.transform(target, true, lexerActionExecutor);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tassert(c.lexerActionExecutor == null);\r\n\t\t\t\t\t\tconfig = c.transform(target, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet treatEofAsEpsilon: boolean = t === IntStream.EOF;\r\n\t\t\t\t\tif (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\r\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority than\r\n\t\t\t\t\t\t// the one that just reached an accept state.\r\n\t\t\t\t\t\tskipAlt = c.alt;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected accept(\r\n\t\t@NotNull input: CharStream, lexerActionExecutor: LexerActionExecutor | undefined,\r\n\t\tstartIndex: number, index: number, line: number, charPos: number): void {\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(`ACTION ${lexerActionExecutor}`);\r\n\t\t}\r\n\r\n\t\t// seek to after last char in token\r\n\t\tinput.seek(index);\r\n\t\tthis._line = line;\r\n\t\tthis._charPositionInLine = charPos;\r\n\r\n\t\tif (lexerActionExecutor != null && this.recog != null) {\r\n\t\t\tlexerActionExecutor.execute(this.recog, input, startIndex);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getReachableTarget(trans: Transition, t: number): ATNState | undefined {\r\n\t\tif (trans.matches(t, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\r\n\t\t\treturn trans.target;\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected computeStartState(\r\n\t\t@NotNull input: CharStream,\r\n\t\t@NotNull p: ATNState): ATNConfigSet {\r\n\t\tlet initialContext: PredictionContext = PredictionContext.EMPTY_FULL;\r\n\t\tlet configs: ATNConfigSet = new OrderedATNConfigSet();\r\n\t\tfor (let i = 0; i < p.numberOfTransitions; i++) {\r\n\t\t\tlet target: ATNState = p.transition(i).target;\r\n\t\t\tlet c: ATNConfig = ATNConfig.create(target, i + 1, initialContext);\r\n\t\t\tthis.closure(input, c, configs, false, false, false);\r\n\t\t}\r\n\t\treturn configs;\r\n\t}\r\n\r\n\t/**\r\n\t * Since the alternatives within any lexer decision are ordered by\r\n\t * preference, this method stops pursuing the closure as soon as an accept\r\n\t * state is reached. After the first accept state is reached by depth-first\r\n\t * search from `config`, all other (potentially reachable) states for\r\n\t * this rule would have a lower priority.\r\n\t *\r\n\t * @returns `true` if an accept state is reached, otherwise\r\n\t * `false`.\r\n\t */\r\n\tprotected closure(@NotNull input: CharStream, @NotNull config: ATNConfig, @NotNull configs: ATNConfigSet, currentAltReachedAcceptState: boolean, speculative: boolean, treatEofAsEpsilon: boolean): boolean {\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\r\n\t\t}\r\n\r\n\t\tif (config.state instanceof RuleStopState) {\r\n\t\t\tif (LexerATNSimulator.debug) {\r\n\t\t\t\tif (this.recog != null) {\r\n\t\t\t\t\tconsole.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(`closure at rule stop ${config}`);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet context: PredictionContext = config.context;\r\n\t\t\tif (context.isEmpty) {\r\n\t\t\t\tconfigs.add(config);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\telse if (context.hasEmpty) {\r\n\t\t\t\tconfigs.add(config.transform(config.state, true, PredictionContext.EMPTY_FULL));\r\n\t\t\t\tcurrentAltReachedAcceptState = true;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < context.size; i++) {\r\n\t\t\t\tlet returnStateNumber: number = context.getReturnState(i);\r\n\t\t\t\tif (returnStateNumber === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet newContext: PredictionContext = context.getParent(i); // \"pop\" return state\r\n\t\t\t\tlet returnState: ATNState = this.atn.states[returnStateNumber];\r\n\t\t\t\tlet c: ATNConfig = config.transform(returnState, false, newContext);\r\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\r\n\t\t\t}\r\n\r\n\t\t\treturn currentAltReachedAcceptState;\r\n\t\t}\r\n\r\n\t\t// optimization\r\n\t\tif (!config.state.onlyHasEpsilonTransitions) {\r\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {\r\n\t\t\t\tconfigs.add(config);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet p: ATNState = config.state;\r\n\t\tfor (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\r\n\t\t\tlet t: Transition = p.getOptimizedTransition(i);\r\n\t\t\tlet c: ATNConfig | undefined = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);\r\n\t\t\tif (c != null) {\r\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn currentAltReachedAcceptState;\r\n\t}\r\n\r\n\t// side-effect: can alter configs.hasSemanticContext\r\n\tprotected getEpsilonTarget(\r\n\t\t@NotNull input: CharStream,\r\n\t\t@NotNull config: ATNConfig,\r\n\t\t@NotNull t: Transition,\r\n\t\t@NotNull configs: ATNConfigSet,\r\n\t\tspeculative: boolean,\r\n\t\ttreatEofAsEpsilon: boolean): ATNConfig | undefined {\r\n\t\tlet c: ATNConfig | undefined;\r\n\r\n\t\tswitch (t.serializationType) {\r\n\t\tcase TransitionType.RULE:\r\n\t\t\tlet ruleTransition: RuleTransition = t as RuleTransition;\r\n\t\t\tif (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {\r\n\t\t\t\tc = config.transform(t.target, true);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet newContext: PredictionContext = config.context.getChild(ruleTransition.followState.stateNumber);\r\n\t\t\t\tc = config.transform(t.target, true, newContext);\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.PRECEDENCE:\r\n\t\t\tthrow new Error(\"Precedence predicates are not supported in lexers.\");\r\n\r\n\t\tcase TransitionType.PREDICATE:\r\n\t\t\t/*  Track traversing semantic predicates. If we traverse,\r\n\t\t\t\twe cannot add a DFA state for this \"reach\" computation\r\n\t\t\t\tbecause the DFA would not test the predicate again in the\r\n\t\t\t\tfuture. Rather than creating collections of semantic predicates\r\n\t\t\t\tlike v3 and testing them on prediction, v4 will test them on the\r\n\t\t\t\tfly all the time using the ATN not the DFA. This is slower but\r\n\t\t\t\tsemantically it's not used that often. One of the key elements to\r\n\t\t\t\tthis predicate mechanism is not adding DFA states that see\r\n\t\t\t\tpredicates immediately afterwards in the ATN. For example,\r\n\r\n\t\t\t\ta : ID {p1}? | ID {p2}? ;\r\n\r\n\t\t\t\tshould create the start state for rule 'a' (to save start state\r\n\t\t\t\tcompetition), but should not create target of ID state. The\r\n\t\t\t\tcollection of ATN states the following ID references includes\r\n\t\t\t\tstates reached by traversing predicates. Since this is when we\r\n\t\t\t\ttest them, we cannot cash the DFA state target of ID.\r\n\t\t\t*/\r\n\t\t\tlet pt: PredicateTransition = t as PredicateTransition;\r\n\t\t\tif (LexerATNSimulator.debug) {\r\n\t\t\t\tconsole.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\r\n\t\t\t}\r\n\t\t\tconfigs.hasSemanticContext = true;\r\n\t\t\tif (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {\r\n\t\t\t\tc = config.transform(t.target, true);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tc = undefined;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.ACTION:\r\n\t\t\tif (config.context.hasEmpty) {\r\n\t\t\t\t// execute actions anywhere in the start rule for a token.\r\n\t\t\t\t//\r\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\r\n\t\t\t\t// actions may be executed during the recursive call. The\r\n\t\t\t\t// problem can appear when hasEmpty is true but\r\n\t\t\t\t// isEmpty is false. In this case, the config needs to be\r\n\t\t\t\t// split into two contexts - one with just the empty path\r\n\t\t\t\t// and another with everything but the empty path.\r\n\t\t\t\t// Unfortunately, the current algorithm does not allow\r\n\t\t\t\t// getEpsilonTarget to return two configurations, so\r\n\t\t\t\t// additional modifications are needed before we can support\r\n\t\t\t\t// the split operation.\r\n\t\t\t\tlet lexerActionExecutor: LexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[(t as ActionTransition).actionIndex]);\r\n\t\t\t\tc = config.transform(t.target, true, lexerActionExecutor);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// ignore actions in referenced rules\r\n\t\t\t\tc = config.transform(t.target, true);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\tcase TransitionType.EPSILON:\r\n\t\t\tc = config.transform(t.target, true);\r\n\t\t\tbreak;\r\n\r\n\t\tcase TransitionType.ATOM:\r\n\t\tcase TransitionType.RANGE:\r\n\t\tcase TransitionType.SET:\r\n\t\t\tif (treatEofAsEpsilon) {\r\n\t\t\t\tif (t.matches(IntStream.EOF, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\r\n\t\t\t\t\tc = config.transform(t.target, false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tc = undefined;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tc = undefined;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * Evaluate a predicate specified in the lexer.\r\n\t *\r\n\t * If `speculative` is `true`, this method was called before\r\n\t * {@link #consume} for the matched character. This method should call\r\n\t * {@link #consume} before evaluating the predicate to ensure position\r\n\t * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},\r\n\t * and {@link Lexer#getCharPositionInLine}, properly reflect the current\r\n\t * lexer state. This method should restore `input` and the simulator\r\n\t * to the original state before returning (i.e. undo the actions made by the\r\n\t * call to {@link #consume}.\r\n\t *\r\n\t * @param input The input stream.\r\n\t * @param ruleIndex The rule containing the predicate.\r\n\t * @param predIndex The index of the predicate within the rule.\r\n\t * @param speculative `true` if the current index in `input` is\r\n\t * one character before the predicate's location.\r\n\t *\r\n\t * @returns `true` if the specified predicate evaluates to\r\n\t * `true`.\r\n\t */\r\n\tprotected evaluatePredicate(@NotNull input: CharStream, ruleIndex: number, predIndex: number, speculative: boolean): boolean {\r\n\t\t// assume true if no recognizer was provided\r\n\t\tif (this.recog == null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (!speculative) {\r\n\t\t\treturn this.recog.sempred(undefined, ruleIndex, predIndex);\r\n\t\t}\r\n\r\n\t\tlet savedCharPositionInLine: number = this._charPositionInLine;\r\n\t\tlet savedLine: number = this._line;\r\n\t\tlet index: number = input.index;\r\n\t\tlet marker: number = input.mark();\r\n\t\ttry {\r\n\t\t\tthis.consume(input);\r\n\t\t\treturn this.recog.sempred(undefined, ruleIndex, predIndex);\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\tthis._charPositionInLine = savedCharPositionInLine;\r\n\t\t\tthis._line = savedLine;\r\n\t\t\tinput.seek(index);\r\n\t\t\tinput.release(marker);\r\n\t\t}\r\n\t}\r\n\r\n\tprotected captureSimState(\r\n\t\t@NotNull settings: LexerATNSimulator.SimState,\r\n\t\t@NotNull input: CharStream,\r\n\t\t@NotNull dfaState: DFAState): void {\r\n\t\tsettings.index = input.index;\r\n\t\tsettings.line = this._line;\r\n\t\tsettings.charPos = this._charPositionInLine;\r\n\t\tsettings.dfaState = dfaState;\r\n\t}\r\n\r\n\t// @NotNull\r\n\tprotected addDFAEdge(/*@NotNull*/ p: DFAState, t: number, /*@NotNull*/ q: ATNConfigSet): DFAState;\r\n\tprotected addDFAEdge(/*@NotNull*/ p: DFAState, t: number, /*@NotNull*/ q: DFAState): void;\r\n\tprotected addDFAEdge(p: DFAState, t: number, q: ATNConfigSet | DFAState): DFAState | void {\r\n\t\tif (q instanceof ATNConfigSet) {\r\n\t\t\t/* leading to this call, ATNConfigSet.hasSemanticContext is used as a\r\n\t\t\t* marker indicating dynamic predicate evaluation makes this edge\r\n\t\t\t* dependent on the specific input sequence, so the static edge in the\r\n\t\t\t* DFA should be omitted. The target DFAState is still created since\r\n\t\t\t* execATN has the ability to resynchronize with the DFA state cache\r\n\t\t\t* following the predicate evaluation step.\r\n\t\t\t*\r\n\t\t\t* TJP notes: next time through the DFA, we see a pred again and eval.\r\n\t\t\t* If that gets us to a previously created (but dangling) DFA\r\n\t\t\t* state, we can continue in pure DFA mode from there.\r\n\t\t\t*/\r\n\t\t\tlet suppressEdge: boolean = q.hasSemanticContext;\r\n\t\t\tif (suppressEdge) {\r\n\t\t\t\tq.hasSemanticContext = false;\r\n\t\t\t}\r\n\r\n\t\t\t// @NotNull\r\n\t\t\tlet to: DFAState = this.addDFAState(q);\r\n\r\n\t\t\tif (suppressEdge) {\r\n\t\t\t\treturn to;\r\n\t\t\t}\r\n\r\n\t\t\tthis.addDFAEdge(p, t, to);\r\n\t\t\treturn to;\r\n\t\t} else {\r\n\t\t\tif (LexerATNSimulator.debug) {\r\n\t\t\t\tconsole.log(\"EDGE \" + p + \" -> \" + q + \" upon \" + String.fromCharCode(t));\r\n\t\t\t}\r\n\r\n\t\t\tif (p != null) {\r\n\t\t\t\tp.setTarget(t, q);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** Add a new DFA state if there isn't one with this set of\r\n\t * \tconfigurations already. This method also detects the first\r\n\t * \tconfiguration containing an ATN rule stop state. Later, when\r\n\t * \ttraversing the DFA, we will know which rule to accept.\r\n\t */\r\n\t@NotNull\r\n\tprotected addDFAState(@NotNull configs: ATNConfigSet): DFAState {\r\n\t\t/* the lexer evaluates predicates on-the-fly; by this point configs\r\n\t\t * should not contain any configurations with unevaluated predicates.\r\n\t\t */\r\n\t\tassert(!configs.hasSemanticContext);\r\n\r\n\t\tlet proposed: DFAState = new DFAState(configs);\r\n\t\tlet existing: DFAState | undefined = this.atn.modeToDFA[this.mode].states.get(proposed);\r\n\t\tif (existing != null) {\r\n\t\t\treturn existing;\r\n\t\t}\r\n\r\n\t\tconfigs.optimizeConfigs(this);\r\n\t\tlet newState: DFAState = new DFAState(configs.clone(true));\r\n\r\n\t\tlet firstConfigWithRuleStopState: ATNConfig | undefined;\r\n\t\tfor (let c of configs) {\r\n\t\t\tif (c.state instanceof RuleStopState) {\r\n\t\t\t\tfirstConfigWithRuleStopState = c;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (firstConfigWithRuleStopState != null) {\r\n\t\t\tlet prediction: number = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\r\n\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = firstConfigWithRuleStopState.lexerActionExecutor;\r\n\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(prediction, lexerActionExecutor);\r\n\t\t}\r\n\r\n\t\treturn this.atn.modeToDFA[this.mode].addState(newState);\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getDFA(mode: number): DFA {\r\n\t\treturn this.atn.modeToDFA[mode];\r\n\t}\r\n\r\n\t/** Get the text matched so far for the current token.\r\n\t */\r\n\t@NotNull\r\n\tpublic getText(@NotNull input: CharStream): string {\r\n\t\t// index is first lookahead char, don't include.\r\n\t\treturn input.getText(Interval.of(this.startIndex, input.index - 1));\r\n\t}\r\n\r\n\tget line(): number {\r\n\t\treturn this._line;\r\n\t}\r\n\r\n\tset line(line: number) {\r\n\t\tthis._line = line;\r\n\t}\r\n\r\n\tget charPositionInLine(): number {\r\n\t\treturn this._charPositionInLine;\r\n\t}\r\n\r\n\tset charPositionInLine(charPositionInLine: number) {\r\n\t\tthis._charPositionInLine = charPositionInLine;\r\n\t}\r\n\r\n\tpublic consume(@NotNull input: CharStream): void {\r\n\t\tlet curChar: number = input.LA(1);\r\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\r\n\t\t\tthis._line++;\r\n\t\t\tthis._charPositionInLine = 0;\r\n\t\t} else {\r\n\t\t\tthis._charPositionInLine++;\r\n\t\t}\r\n\t\tinput.consume();\r\n\t}\r\n\r\n\t@NotNull\r\n\tpublic getTokenName(t: number): string {\r\n\t\tif (t === -1) {\r\n\t\t\treturn \"EOF\";\r\n\t\t}\r\n\t\t//if ( atn.g!=null ) return atn.g.getTokenDisplayName(t);\r\n\t\treturn \"'\" + String.fromCharCode(t) + \"'\";\r\n\t}\r\n}\r\n\r\nexport namespace LexerATNSimulator {\r\n\texport const debug: boolean = false;\r\n\texport const dfa_debug: boolean = false;\r\n\r\n\t/** When we hit an accept state in either the DFA or the ATN, we\r\n\t *  have to notify the character stream to start buffering characters\r\n\t *  via {@link IntStream#mark} and record the current state. The current sim state\r\n\t *  includes the current index into the input, the current line,\r\n\t *  and current character position in that line. Note that the Lexer is\r\n\t *  tracking the starting line and characterization of the token. These\r\n\t *  variables track the \"state\" of the simulator when it hits an accept state.\r\n\t *\r\n\t *  We track these variables separately for the DFA and ATN simulation\r\n\t *  because the DFA simulation often has to fail over to the ATN\r\n\t *  simulation. If the ATN simulation fails, we need the DFA to fall\r\n\t *  back to its previously accepted state, if any. If the ATN succeeds,\r\n\t *  then the ATN does the accept and the DFA simulator that invoked it\r\n\t *  can simply return the predicted token type.\r\n\t */\r\n\texport class SimState {\r\n\t\tpublic index: number = -1;\r\n\t\tpublic line: number = 0;\r\n\t\tpublic charPos: number = -1;\r\n\t\tpublic dfaState?: DFAState;\r\n\r\n\t\tpublic reset(): void {\r\n\t\t\tthis.index = -1;\r\n\t\t\tthis.line = 0;\r\n\t\t\tthis.charPos = -1;\r\n\t\t\tthis.dfaState = undefined;\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:51.7913318-07:00\r\n\r\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\r\nimport { CharStream } from \"./CharStream\";\r\nimport { CommonTokenFactory } from \"./CommonTokenFactory\";\r\nimport { IntegerStack } from \"./misc/IntegerStack\";\r\nimport { Interval } from \"./misc/Interval\";\r\nimport { IntStream } from \"./IntStream\";\r\nimport { LexerATNSimulator } from \"./atn/LexerATNSimulator\";\r\nimport { LexerNoViableAltException } from \"./LexerNoViableAltException\";\r\nimport { Override } from \"./Decorators\";\r\nimport { RecognitionException } from \"./RecognitionException\";\r\nimport { Recognizer } from \"./Recognizer\";\r\nimport { Token } from \"./Token\";\r\nimport { TokenFactory } from \"./TokenFactory\";\r\nimport { TokenSource } from \"./TokenSource\";\r\n\r\n/** A lexer is recognizer that draws input symbols from a character stream.\r\n *  lexer grammars result in a subclass of this object. A Lexer object\r\n *  uses simplified match() and error recovery mechanisms in the interest\r\n *  of speed.\r\n */\r\nexport abstract class Lexer extends Recognizer<number, LexerATNSimulator>\r\n\timplements TokenSource {\r\n\tpublic static readonly DEFAULT_MODE: number = 0;\r\n\tpublic static readonly MORE: number = -2;\r\n\tpublic static readonly SKIP: number = -3;\r\n\r\n\tstatic get DEFAULT_TOKEN_CHANNEL(): number {\r\n\t\treturn Token.DEFAULT_CHANNEL;\r\n\t}\r\n\r\n\tstatic get HIDDEN(): number {\r\n\t\treturn Token.HIDDEN_CHANNEL;\r\n\t}\r\n\r\n\tpublic static readonly MIN_CHAR_VALUE: number = 0x0000;\r\n\tpublic static readonly MAX_CHAR_VALUE: number = 0x10FFFF;\r\n\r\n\tpublic _input: CharStream;\r\n\r\n\tprotected _tokenFactorySourcePair: { source: TokenSource, stream: CharStream };\r\n\r\n\t/** How to create token objects */\r\n\tprotected _factory: TokenFactory = CommonTokenFactory.DEFAULT;\r\n\r\n\t/** The goal of all lexer rules/methods is to create a token object.\r\n\t *  This is an instance variable as multiple rules may collaborate to\r\n\t *  create a single token.  nextToken will return this object after\r\n\t *  matching lexer rule(s).  If you subclass to allow multiple token\r\n\t *  emissions, then set this to the last token to be matched or\r\n\t *  something non-undefined so that the auto token emit mechanism will not\r\n\t *  emit another token.\r\n\t */\r\n\tpublic _token: Token | undefined;\r\n\r\n\t/** What character index in the stream did the current token start at?\r\n\t *  Needed, for example, to get the text for current token.  Set at\r\n\t *  the start of nextToken.\r\n\t */\r\n\tpublic _tokenStartCharIndex: number = -1;\r\n\r\n\t/** The line on which the first character of the token resides */\r\n\tpublic _tokenStartLine: number = 0;\r\n\r\n\t/** The character position of first character within the line */\r\n\tpublic _tokenStartCharPositionInLine: number = 0;\r\n\r\n\t/** Once we see EOF on char stream, next token will be EOF.\r\n\t *  If you have DONE : EOF ; then you see DONE EOF.\r\n\t */\r\n\tpublic _hitEOF: boolean = false;\r\n\r\n\t/** The channel number for the current token */\r\n\tpublic _channel: number = 0;\r\n\r\n\t/** The token type for the current token */\r\n\tpublic _type: number = 0;\r\n\r\n\tpublic readonly _modeStack: IntegerStack = new IntegerStack();\r\n\tpublic _mode: number = Lexer.DEFAULT_MODE;\r\n\r\n\t/** You can set the text for the current token to override what is in\r\n\t *  the input char buffer.  Set `text` or can set this instance var.\r\n\t */\r\n\tpublic _text: string | undefined;\r\n\r\n\tconstructor(input: CharStream) {\r\n\t\tsuper();\r\n\t\tthis._input = input;\r\n\t\tthis._tokenFactorySourcePair = { source: this, stream: input };\r\n\t}\r\n\r\n\tpublic reset(): void;\r\n\tpublic reset(resetInput: boolean): void;\r\n\tpublic reset(resetInput?: boolean): void {\r\n\t\t// wack Lexer state variables\r\n\t\tif (resetInput === undefined || resetInput) {\r\n\t\t\tthis._input.seek(0); // rewind the input\r\n\t\t}\r\n\r\n\t\tthis._token = undefined;\r\n\t\tthis._type = Token.INVALID_TYPE;\r\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\r\n\t\tthis._tokenStartCharIndex = -1;\r\n\t\tthis._tokenStartCharPositionInLine = -1;\r\n\t\tthis._tokenStartLine = -1;\r\n\t\tthis._text = undefined;\r\n\r\n\t\tthis._hitEOF = false;\r\n\t\tthis._mode = Lexer.DEFAULT_MODE;\r\n\t\tthis._modeStack.clear();\r\n\r\n\t\tthis.interpreter.reset();\r\n\t}\r\n\r\n\t/** Return a token from this source; i.e., match a token on the char\r\n\t *  stream.\r\n\t */\r\n\t@Override\r\n\tpublic nextToken(): Token {\r\n\t\tif (this._input == null) {\r\n\t\t\tthrow new Error(\"nextToken requires a non-null input stream.\");\r\n\t\t}\r\n\r\n\t\t// Mark start location in char stream so unbuffered streams are\r\n\t\t// guaranteed at least have text of current token\r\n\t\tlet tokenStartMarker: number = this._input.mark();\r\n\t\ttry {\r\n\t\t\touter:\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (this._hitEOF) {\r\n\t\t\t\t\treturn this.emitEOF();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._token = undefined;\r\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\r\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\r\n\t\t\t\tthis._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;\r\n\t\t\t\tthis._tokenStartLine = this.interpreter.line;\r\n\t\t\t\tthis._text = undefined;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\r\n//\t\t\t\tSystem.out.println(\"nextToken line \"+tokenStartLine+\" at \"+((char)input.LA(1))+\r\n//\t\t\t\t\t\t\t\t   \" in mode \"+mode+\r\n//\t\t\t\t\t\t\t\t   \" at index \"+input.index);\r\n\t\t\t\t\tlet ttype: number;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tttype = this.interpreter.match(this._input, this._mode);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\tif (e instanceof LexerNoViableAltException) {\r\n\t\t\t\t\t\t\tthis.notifyListeners(e);\t\t// report error\r\n\t\t\t\t\t\t\tthis.recover(e);\r\n\t\t\t\t\t\t\tttype = Lexer.SKIP;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this._input.LA(1) === IntStream.EOF) {\r\n\t\t\t\t\t\tthis._hitEOF = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\r\n\t\t\t\t\t\tthis._type = ttype;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (this._type === Lexer.MORE);\r\n\t\t\t\tif (this._token == null) {\r\n\t\t\t\t\treturn this.emit();\r\n\t\t\t\t}\r\n\t\t\t\treturn this._token;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\t// make sure we release marker after match or\r\n\t\t\t// unbuffered char stream will keep buffering\r\n\t\t\tthis._input.release(tokenStartMarker);\r\n\t\t}\r\n\t}\r\n\r\n\t/** Instruct the lexer to skip creating a token for current lexer rule\r\n\t *  and look for another token.  nextToken() knows to keep looking when\r\n\t *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that\r\n\t *  if token==undefined at end of any token rule, it creates one for you\r\n\t *  and emits it.\r\n\t */\r\n\tpublic skip(): void {\r\n\t\tthis._type = Lexer.SKIP;\r\n\t}\r\n\r\n\tpublic more(): void {\r\n\t\tthis._type = Lexer.MORE;\r\n\t}\r\n\r\n\tpublic mode(m: number): void {\r\n\t\tthis._mode = m;\r\n\t}\r\n\r\n\tpublic pushMode(m: number): void {\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(\"pushMode \" + m);\r\n\t\t}\r\n\t\tthis._modeStack.push(this._mode);\r\n\t\tthis.mode(m);\r\n\t}\r\n\r\n\tpublic popMode(): number {\r\n\t\tif (this._modeStack.isEmpty) {\r\n\t\t\tthrow new Error(\"EmptyStackException\");\r\n\t\t}\r\n\t\tif (LexerATNSimulator.debug) {\r\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.peek());\r\n\t\t}\r\n\t\tthis.mode(this._modeStack.pop());\r\n\t\treturn this._mode;\r\n\t}\r\n\r\n\t@Override\r\n\tget tokenFactory(): TokenFactory {\r\n\t\treturn this._factory;\r\n\t}\r\n\r\n\t// @Override\r\n\tset tokenFactory(factory: TokenFactory) {\r\n\t\tthis._factory = factory;\r\n\t}\r\n\r\n\t@Override\r\n\tget inputStream(): CharStream {\r\n\t\treturn this._input;\r\n\t}\r\n\r\n\t/** Set the char stream and reset the lexer */\r\n\tset inputStream(input: CharStream) {\r\n\t\tthis.reset(false);\r\n\t\tthis._input = input;\r\n\t\tthis._tokenFactorySourcePair = { source: this, stream: this._input };\r\n\t}\r\n\r\n\t@Override\r\n\tget sourceName(): string {\r\n\t\treturn this._input.sourceName;\r\n\t}\r\n\r\n\r\n\t/** The standard method called to automatically emit a token at the\r\n\t *  outermost lexical rule.  The token object should point into the\r\n\t *  char buffer start..stop.  If there is a text override in 'text',\r\n\t *  use that to set the token's text.  Override this method to emit\r\n\t *  custom Token objects or provide a new factory.\r\n\t */\r\n\tpublic emit(token: Token): Token;\r\n\r\n\t/** By default does not support multiple emits per nextToken invocation\r\n\t *  for efficiency reasons.  Subclass and override this method, nextToken,\r\n\t *  and getToken (to push tokens into a list and pull from that list\r\n\t *  rather than a single variable as this implementation does).\r\n\t */\r\n\tpublic emit(): Token;\r\n\r\n\tpublic emit(token?: Token): Token {\r\n\t\tif (!token) {\r\n\t\t\ttoken = this._factory.create(\r\n\t\t\t\tthis._tokenFactorySourcePair, this._type, this._text, this._channel,\r\n\t\t\t\tthis._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine,\r\n\t\t\t\tthis._tokenStartCharPositionInLine);\r\n\t\t}\r\n\t\tthis._token = token;\r\n\t\treturn token;\r\n\t}\r\n\r\n\tpublic emitEOF(): Token {\r\n\t\tlet cpos: number = this.charPositionInLine;\r\n\t\tlet line: number = this.line;\r\n\t\tlet eof: Token = this._factory.create(\r\n\t\t\tthis._tokenFactorySourcePair, Token.EOF, undefined,\r\n\t\t\tToken.DEFAULT_CHANNEL, this._input.index, this._input.index - 1,\r\n\t\t\tline, cpos);\r\n\t\tthis.emit(eof);\r\n\t\treturn eof;\r\n\t}\r\n\r\n\t@Override\r\n\tget line(): number {\r\n\t\treturn this.interpreter.line;\r\n\t}\r\n\r\n\tset line(line: number) {\r\n\t\tthis.interpreter.line = line;\r\n\t}\r\n\r\n\t@Override\r\n\tget charPositionInLine(): number {\r\n\t\treturn this.interpreter.charPositionInLine;\r\n\t}\r\n\r\n\tset charPositionInLine(charPositionInLine: number) {\r\n\t\tthis.interpreter.charPositionInLine = charPositionInLine;\r\n\t}\r\n\r\n\t/** What is the index of the current character of lookahead? */\r\n\tget charIndex(): number {\r\n\t\treturn this._input.index;\r\n\t}\r\n\r\n\t/** Return the text matched so far for the current token or any\r\n\t *  text override.\r\n\t */\r\n\tget text(): string {\r\n\t\tif (this._text != null) {\r\n\t\t\treturn this._text;\r\n\t\t}\r\n\t\treturn this.interpreter.getText(this._input);\r\n\t}\r\n\r\n\t/** Set the complete text of this token; it wipes any previous\r\n\t *  changes to the text.\r\n\t */\r\n\tset text(text: string) {\r\n\t\tthis._text = text;\r\n\t}\r\n\r\n\t/** Override if emitting multiple tokens. */\r\n\tget token(): Token | undefined { return this._token; }\r\n\r\n\tset token(_token: Token | undefined) {\r\n\t\tthis._token = _token;\r\n\t}\r\n\r\n\tset type(ttype: number) {\r\n\t\tthis._type = ttype;\r\n\t}\r\n\r\n\tget type(): number {\r\n\t\treturn this._type;\r\n\t}\r\n\r\n\tset channel(channel: number) {\r\n\t\tthis._channel = channel;\r\n\t}\r\n\r\n\tget channel(): number {\r\n\t\treturn this._channel;\r\n\t}\r\n\r\n\tpublic abstract readonly channelNames: string[];\r\n\r\n\tpublic abstract readonly modeNames: string[];\r\n\r\n\t/** Return a list of all Token objects in input char stream.\r\n\t *  Forces load of all tokens. Does not include EOF token.\r\n\t */\r\n\tpublic getAllTokens(): Token[] {\r\n\t\tlet tokens: Token[] = [];\r\n\t\tlet t: Token = this.nextToken();\r\n\t\twhile (t.type !== Token.EOF) {\r\n\t\t\ttokens.push(t);\r\n\t\t\tt = this.nextToken();\r\n\t\t}\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tpublic notifyListeners(e: LexerNoViableAltException): void {\r\n\t\tlet text: string = this._input.getText(\r\n\t\t\tInterval.of(this._tokenStartCharIndex, this._input.index));\r\n\t\tlet msg: string = \"token recognition error at: '\" +\r\n\t\t\tthis.getErrorDisplay(text) + \"'\";\r\n\r\n\t\tlet listener: ANTLRErrorListener<number> = this.getErrorListenerDispatch();\r\n\t\tif (listener.syntaxError) {\r\n\t\t\tlistener.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getErrorDisplay(s: string | number): string {\r\n\t\tif (typeof s === \"number\") {\r\n\t\t\tswitch (s) {\r\n\t\t\tcase Token.EOF:\r\n\t\t\t\treturn \"<EOF>\";\r\n\t\t\tcase 0x0a:\r\n\t\t\t\treturn \"\\\\n\";\r\n\t\t\tcase 0x09:\r\n\t\t\t\treturn \"\\\\t\";\r\n\t\t\tcase 0x0d:\r\n\t\t\t\treturn \"\\\\r\";\r\n\t\t\t}\r\n\t\t\treturn String.fromCharCode(s);\r\n\t\t}\r\n\t\treturn s.replace(/\\n/g, \"\\\\n\")\r\n\t\t\t.replace(/\\t/g, \"\\\\t\")\r\n\t\t\t.replace(/\\r/g, \"\\\\r\");\r\n\t}\r\n\r\n\tpublic getCharErrorDisplay(c: number): string {\r\n\t\tlet s: string = this.getErrorDisplay(c);\r\n\t\treturn \"'\" + s + \"'\";\r\n\t}\r\n\r\n\t/** Lexers can normally match any char in it's vocabulary after matching\r\n\t *  a token, so do the easy thing and just kill a character and hope\r\n\t *  it all works out.  You can instead use the rule invocation stack\r\n\t *  to do sophisticated error recovery if you are in a fragment rule.\r\n\t */\r\n\tpublic recover(re: RecognitionException): void;\r\n\tpublic recover(re: LexerNoViableAltException): void;\r\n\tpublic recover(re: RecognitionException): void {\r\n\t\tif (re instanceof LexerNoViableAltException) {\r\n\t\t\tif (this._input.LA(1) !== IntStream.EOF) {\r\n\t\t\t\t// skip a char and try again\r\n\t\t\t\tthis.interpreter.consume(this._input);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//System.out.println(\"consuming char \"+(char)input.LA(1)+\" during recovery\");\r\n\t\t\t//re.printStackTrace();\r\n\t\t\t// TODO: Do we lose character or line position information?\r\n\t\t\tthis._input.consume();\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:40.8683480-07:00\r\n\r\nimport { ArrayEqualityComparator } from \"./ArrayEqualityComparator\";\r\nimport { IntegerList } from \"./IntegerList\";\r\nimport { Interval } from \"./Interval\";\r\nimport { IntSet } from \"./IntSet\";\r\nimport { Lexer } from \"../Lexer\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Token } from \"../Token\";\r\nimport { Vocabulary } from \"../Vocabulary\";\r\n\r\n/**\r\n * This class implements the {@link IntSet} backed by a sorted array of\r\n * non-overlapping intervals. It is particularly efficient for representing\r\n * large collections of numbers, where the majority of elements appear as part\r\n * of a sequential range of numbers that are all part of the set. For example,\r\n * the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.\r\n *\r\n * This class is able to represent sets containing any combination of values in\r\n * the range {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}\r\n * (inclusive).\r\n */\r\nexport class IntervalSet implements IntSet {\r\n\tprivate static _COMPLETE_CHAR_SET: IntervalSet;\r\n\tstatic get COMPLETE_CHAR_SET(): IntervalSet {\r\n\t\tif (IntervalSet._COMPLETE_CHAR_SET === undefined) {\r\n\t\t\tIntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE);\r\n\t\t\tIntervalSet._COMPLETE_CHAR_SET.setReadonly(true);\r\n\t\t}\r\n\r\n\t\treturn IntervalSet._COMPLETE_CHAR_SET;\r\n\t}\r\n\r\n\tprivate static _EMPTY_SET: IntervalSet;\r\n\tstatic get EMPTY_SET(): IntervalSet {\r\n\t\tif (IntervalSet._EMPTY_SET == null) {\r\n\t\t\tIntervalSet._EMPTY_SET = new IntervalSet();\r\n\t\t\tIntervalSet._EMPTY_SET.setReadonly(true);\r\n\t\t}\r\n\r\n\t\treturn IntervalSet._EMPTY_SET;\r\n\t}\r\n\r\n\t/** The list of sorted, disjoint intervals. */\r\n\tprivate _intervals: Interval[];\r\n\r\n\tprivate readonly: boolean = false;\r\n\r\n\tconstructor(intervals?: Interval[]) {\r\n\t\tif (intervals != null) {\r\n\t\t\tthis._intervals = intervals.slice(0);\r\n\t\t} else {\r\n\t\t\tthis._intervals = [];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element\r\n\t * a.\r\n\t */\r\n\t@NotNull\r\n\tpublic static of(a: number, b: number = a): IntervalSet {\r\n\t\tlet s: IntervalSet = new IntervalSet();\r\n\t\ts.add(a, b);\r\n\t\treturn s;\r\n\t}\r\n\r\n\tpublic clear(): void {\r\n\t\tif (this.readonly) {\r\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\r\n\t\t}\r\n\r\n\t\tthis._intervals.length = 0;\r\n\t}\r\n\r\n\t/** Add interval; i.e., add all integers from a to b to set.\r\n\t *  If b&lt;a, do nothing.\r\n\t *  Keep list in sorted order (by left range value).\r\n\t *  If overlap, combine ranges.  For example,\r\n\t *  If this is {1..5, 10..20}, adding 6..7 yields\r\n\t *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.\r\n\t */\r\n\tpublic add(a: number, b: number = a): void {\r\n\t\tthis.addRange(Interval.of(a, b));\r\n\t}\r\n\r\n\t// copy on write so we can cache a..a intervals and sets of that\r\n\tprotected addRange(addition: Interval): void {\r\n\t\tif (this.readonly) {\r\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\r\n\t\t}\r\n\r\n\t\t//System.out.println(\"add \"+addition+\" to \"+intervals.toString());\r\n\t\tif (addition.b < addition.a) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// find position in list\r\n\t\t// Use iterators as we modify list in place\r\n\t\tfor (let i: number = 0; i < this._intervals.length; i++) {\r\n\t\t\tlet r: Interval = this._intervals[i];\r\n\t\t\tif (addition.equals(r)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (addition.adjacent(r) || !addition.disjoint(r)) {\r\n\t\t\t\t// next to each other, make a single larger interval\r\n\t\t\t\tlet bigger: Interval = addition.union(r);\r\n\t\t\t\tthis._intervals[i] = bigger;\r\n\t\t\t\t// make sure we didn't just create an interval that\r\n\t\t\t\t// should be merged with next interval in list\r\n\t\t\t\twhile (i < this._intervals.length - 1) {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tlet next: Interval = this._intervals[i];\r\n\t\t\t\t\tif (!bigger.adjacent(next) && bigger.disjoint(next)) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if we bump up against or overlap next, merge\r\n\t\t\t\t\t// remove this one\r\n\t\t\t\t\tthis._intervals.splice(i, 1);\r\n\t\t\t\t\ti--;\r\n\t\t\t\t\t// move backwards to what we just set\r\n\t\t\t\t\tthis._intervals[i] = bigger.union(next);\r\n\t\t\t\t\t// set to 3 merged ones\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// first call to next after previous duplicates the result\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (addition.startsBeforeDisjoint(r)) {\r\n\t\t\t\t// insert before r\r\n\t\t\t\tthis._intervals.splice(i, 0, addition);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// if disjoint and after r, a future iteration will handle it\r\n\t\t}\r\n\r\n\t\t// ok, must be after last interval (and disjoint from last interval)\r\n\t\t// just add it\r\n\t\tthis._intervals.push(addition);\r\n\t}\r\n\r\n\t/** combine all sets in the array returned the or'd value */\r\n\tpublic static or(sets: IntervalSet[]): IntervalSet {\r\n\t\tlet r: IntervalSet = new IntervalSet();\r\n\t\tfor (let s of sets) {\r\n\t\t\tr.addAll(s);\r\n\t\t}\r\n\r\n\t\treturn r;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic addAll(set: IntSet): IntervalSet {\r\n\t\tif (set == null) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (set instanceof IntervalSet) {\r\n\t\t\tlet other: IntervalSet = set;\r\n\t\t\t// walk set and add each interval\r\n\t\t\tlet n: number = other._intervals.length;\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet I: Interval = other._intervals[i];\r\n\t\t\t\tthis.add(I.a, I.b);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (let value of set.toArray()) {\r\n\t\t\t\tthis.add(value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic complementRange(minElement: number, maxElement: number): IntervalSet {\r\n\t\treturn this.complement(IntervalSet.of(minElement, maxElement));\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic complement(vocabulary: IntSet): IntervalSet {\r\n\t\tif (vocabulary.isNil) {\r\n\t\t\t// nothing in common with null set\r\n\t\t\treturn IntervalSet.EMPTY_SET;\r\n\t\t}\r\n\r\n\t\tlet vocabularyIS: IntervalSet;\r\n\t\tif (vocabulary instanceof IntervalSet) {\r\n\t\t\tvocabularyIS = vocabulary;\r\n\t\t} else {\r\n\t\t\tvocabularyIS = new IntervalSet();\r\n\t\t\tvocabularyIS.addAll(vocabulary);\r\n\t\t}\r\n\r\n\t\treturn vocabularyIS.subtract(this);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic subtract(a: IntSet): IntervalSet {\r\n\t\tif (a == null || a.isNil) {\r\n\t\t\treturn new IntervalSet(this._intervals);\r\n\t\t}\r\n\r\n\t\tif (a instanceof IntervalSet) {\r\n\t\t\treturn IntervalSet.subtract(this, a);\r\n\t\t}\r\n\r\n\t\tlet other: IntervalSet = new IntervalSet();\r\n\t\tother.addAll(a);\r\n\t\treturn IntervalSet.subtract(this, other);\r\n\t}\r\n\r\n\t/**\r\n\t * Compute the set difference between two interval sets. The specific\r\n\t * operation is `left - right`.\r\n\t */\r\n\t@NotNull\r\n\tpublic static subtract(left: IntervalSet, right: IntervalSet): IntervalSet {\r\n\t\tif (left.isNil) {\r\n\t\t\treturn new IntervalSet();\r\n\t\t}\r\n\r\n\t\tlet result: IntervalSet = new IntervalSet(left._intervals);\r\n\t\tif (right.isNil) {\r\n\t\t\t// right set has no elements; just return the copy of the current set\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tlet resultI: number = 0;\r\n\t\tlet rightI: number = 0;\r\n\t\twhile (resultI < result._intervals.length && rightI < right._intervals.length) {\r\n\t\t\tlet resultInterval: Interval = result._intervals[resultI];\r\n\t\t\tlet rightInterval: Interval = right._intervals[rightI];\r\n\r\n\t\t\t// operation: (resultInterval - rightInterval) and update indexes\r\n\r\n\t\t\tif (rightInterval.b < resultInterval.a) {\r\n\t\t\t\trightI++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (rightInterval.a > resultInterval.b) {\r\n\t\t\t\tresultI++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tlet beforeCurrent: Interval | undefined;\r\n\t\t\tlet afterCurrent: Interval | undefined;\r\n\t\t\tif (rightInterval.a > resultInterval.a) {\r\n\t\t\t\tbeforeCurrent = new Interval(resultInterval.a, rightInterval.a - 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (rightInterval.b < resultInterval.b) {\r\n\t\t\t\tafterCurrent = new Interval(rightInterval.b + 1, resultInterval.b);\r\n\t\t\t}\r\n\r\n\t\t\tif (beforeCurrent) {\r\n\t\t\t\tif (afterCurrent) {\r\n\t\t\t\t\t// split the current interval into two\r\n\t\t\t\t\tresult._intervals[resultI] = beforeCurrent;\r\n\t\t\t\t\tresult._intervals.splice(resultI + 1, 0, afterCurrent);\r\n\t\t\t\t\tresultI++;\r\n\t\t\t\t\trightI++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// replace the current interval\r\n\t\t\t\t\tresult._intervals[resultI] = beforeCurrent;\r\n\t\t\t\t\tresultI++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (afterCurrent) {\r\n\t\t\t\t\t// replace the current interval\r\n\t\t\t\t\tresult._intervals[resultI] = afterCurrent;\r\n\t\t\t\t\trightI++;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// remove the current interval (thus no need to increment resultI)\r\n\t\t\t\t\tresult._intervals.splice(resultI, 1);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If rightI reached right.intervals.size, no more intervals to subtract from result.\r\n\t\t// If resultI reached result.intervals.size, we would be subtracting from an empty set.\r\n\t\t// Either way, we are done.\r\n\t\treturn result;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic or(a: IntSet): IntervalSet {\r\n\t\tlet o: IntervalSet = new IntervalSet();\r\n\t\to.addAll(this);\r\n\t\to.addAll(a);\r\n\t\treturn o;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic and(other: IntSet): IntervalSet {\r\n\t\tif (other.isNil) { //|| !(other instanceof IntervalSet) ) {\r\n\t\t\t// nothing in common with null set\r\n\t\t\treturn new IntervalSet();\r\n\t\t}\r\n\r\n\t\tlet myIntervals: Interval[] = this._intervals;\r\n\t\tlet theirIntervals: Interval[] = (other as IntervalSet)._intervals;\r\n\t\tlet intersection: IntervalSet | undefined;\r\n\t\tlet mySize: number = myIntervals.length;\r\n\t\tlet theirSize: number = theirIntervals.length;\r\n\t\tlet i: number = 0;\r\n\t\tlet j: number = 0;\r\n\t\t// iterate down both interval lists looking for nondisjoint intervals\r\n\t\twhile (i < mySize && j < theirSize) {\r\n\t\t\tlet mine: Interval = myIntervals[i];\r\n\t\t\tlet theirs: Interval = theirIntervals[j];\r\n\t\t\t//System.out.println(\"mine=\"+mine+\" and theirs=\"+theirs);\r\n\t\t\tif (mine.startsBeforeDisjoint(theirs)) {\r\n\t\t\t\t// move this iterator looking for interval that might overlap\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\telse if (theirs.startsBeforeDisjoint(mine)) {\r\n\t\t\t\t// move other iterator looking for interval that might overlap\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t\telse if (mine.properlyContains(theirs)) {\r\n\t\t\t\t// overlap, add intersection, get next theirs\r\n\t\t\t\tif (!intersection) {\r\n\t\t\t\t\tintersection = new IntervalSet();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t\telse if (theirs.properlyContains(mine)) {\r\n\t\t\t\t// overlap, add intersection, get next mine\r\n\t\t\t\tif (!intersection) {\r\n\t\t\t\t\tintersection = new IntervalSet();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\telse if (!mine.disjoint(theirs)) {\r\n\t\t\t\t// overlap, add intersection\r\n\t\t\t\tif (!intersection) {\r\n\t\t\t\t\tintersection = new IntervalSet();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\r\n\t\t\t\t// Move the iterator of lower range [a..b], but not\r\n\t\t\t\t// the upper range as it may contain elements that will collide\r\n\t\t\t\t// with the next iterator. So, if mine=[0..115] and\r\n\t\t\t\t// theirs=[115..200], then intersection is 115 and move mine\r\n\t\t\t\t// but not theirs as theirs may collide with the next range\r\n\t\t\t\t// in thisIter.\r\n\t\t\t\t// move both iterators to next ranges\r\n\t\t\t\tif (mine.startsAfterNonDisjoint(theirs)) {\r\n\t\t\t\t\tj++;\r\n\t\t\t\t}\r\n\t\t\t\telse if (theirs.startsAfterNonDisjoint(mine)) {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!intersection) {\r\n\t\t\treturn new IntervalSet();\r\n\t\t}\r\n\r\n\t\treturn intersection;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic contains(el: number): boolean {\r\n\t\tlet n: number = this._intervals.length;\r\n\t\tlet l: number = 0;\r\n\t\tlet r: number = n - 1;\r\n\t\t// Binary search for the element in the (sorted, disjoint) array of intervals.\r\n\t\twhile (l <= r) {\r\n\t\t\tlet m: number = (l + r) >> 1;\r\n\t\t\tlet I: Interval = this._intervals[m];\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tif (b < el) {\r\n\t\t\t\tl = m + 1;\r\n\t\t\t} else if (a > el) {\r\n\t\t\t\tr = m - 1;\r\n\t\t\t} else {\r\n\t\t\t\t// el >= a && el <= b\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/** {@inheritDoc} */\r\n\t@Override\r\n\tget isNil(): boolean {\r\n\t\treturn this._intervals == null || this._intervals.length === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the maximum value contained in the set if not isNil.\r\n\t *\r\n\t * @return the maximum value contained in the set.\r\n\t * @throws RangeError if set is empty\r\n\t */\r\n\tget maxElement(): number {\r\n\t\tif (this.isNil) {\r\n\t\t\tthrow new RangeError(\"set is empty\");\r\n\t\t}\r\n\r\n\t\tlet last: Interval = this._intervals[this._intervals.length - 1];\r\n\t\treturn last.b;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the minimum value contained in the set if not isNil.\r\n\t *\r\n\t * @return the minimum value contained in the set.\r\n\t * @throws RangeError if set is empty\r\n\t */\r\n\tget minElement(): number {\r\n\t\tif (this.isNil) {\r\n\t\t\tthrow new RangeError(\"set is empty\");\r\n\t\t}\r\n\r\n\t\treturn this._intervals[0].a;\r\n\t}\r\n\r\n\t/** Return a list of Interval objects. */\r\n\tget intervals(): Interval[] {\r\n\t\treturn this._intervals;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\tfor (let I of this._intervals) {\r\n\t\t\thash = MurmurHash.update(hash, I.a);\r\n\t\t\thash = MurmurHash.update(hash, I.b);\r\n\t\t}\r\n\r\n\t\thash = MurmurHash.finish(hash, this._intervals.length * 2);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/** Are two IntervalSets equal?  Because all intervals are sorted\r\n\t *  and disjoint, equals is a simple linear walk over both lists\r\n\t *  to make sure they are the same.  Interval.equals() is used\r\n\t *  by the List.equals() method to check the ranges.\r\n\t */\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (o == null || !(o instanceof IntervalSet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);\r\n\t}\r\n\r\n\tpublic toString(elemAreChar: boolean = false): string {\r\n\t\tlet buf: string = \"\";\r\n\t\tif (this._intervals == null || this._intervals.length === 0) {\r\n\t\t\treturn \"{}\";\r\n\t\t}\r\n\r\n\t\tif (this.size > 1) {\r\n\t\t\tbuf += \"{\";\r\n\t\t}\r\n\r\n\t\tlet first: boolean = true;\r\n\t\tfor (let I of this._intervals) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tbuf += \", \";\r\n\t\t\t}\r\n\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tif (a === b) {\r\n\t\t\t\tif (a === Token.EOF) {\r\n\t\t\t\t\tbuf += \"<EOF>\";\r\n\t\t\t\t} else if (elemAreChar) {\r\n\t\t\t\t\tbuf += \"'\" + String.fromCodePoint(a) + \"'\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf += a;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (elemAreChar) {\r\n\t\t\t\t\tbuf += \"'\" + String.fromCodePoint(a) + \"'..'\" + String.fromCodePoint(b) + \"'\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf += a + \"..\" + b;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.size > 1) {\r\n\t\t\tbuf += \"}\";\r\n\t\t}\r\n\r\n\t\treturn buf;\r\n\t}\r\n\r\n\tpublic toStringVocabulary( @NotNull vocabulary: Vocabulary): string {\r\n\t\tif (this._intervals == null || this._intervals.length === 0) {\r\n\t\t\treturn \"{}\";\r\n\t\t}\r\n\r\n\t\tlet buf: string = \"\";\r\n\t\tif (this.size > 1) {\r\n\t\t\tbuf += \"{\";\r\n\t\t}\r\n\r\n\t\tlet first: boolean = true;\r\n\t\tfor (let I of this._intervals) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tbuf += \", \";\r\n\t\t\t}\r\n\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tif (a === b) {\r\n\t\t\t\tbuf += this.elementName(vocabulary, a);\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = a; i <= b; i++) {\r\n\t\t\t\t\tif (i > a) {\r\n\t\t\t\t\t\tbuf += \", \";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbuf += this.elementName(vocabulary, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.size > 1) {\r\n\t\t\tbuf += \"}\";\r\n\t\t}\r\n\r\n\t\treturn buf;\r\n\t}\r\n\r\n\t@NotNull\r\n\tprotected elementName( @NotNull vocabulary: Vocabulary, a: number): string {\r\n\t\tif (a === Token.EOF) {\r\n\t\t\treturn \"<EOF>\";\r\n\t\t} else if (a === Token.EPSILON) {\r\n\t\t\treturn \"<EPSILON>\";\r\n\t\t} else {\r\n\t\t\treturn vocabulary.getDisplayName(a);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\tlet n: number = 0;\r\n\t\tlet numIntervals: number = this._intervals.length;\r\n\t\tif (numIntervals === 1) {\r\n\t\t\tlet firstInterval: Interval = this._intervals[0];\r\n\t\t\treturn firstInterval.b - firstInterval.a + 1;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < numIntervals; i++) {\r\n\t\t\tlet I: Interval = this._intervals[i];\r\n\t\t\tn += (I.b - I.a + 1);\r\n\t\t}\r\n\r\n\t\treturn n;\r\n\t}\r\n\r\n\tpublic toIntegerList(): IntegerList {\r\n\t\tlet values: IntegerList = new IntegerList(this.size);\r\n\t\tlet n: number = this._intervals.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet I: Interval = this._intervals[i];\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tfor (let v = a; v <= b; v++) {\r\n\t\t\t\tvalues.add(v);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n\tpublic toSet(): Set<number> {\r\n\t\tlet s: Set<number> = new Set<number>();\r\n\t\tfor (let I of this._intervals) {\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tfor (let v = a; v <= b; v++) {\r\n\t\t\t\ts.add(v);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn s;\r\n\t}\r\n\r\n\tpublic toArray(): number[] {\r\n\t\tlet values: number[] = new Array<number>();\r\n\t\tlet n: number = this._intervals.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet I: Interval = this._intervals[i];\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tfor (let v = a; v <= b; v++) {\r\n\t\t\t\tvalues.push(v);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic remove(el: number): void {\r\n\t\tif (this.readonly) {\r\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\r\n\t\t}\r\n\r\n\t\tlet n: number = this._intervals.length;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet I: Interval = this._intervals[i];\r\n\t\t\tlet a: number = I.a;\r\n\t\t\tlet b: number = I.b;\r\n\t\t\tif (el < a) {\r\n\t\t\t\tbreak; // list is sorted and el is before this interval; not here\r\n\t\t\t}\r\n\t\t\t// if whole interval x..x, rm\r\n\t\t\tif (el === a && el === b) {\r\n\t\t\t\tthis._intervals.splice(i, 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// if on left edge x..b, adjust left\r\n\t\t\tif (el === a) {\r\n\t\t\t\tthis._intervals[i] = Interval.of(I.a + 1, I.b);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// if on right edge a..x, adjust right\r\n\t\t\tif (el === b) {\r\n\t\t\t\tthis._intervals[i] = Interval.of(I.a, I.b - 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// if in middle a..x..b, split interval\r\n\t\t\tif (el > a && el < b) { // found in this interval\r\n\t\t\t\tlet oldb: number = I.b;\r\n\t\t\t\tthis._intervals[i] = Interval.of(I.a, el - 1); // [a..x-1]\r\n\t\t\t\tthis.add(el + 1, oldb); // add [x+1..b]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tget isReadonly(): boolean {\r\n\t\treturn this.readonly;\r\n\t}\r\n\r\n\tpublic setReadonly(readonly: boolean): void {\r\n\t\tif (this.readonly && !readonly) {\r\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\r\n\t\t}\r\n\r\n\t\tthis.readonly = readonly;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:27.8389930-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class BasicState extends ATNState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.BASIC;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNStateType } from \"./ATNStateType\";\r\nimport { BasicState } from \"./BasicState\";\r\nimport { Override } from \"../Decorators\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class InvalidState extends BasicState {\r\n\r\n\t@Override\r\n\tget stateType(): ATNStateType {\r\n\t\treturn ATNStateType.INVALID_TYPE;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.3060135-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { Override, NotNull, Nullable } from \"../Decorators\";\r\nimport { Token } from \"../Token\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/** A transition containing a set of values. */\r\nexport class SetTransition extends Transition {\r\n\t@NotNull\r\n\tpublic set: IntervalSet;\r\n\r\n\t// TODO (sam): should we really allow undefined here?\r\n\tconstructor(@NotNull target: ATNState, @Nullable set: IntervalSet) {\r\n\t\tsuper(target);\r\n\t\tif (set == null) {\r\n\t\t\tset = IntervalSet.of(Token.INVALID_TYPE);\r\n\t\t}\r\n\r\n\t\tthis.set = set;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.SET;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tget label(): IntervalSet {\r\n\t\treturn this.set;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn this.set.contains(symbol);\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn this.set.toString();\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.8483617-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { Override, NotNull, Nullable } from \"../Decorators\";\r\nimport { SetTransition } from \"./SetTransition\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\nexport class NotSetTransition extends SetTransition {\r\n\tconstructor(@NotNull target: ATNState, @Nullable set: IntervalSet) {\r\n\t\tsuper(target, set);\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.NOT_SET;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn symbol >= minVocabSymbol\r\n\t\t\t&& symbol <= maxVocabSymbol\r\n\t\t\t&& !super.matches(symbol, minVocabSymbol, maxVocabSymbol);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\treturn \"~\" + super.toString();\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.8294453-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { RuleStartState } from \"./RuleStartState\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/** */\r\nexport class RuleTransition extends Transition {\r\n\t/** Ptr to the rule definition object for this rule ref */\r\n\tpublic ruleIndex: number;      // no Rule object at runtime\r\n\r\n\tpublic precedence: number;\r\n\r\n\t/** What node to begin computations following ref to rule */\r\n\t@NotNull\r\n\tpublic followState: ATNState;\r\n\r\n\tpublic tailCall: boolean = false;\r\n\tpublic optimizedTailCall: boolean = false;\r\n\r\n\tconstructor(@NotNull ruleStart: RuleStartState, ruleIndex: number, precedence: number, @NotNull followState: ATNState) {\r\n\t\tsuper(ruleStart);\r\n\t\tthis.ruleIndex = ruleIndex;\r\n\t\tthis.precedence = precedence;\r\n\t\tthis.followState = followState;\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.RULE;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEpsilon(): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn false;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.9456839-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { Override, NotNull } from \"../Decorators\";\r\nimport { Transition } from \"./Transition\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\nexport class WildcardTransition extends Transition {\r\n\tconstructor(@NotNull target: ATNState) {\r\n\t\tsuper(target);\r\n\t}\r\n\r\n\t@Override\r\n\tget serializationType(): TransitionType {\r\n\t\treturn TransitionType.WILDCARD;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean {\r\n\t\treturn symbol >= minVocabSymbol && symbol <= maxVocabSymbol;\r\n\t}\r\n\r\n\t@Override\r\n\t@NotNull\r\n\tpublic toString(): string {\r\n\t\treturn \".\";\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:30.4445360-07:00\r\n\r\nimport { AbstractPredicateTransition } from \"./AbstractPredicateTransition\";\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { ATN } from \"./ATN\";\r\nimport { ATNConfig } from \"./ATNConfig\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { BitSet } from \"../misc/BitSet\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { NotSetTransition } from \"./NotSetTransition\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\nimport { SetTransition } from \"./SetTransition\";\r\nimport { Token } from \"../Token\";\r\nimport { Transition } from \"./Transition\";\r\nimport { WildcardTransition } from \"./WildcardTransition\";\r\n\r\nexport class LL1Analyzer {\r\n\t/** Special value added to the lookahead sets to indicate that we hit\r\n\t *  a predicate during analysis if `seeThruPreds==false`.\r\n\t */\r\n\tpublic static readonly HIT_PRED: number = Token.INVALID_TYPE;\r\n\r\n\t@NotNull\r\n\tpublic atn: ATN;\r\n\r\n\tconstructor(@NotNull atn: ATN) { this.atn = atn; }\r\n\r\n\t/**\r\n\t * Calculates the SLL(1) expected lookahead set for each outgoing transition\r\n\t * of an {@link ATNState}. The returned array has one element for each\r\n\t * outgoing transition in `s`. If the closure from transition\r\n\t * *i* leads to a semantic predicate before matching a symbol, the\r\n\t * element at index *i* of the result will be `undefined`.\r\n\t *\r\n\t * @param s the ATN state\r\n\t * @returns the expected symbols for each outgoing transition of `s`.\r\n\t */\r\n\tpublic getDecisionLookahead(s: ATNState | undefined): Array<IntervalSet | undefined> | undefined {\r\n//\t\tSystem.out.println(\"LOOK(\"+s.stateNumber+\")\");\r\n\t\tif (s == null) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet look: Array<IntervalSet | undefined> = new Array<IntervalSet>(s.numberOfTransitions);\r\n\t\tfor (let alt = 0; alt < s.numberOfTransitions; alt++) {\r\n\t\t\tlet current: IntervalSet | undefined = new IntervalSet();\r\n\t\t\tlook[alt] = current;\r\n\t\t\tlet lookBusy: Array2DHashSet<ATNConfig> = new Array2DHashSet<ATNConfig>(ObjectEqualityComparator.INSTANCE);\r\n\t\t\tlet seeThruPreds: boolean = false; // fail to get lookahead upon pred\r\n\t\t\tthis._LOOK(s.transition(alt).target, undefined, PredictionContext.EMPTY_LOCAL,\r\n\t\t\t\tcurrent, lookBusy, new BitSet(), seeThruPreds, false);\r\n\t\t\t// Wipe out lookahead for this alternative if we found nothing\r\n\t\t\t// or we had a predicate when we !seeThruPreds\r\n\t\t\tif (current.size === 0 || current.contains(LL1Analyzer.HIT_PRED)) {\r\n\t\t\t\tcurrent = undefined;\r\n\t\t\t\tlook[alt] = current;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn look;\r\n\t}\r\n\r\n\t/**\r\n\t * Compute set of tokens that can follow `s` in the ATN in the\r\n\t * specified `ctx`.\r\n\t *\r\n\t * If `ctx` is `undefined` and the end of the rule containing\r\n\t * `s` is reached, {@link Token#EPSILON} is added to the result set.\r\n\t * If `ctx` is not `undefined` and the end of the outermost rule is\r\n\t * reached, {@link Token#EOF} is added to the result set.\r\n\t *\r\n\t * @param s the ATN state\r\n\t * @param ctx the complete parser context, or `undefined` if the context\r\n\t * should be ignored\r\n\t *\r\n\t * @returns The set of tokens that can follow `s` in the ATN in the\r\n\t * specified `ctx`.\r\n\t */\r\n\t// @NotNull\r\n\tpublic LOOK(/*@NotNull*/ s: ATNState, /*@NotNull*/ ctx: PredictionContext): IntervalSet;\r\n\r\n\t/**\r\n\t * Compute set of tokens that can follow `s` in the ATN in the\r\n\t * specified `ctx`.\r\n\t *\r\n\t * If `ctx` is `undefined` and the end of the rule containing\r\n\t * `s` is reached, {@link Token#EPSILON} is added to the result set.\r\n\t * If `ctx` is not `PredictionContext#EMPTY_LOCAL` and the end of the outermost rule is\r\n\t * reached, {@link Token#EOF} is added to the result set.\r\n\t *\r\n\t * @param s the ATN state\r\n\t * @param stopState the ATN state to stop at. This can be a\r\n\t * {@link BlockEndState} to detect epsilon paths through a closure.\r\n\t * @param ctx the complete parser context, or `undefined` if the context\r\n\t * should be ignored\r\n\t *\r\n\t * @returns The set of tokens that can follow `s` in the ATN in the\r\n\t * specified `ctx`.\r\n\t */\r\n\t// @NotNull\r\n\tpublic LOOK(/*@NotNull*/ s: ATNState, /*@NotNull*/ ctx: PredictionContext, stopState: ATNState | null): IntervalSet;\r\n\r\n\t@NotNull\r\n\tpublic LOOK(@NotNull s: ATNState, @NotNull ctx: PredictionContext, stopState?: ATNState | null): IntervalSet {\r\n\t\tif (stopState === undefined) {\r\n\t\t\tif (s.atn == null) {\r\n\t\t\t\tthrow new Error(\"Illegal state\");\r\n\t\t\t}\r\n\r\n\t\t\tstopState = s.atn.ruleToStopState[s.ruleIndex];\r\n\t\t} else if (stopState === null) {\r\n\t\t\t// This is an explicit request to pass undefined as the stopState to _LOOK. Used to distinguish an overload\r\n\t\t\t// from the method which simply omits the stopState parameter.\r\n\t\t\tstopState = undefined;\r\n\t\t}\r\n\r\n\t\tlet r: IntervalSet = new IntervalSet();\r\n\t\tlet seeThruPreds: boolean = true; // ignore preds; get all lookahead\r\n\t\tlet addEOF: boolean = true;\r\n\t\tthis._LOOK(s, stopState, ctx, r, new Array2DHashSet<ATNConfig>(), new BitSet(), seeThruPreds, addEOF);\r\n\t\treturn r;\r\n\t}\r\n\r\n\t/**\r\n\t * Compute set of tokens that can follow `s` in the ATN in the\r\n\t * specified `ctx`.\r\n\t * <p/>\r\n\t * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and\r\n\t * `stopState` or the end of the rule containing `s` is reached,\r\n\t * {@link Token#EPSILON} is added to the result set. If `ctx` is not\r\n\t * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`\r\n\t * and `stopState` or the end of the outermost rule is reached,\r\n\t * {@link Token#EOF} is added to the result set.\r\n\t *\r\n\t * @param s the ATN state.\r\n\t * @param stopState the ATN state to stop at. This can be a\r\n\t * {@link BlockEndState} to detect epsilon paths through a closure.\r\n\t * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if\r\n\t * the outer context should not be used.\r\n\t * @param look The result lookahead set.\r\n\t * @param lookBusy A set used for preventing epsilon closures in the ATN\r\n\t * from causing a stack overflow. Outside code should pass\r\n\t * `new HashSet<ATNConfig>` for this argument.\r\n\t * @param calledRuleStack A set used for preventing left recursion in the\r\n\t * ATN from causing a stack overflow. Outside code should pass\r\n\t * `new BitSet()` for this argument.\r\n\t * @param seeThruPreds `true` to true semantic predicates as\r\n\t * implicitly `true` and \"see through them\", otherwise `false`\r\n\t * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the\r\n\t * result if one is encountered.\r\n\t * @param addEOF Add {@link Token#EOF} to the result if the end of the\r\n\t * outermost context is reached. This parameter has no effect if `ctx`\r\n\t * is {@link PredictionContext#EMPTY_LOCAL}.\r\n\t */\r\n\tprotected _LOOK(\r\n\t\t@NotNull s: ATNState,\r\n\t\tstopState: ATNState | undefined,\r\n\t\t@NotNull ctx: PredictionContext,\r\n\t\t@NotNull look: IntervalSet,\r\n\t\t@NotNull lookBusy: Array2DHashSet<ATNConfig>,\r\n\t\t@NotNull calledRuleStack: BitSet,\r\n\t\tseeThruPreds: boolean,\r\n\t\taddEOF: boolean): void {\r\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\r\n\t\tlet c: ATNConfig = ATNConfig.create(s, 0, ctx);\r\n\t\tif (!lookBusy.add(c)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (s === stopState) {\r\n\t\t\tif (PredictionContext.isEmptyLocal(ctx)) {\r\n\t\t\t\tlook.add(Token.EPSILON);\r\n\t\t\t\treturn;\r\n\t\t\t} else if (ctx.isEmpty) {\r\n\t\t\t\tif (addEOF) {\r\n\t\t\t\t\tlook.add(Token.EOF);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (s instanceof RuleStopState) {\r\n\t\t\tif (ctx.isEmpty && !PredictionContext.isEmptyLocal(ctx)) {\r\n\t\t\t\tif (addEOF) {\r\n\t\t\t\t\tlook.add(Token.EOF);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet removed: boolean = calledRuleStack.get(s.ruleIndex);\r\n\t\t\ttry {\r\n\t\t\t\tcalledRuleStack.clear(s.ruleIndex);\r\n\t\t\t\tfor (let i = 0; i < ctx.size; i++) {\r\n\t\t\t\t\tif (ctx.getReturnState(i) === PredictionContext.EMPTY_FULL_STATE_KEY) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet returnState: ATNState = this.atn.states[ctx.getReturnState(i)];\r\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\r\n\t\t\t\t\tthis._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfinally {\r\n\t\t\t\tif (removed) {\r\n\t\t\t\t\tcalledRuleStack.set(s.ruleIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet n: number = s.numberOfTransitions;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tlet t: Transition = s.transition(i);\r\n\t\t\tif (t instanceof RuleTransition) {\r\n\t\t\t\tif (calledRuleStack.get(t.ruleIndex)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet newContext: PredictionContext = ctx.getChild(t.followState.stateNumber);\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcalledRuleStack.set(t.ruleIndex);\r\n\t\t\t\t\tthis._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\r\n\t\t\t\t}\r\n\t\t\t\tfinally {\r\n\t\t\t\t\tcalledRuleStack.clear(t.ruleIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (t instanceof AbstractPredicateTransition) {\r\n\t\t\t\tif (seeThruPreds) {\r\n\t\t\t\t\tthis._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlook.add(LL1Analyzer.HIT_PRED);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (t.isEpsilon) {\r\n\t\t\t\tthis._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\r\n\t\t\t}\r\n\t\t\telse if (t instanceof WildcardTransition) {\r\n\t\t\t\tlook.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\r\n\t\t\t}\r\n\t\t\telse {\r\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\r\n\t\t\t\tlet set: IntervalSet | undefined = t.label;\r\n\t\t\t\tif (set != null) {\r\n\t\t\t\t\tif (t instanceof NotSetTransition) {\r\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlook.addAll(set);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:25.1063510-07:00\r\n\r\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\r\nimport { ATNState } from \"./ATNState\";\r\nimport { ATNType } from \"./ATNType\";\r\nimport { DecisionState } from \"./DecisionState\";\r\nimport { DFA } from \"../dfa/DFA\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { InvalidState } from \"./InvalidState\";\r\nimport { LexerAction } from \"./LexerAction\";\r\nimport { LL1Analyzer } from \"./LL1Analyzer\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { PredictionContext } from \"./PredictionContext\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport { RuleStartState } from \"./RuleStartState\";\r\nimport { RuleStopState } from \"./RuleStopState\";\r\nimport { RuleTransition } from \"./RuleTransition\";\r\nimport { Token } from \"../Token\";\r\nimport { TokensStartState } from \"./TokensStartState\";\r\n\r\nimport * as assert from \"assert\";\r\n\r\n/** */\r\nexport class ATN {\r\n\t@NotNull\r\n\tpublic readonly states: ATNState[] = [];\r\n\r\n\t/** Each subrule/rule is a decision point and we must track them so we\r\n\t *  can go back later and build DFA predictors for them.  This includes\r\n\t *  all the rules, subrules, optional blocks, ()+, ()* etc...\r\n\t */\r\n\t@NotNull\r\n\tpublic decisionToState: DecisionState[] = [];\r\n\r\n\t/**\r\n\t * Maps from rule index to starting state number.\r\n\t */\r\n\tpublic ruleToStartState!: RuleStartState[];\r\n\r\n\t/**\r\n\t * Maps from rule index to stop state number.\r\n\t */\r\n\tpublic ruleToStopState!: RuleStopState[];\r\n\r\n\t@NotNull\r\n\tpublic modeNameToStartState: Map<string, TokensStartState> =\r\n\t\tnew Map<string, TokensStartState>();\r\n\r\n\t/**\r\n\t * The type of the ATN.\r\n\t */\r\n\tpublic grammarType: ATNType;\r\n\r\n\t/**\r\n\t * The maximum value for any symbol recognized by a transition in the ATN.\r\n\t */\r\n\tpublic maxTokenType: number;\r\n\r\n\t/**\r\n\t * For lexer ATNs, this maps the rule index to the resulting token type.\r\n\t * For parser ATNs, this maps the rule index to the generated bypass token\r\n\t * type if the\r\n\t * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}\r\n\t * deserialization option was specified; otherwise, this is `undefined`.\r\n\t */\r\n\tpublic ruleToTokenType!: Int32Array;\r\n\r\n\t/**\r\n\t * For lexer ATNs, this is an array of {@link LexerAction} objects which may\r\n\t * be referenced by action transitions in the ATN.\r\n\t */\r\n\tpublic lexerActions!: LexerAction[];\r\n\r\n\t@NotNull\r\n\tpublic modeToStartState: TokensStartState[] = [];\r\n\r\n\tprivate contextCache: Array2DHashMap<PredictionContext, PredictionContext> =\r\n\t\tnew Array2DHashMap<PredictionContext, PredictionContext>(ObjectEqualityComparator.INSTANCE);\r\n\r\n\t@NotNull\r\n\tpublic decisionToDFA: DFA[] = [];\r\n\t@NotNull\r\n\tpublic modeToDFA: DFA[] = [];\r\n\r\n\tpublic LL1Table: Map<number, number> = new Map<number, number>();\r\n\r\n\t/** Used for runtime deserialization of ATNs from strings */\r\n\tconstructor(@NotNull grammarType: ATNType, maxTokenType: number) {\r\n\t\tthis.grammarType = grammarType;\r\n\t\tthis.maxTokenType = maxTokenType;\r\n\t}\r\n\r\n\tpublic clearDFA(): void {\r\n\t\tthis.decisionToDFA = new Array<DFA>(this.decisionToState.length);\r\n\t\tfor (let i = 0; i < this.decisionToDFA.length; i++) {\r\n\t\t\tthis.decisionToDFA[i] = new DFA(this.decisionToState[i], i);\r\n\t\t}\r\n\r\n\t\tthis.modeToDFA = new Array<DFA>(this.modeToStartState.length);\r\n\t\tfor (let i = 0; i < this.modeToDFA.length; i++) {\r\n\t\t\tthis.modeToDFA[i] = new DFA(this.modeToStartState[i]);\r\n\t\t}\r\n\r\n\t\tthis.contextCache.clear();\r\n\t\tthis.LL1Table.clear();\r\n\t}\r\n\r\n\tget contextCacheSize(): number {\r\n\t\treturn this.contextCache.size;\r\n\t}\r\n\r\n\tpublic getCachedContext(context: PredictionContext): PredictionContext {\r\n\t\treturn PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext.IdentityHashMap());\r\n\t}\r\n\r\n\tpublic getDecisionToDFA(): DFA[] {\r\n\t\tassert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);\r\n\t\treturn this.decisionToDFA;\r\n\t}\r\n\r\n\t/** Compute the set of valid tokens that can occur starting in state `s`.\r\n\t *  If `ctx` is {@link PredictionContext#EMPTY_LOCAL}, the set of tokens will not include what can follow\r\n\t *  the rule surrounding `s`. In other words, the set will be\r\n\t *  restricted to tokens reachable staying within `s`'s rule.\r\n\t */\r\n\t// @NotNull\r\n\tpublic nextTokens(s: ATNState, /*@NotNull*/ ctx: PredictionContext): IntervalSet;\r\n\r\n\t/**\r\n\t * Compute the set of valid tokens that can occur starting in `s` and\r\n\t * staying in same rule. {@link Token#EPSILON} is in set if we reach end of\r\n\t * rule.\r\n\t */\r\n\t// @NotNull\r\n\tpublic nextTokens(/*@NotNull*/ s: ATNState): IntervalSet;\r\n\r\n\t@NotNull\r\n\tpublic nextTokens(s: ATNState, ctx?: PredictionContext): IntervalSet {\r\n\t\tif (ctx) {\r\n\t\t\tlet anal: LL1Analyzer = new LL1Analyzer(this);\r\n\t\t\tlet next: IntervalSet = anal.LOOK(s, ctx);\r\n\t\t\treturn next;\r\n\t\t} else {\r\n\t\t\tif (s.nextTokenWithinRule) {\r\n\t\t\t\treturn s.nextTokenWithinRule;\r\n\t\t\t}\r\n\r\n\t\t\ts.nextTokenWithinRule = this.nextTokens(s, PredictionContext.EMPTY_LOCAL);\r\n\t\t\ts.nextTokenWithinRule.setReadonly(true);\r\n\t\t\treturn s.nextTokenWithinRule;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic addState(state: ATNState): void {\r\n\t\tstate.atn = this;\r\n\t\tstate.stateNumber = this.states.length;\r\n\t\tthis.states.push(state);\r\n\t}\r\n\r\n\tpublic removeState(@NotNull state: ATNState): void {\r\n\t\t// just replace the state, don't shift states in list\r\n\t\tlet invalidState = new InvalidState();\r\n\t\tinvalidState.atn = this;\r\n\t\tinvalidState.stateNumber = state.stateNumber;\r\n\t\tthis.states[state.stateNumber] = invalidState;\r\n\t}\r\n\r\n\tpublic defineMode(@NotNull name: string, @NotNull s: TokensStartState): void {\r\n\t\tthis.modeNameToStartState.set(name, s);\r\n\t\tthis.modeToStartState.push(s);\r\n\t\tthis.modeToDFA.push(new DFA(s));\r\n\t\tthis.defineDecisionState(s);\r\n\t}\r\n\r\n\tpublic defineDecisionState(@NotNull s: DecisionState): number {\r\n\t\tthis.decisionToState.push(s);\r\n\t\ts.decision = this.decisionToState.length - 1;\r\n\t\tthis.decisionToDFA.push(new DFA(s, s.decision));\r\n\t\treturn s.decision;\r\n\t}\r\n\r\n\tpublic getDecisionState(decision: number): DecisionState | undefined {\r\n\t\tif (this.decisionToState.length > 0) {\r\n\t\t\treturn this.decisionToState[decision];\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tget numberOfDecisions(): number {\r\n\t\treturn this.decisionToState.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the set of input symbols which could follow ATN state number\r\n\t * `stateNumber` in the specified full `context`. This method\r\n\t * considers the complete parser context, but does not evaluate semantic\r\n\t * predicates (i.e. all predicates encountered during the calculation are\r\n\t * assumed true). If a path in the ATN exists from the starting state to the\r\n\t * {@link RuleStopState} of the outermost context without matching any\r\n\t * symbols, {@link Token#EOF} is added to the returned set.\r\n\t *\r\n\t * If `context` is `undefined`, it is treated as\r\n\t * {@link ParserRuleContext#EMPTY}.\r\n\t *\r\n\t * Note that this does NOT give you the set of all tokens that could\r\n\t * appear at a given token position in the input phrase.  In other words, it\r\n\t * does not answer:\r\n\t *\r\n\t * > Given a specific partial input phrase, return the set of all\r\n\t * > tokens that can follow the last token in the input phrase.\r\n\t *\r\n\t * The big difference is that with just the input, the parser could land\r\n\t * right in the middle of a lookahead decision. Getting all\r\n\t * *possible* tokens given a partial input stream is a separate\r\n\t * computation. See https://github.com/antlr/antlr4/issues/1428\r\n\t *\r\n\t * For this function, we are specifying an ATN state and call stack to\r\n\t * compute what token(s) can come next and specifically: outside of a\r\n\t * lookahead decision. That is what you want for error reporting and\r\n\t * recovery upon parse error.\r\n\t *\r\n\t * @param stateNumber the ATN state number\r\n\t * @param context the full parse context\r\n\t * @returns The set of potentially valid input symbols which could follow the\r\n\t * specified state in the specified context.\r\n\t * @ if the ATN does not contain a state with\r\n\t * number `stateNumber`\r\n\t */\r\n\t@NotNull\r\n\tpublic getExpectedTokens(stateNumber: number, context: RuleContext | undefined): IntervalSet {\r\n\t\tif (stateNumber < 0 || stateNumber >= this.states.length) {\r\n\t\t\tthrow new RangeError(\"Invalid state number.\");\r\n\t\t}\r\n\r\n\t\tlet ctx: RuleContext | undefined = context;\r\n\t\tlet s: ATNState = this.states[stateNumber];\r\n\t\tlet following: IntervalSet = this.nextTokens(s);\r\n\t\tif (!following.contains(Token.EPSILON)) {\r\n\t\t\treturn following;\r\n\t\t}\r\n\r\n\t\tlet expected: IntervalSet = new IntervalSet();\r\n\t\texpected.addAll(following);\r\n\t\texpected.remove(Token.EPSILON);\r\n\t\twhile (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\r\n\t\t\tlet invokingState: ATNState = this.states[ctx.invokingState];\r\n\t\t\tlet rt: RuleTransition = invokingState.transition(0) as RuleTransition;\r\n\t\t\tfollowing = this.nextTokens(rt.followState);\r\n\t\t\texpected.addAll(following);\r\n\t\t\texpected.remove(Token.EPSILON);\r\n\t\t\tctx = ctx._parent;\r\n\t\t}\r\n\r\n\t\tif (following.contains(Token.EPSILON)) {\r\n\t\t\texpected.add(Token.EOF);\r\n\t\t}\r\n\r\n\t\treturn expected;\r\n\t}\r\n}\r\n\r\nexport namespace ATN {\r\n\texport const INVALID_ALT_NUMBER: number = 0;\r\n}\r\n"],
  "mappings": "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",
  "names": ["ATNState", "Arrays", "PredictionContextCache", "ArrayPredictionContext", "SingletonPredictionContext", "PredictionContext", "ATNConfig", "value", "DFAState", "ATNSimulator", "ATNStateType", "CommonToken", "CommonTokenFactory", "LexerIndexedCustomAction", "LexerActionExecutor", "LexerATNSimulator", "LL1Analyzer", "ATN"]
}
