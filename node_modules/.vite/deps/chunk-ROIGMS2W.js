import {
  require_Decorators
} from "./chunk-U6TX4QV4.js";
import {
  require_Utils
} from "./chunk-TJPYJIIH.js";
import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/Transition.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transition = void 0;
    var Decorators_1 = require_Decorators();
    var Transition = class Transition {
      constructor(target) {
        if (target == null) {
          throw new Error("target cannot be null.");
        }
        this.target = target;
      }
      /**
       * Determines if the transition is an "epsilon" transition.
       *
       * The default implementation returns `false`.
       *
       * @returns `true` if traversing this transition in the ATN does not
       * consume an input symbol; otherwise, `false` if traversing this
       * transition consumes (matches) an input symbol.
       */
      get isEpsilon() {
        return false;
      }
      get label() {
        return void 0;
      }
    };
    Transition.serializationNames = [
      "INVALID",
      "EPSILON",
      "RANGE",
      "RULE",
      "PREDICATE",
      "ATOM",
      "ACTION",
      "SET",
      "NOT_SET",
      "WILDCARD",
      "PRECEDENCE"
    ];
    __decorate([
      Decorators_1.NotNull
    ], Transition.prototype, "target", void 0);
    Transition = __decorate([
      __param(0, Decorators_1.NotNull)
    ], Transition);
    exports.Transition = Transition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/AbstractPredicateTransition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractPredicateTransition = void 0;
    var Transition_1 = require_Transition();
    var AbstractPredicateTransition = class extends Transition_1.Transition {
      constructor(target) {
        super(target);
      }
    };
    exports.AbstractPredicateTransition = AbstractPredicateTransition;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ObjectEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return obj.hashCode();
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined` or `null`, this method returns `true`. Otherwise if only
       * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a, b) {
        if (a == null) {
          return b == null;
        }
        return a.equals(b);
      }
    };
    ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ObjectEqualityComparator.prototype, "equals", null);
    exports.ObjectEqualityComparator = ObjectEqualityComparator;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/MurmurHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MurmurHash = void 0;
    var MurmurHash;
    (function(MurmurHash2) {
      const DEFAULT_SEED = 0;
      function initialize(seed = DEFAULT_SEED) {
        return seed;
      }
      MurmurHash2.initialize = initialize;
      function update(hash, value) {
        const c1 = 3432918353;
        const c2 = 461845907;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n = 3864292196;
        if (value == null) {
          value = 0;
        } else if (typeof value === "string") {
          value = hashString(value);
        } else if (typeof value === "object") {
          value = value.hashCode();
        }
        let k = value;
        k = Math.imul(k, c1);
        k = k << r1 | k >>> 32 - r1;
        k = Math.imul(k, c2);
        hash = hash ^ k;
        hash = hash << r2 | hash >>> 32 - r2;
        hash = Math.imul(hash, m) + n;
        return hash & 4294967295;
      }
      MurmurHash2.update = update;
      function finish(hash, numberOfWords) {
        hash = hash ^ numberOfWords * 4;
        hash = hash ^ hash >>> 16;
        hash = Math.imul(hash, 2246822507);
        hash = hash ^ hash >>> 13;
        hash = Math.imul(hash, 3266489909);
        hash = hash ^ hash >>> 16;
        return hash;
      }
      MurmurHash2.finish = finish;
      function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value of data) {
          hash = update(hash, value);
          length++;
        }
        hash = finish(hash, length);
        return hash;
      }
      MurmurHash2.hashCode = hashCode;
      function hashString(str) {
        let len = str.length;
        if (len === 0) {
          return 0;
        }
        let hash = 0;
        for (let i = 0; i < len; i++) {
          let c = str.charCodeAt(i);
          hash = (hash << 5 >>> 0) - hash + c;
          hash |= 0;
        }
        return hash;
      }
    })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/DefaultEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var DefaultEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        } else if (typeof obj === "string" || typeof obj === "number") {
          return MurmurHash_1.MurmurHash.hashCode([obj]);
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
        }
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined` or `null`, this method returns `true`. Otherwise if only
       * `a` is `undefined` or `null`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (typeof a === "string" || typeof a === "number") {
          return a === b;
        } else {
          return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
        }
      }
    };
    DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], DefaultEqualityComparator.prototype, "equals", null);
    exports.DefaultEqualityComparator = DefaultEqualityComparator;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/Array2DHashSet.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Array2DHashSet = void 0;
    var assert = require_assert();
    var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var INITAL_CAPACITY = 16;
    var LOAD_FACTOR = 0.75;
    var Array2DHashSet = class _Array2DHashSet {
      constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
        if (comparatorOrSet instanceof _Array2DHashSet) {
          this.comparator = comparatorOrSet.comparator;
          this.buckets = comparatorOrSet.buckets.slice(0);
          for (let i = 0; i < this.buckets.length; i++) {
            let bucket = this.buckets[i];
            if (bucket) {
              this.buckets[i] = bucket.slice(0);
            }
          }
          this.n = comparatorOrSet.n;
          this.threshold = comparatorOrSet.threshold;
        } else {
          this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
          this.buckets = this.createBuckets(initialCapacity);
        }
      }
      /**
       * Add `o` to set if not there; return existing value if already
       * there. This method performs the same operation as {@link #add} aside from
       * the return value.
       */
      getOrAdd(o) {
        if (this.n > this.threshold) {
          this.expand();
        }
        return this.getOrAddImpl(o);
      }
      getOrAddImpl(o) {
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          bucket = [o];
          this.buckets[b] = bucket;
          this.n++;
          return o;
        }
        for (let existing of bucket) {
          if (this.comparator.equals(existing, o)) {
            return existing;
          }
        }
        bucket.push(o);
        this.n++;
        return o;
      }
      get(o) {
        if (o == null) {
          return o;
        }
        let b = this.getBucket(o);
        let bucket = this.buckets[b];
        if (!bucket) {
          return void 0;
        }
        for (let e of bucket) {
          if (this.comparator.equals(e, o)) {
            return e;
          }
        }
        return void 0;
      }
      getBucket(o) {
        let hash = this.comparator.hashCode(o);
        let b = hash & this.buckets.length - 1;
        return b;
      }
      hashCode() {
        let hash = MurmurHash_1.MurmurHash.initialize();
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
          }
        }
        hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
        return hash;
      }
      equals(o) {
        if (o === this) {
          return true;
        }
        if (!(o instanceof _Array2DHashSet)) {
          return false;
        }
        if (o.size !== this.size) {
          return false;
        }
        let same = this.containsAll(o);
        return same;
      }
      expand() {
        let old = this.buckets;
        let newCapacity = this.buckets.length * 2;
        let newTable = this.createBuckets(newCapacity);
        this.buckets = newTable;
        this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
        let oldSize = this.size;
        for (let bucket of old) {
          if (!bucket) {
            continue;
          }
          for (let o of bucket) {
            let b = this.getBucket(o);
            let newBucket = this.buckets[b];
            if (!newBucket) {
              newBucket = [];
              this.buckets[b] = newBucket;
            }
            newBucket.push(o);
          }
        }
        assert(this.n === oldSize);
      }
      add(t) {
        let existing = this.getOrAdd(t);
        return existing === t;
      }
      get size() {
        return this.n;
      }
      get isEmpty() {
        return this.n === 0;
      }
      contains(o) {
        return this.containsFast(this.asElementType(o));
      }
      containsFast(obj) {
        if (obj == null) {
          return false;
        }
        return this.get(obj) != null;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      toArray() {
        const a = new Array(this.size);
        let i = 0;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            a[i++] = o;
          }
        }
        return a;
      }
      containsAll(collection) {
        if (collection instanceof _Array2DHashSet) {
          let s = collection;
          for (let bucket of s.buckets) {
            if (bucket == null) {
              continue;
            }
            for (let o of bucket) {
              if (o == null) {
                break;
              }
              if (!this.containsFast(this.asElementType(o))) {
                return false;
              }
            }
          }
        } else {
          for (let o of collection) {
            if (!this.containsFast(this.asElementType(o))) {
              return false;
            }
          }
        }
        return true;
      }
      addAll(c) {
        let changed = false;
        for (let o of c) {
          let existing = this.getOrAdd(o);
          if (existing !== o) {
            changed = true;
          }
        }
        return changed;
      }
      clear() {
        this.buckets = this.createBuckets(INITAL_CAPACITY);
        this.n = 0;
        this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      }
      toString() {
        if (this.size === 0) {
          return "{}";
        }
        let buf = "{";
        let first = true;
        for (let bucket of this.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            if (first) {
              first = false;
            } else {
              buf += ", ";
            }
            buf += o.toString();
          }
        }
        buf += "}";
        return buf;
      }
      toTableString() {
        let buf = "";
        for (let bucket of this.buckets) {
          if (bucket == null) {
            buf += "null\n";
            continue;
          }
          buf += "[";
          let first = true;
          for (let o of bucket) {
            if (first) {
              first = false;
            } else {
              buf += " ";
            }
            if (o == null) {
              buf += "_";
            } else {
              buf += o.toString();
            }
          }
          buf += "]\n";
        }
        return buf;
      }
      /**
       * Return `o` as an instance of the element type `T`. If
       * `o` is non-undefined but known to not be an instance of `T`, this
       * method returns `undefined`. The base implementation does not perform any
       * type checks; override this method to provide strong type checks for the
       * {@link #contains} and {@link #remove} methods to ensure the arguments to
       * the {@link EqualityComparator} for the set always have the expected
       * types.
       *
       * @param o the object to try and cast to the element type of the set
       * @returns `o` if it could be an instance of `T`, otherwise
       * `undefined`.
       */
      asElementType(o) {
        return o;
      }
      /**
       * Return an array of `T[]` with length `capacity`.
       *
       * @param capacity the length of the array to return
       * @returns the newly constructed array
       */
      createBuckets(capacity) {
        return new Array(capacity);
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], Array2DHashSet.prototype, "comparator", void 0);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "add", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "size", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "isEmpty", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "contains", null);
    __decorate([
      __param(0, Decorators_1.Nullable)
    ], Array2DHashSet.prototype, "containsFast", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, Symbol.iterator, null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toArray", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "containsAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "addAll", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "clear", null);
    __decorate([
      Decorators_1.Override
    ], Array2DHashSet.prototype, "toString", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "asElementType", null);
    __decorate([
      Decorators_1.SuppressWarnings("unchecked")
    ], Array2DHashSet.prototype, "createBuckets", null);
    exports.Array2DHashSet = Array2DHashSet;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/misc/ArrayEqualityComparator.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayEqualityComparator = void 0;
    var Decorators_1 = require_Decorators();
    var MurmurHash_1 = require_MurmurHash();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var ArrayEqualityComparator = class {
      /**
       * {@inheritDoc}
       *
       * This implementation returns
       * `obj.`{@link Object#hashCode hashCode()}.
       */
      hashCode(obj) {
        if (obj == null) {
          return 0;
        }
        return MurmurHash_1.MurmurHash.hashCode(obj, 0);
      }
      /**
       * {@inheritDoc}
       *
       * This implementation relies on object equality. If both objects are
       * `undefined`, this method returns `true`. Otherwise if only
       * `a` is `undefined`, this method returns `false`. Otherwise,
       * this method returns the result of
       * `a.`{@link Object#equals equals}`(b)`.
       */
      equals(a, b) {
        if (a == null) {
          return b == null;
        } else if (b == null) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    };
    ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], ArrayEqualityComparator.prototype, "equals", null);
    exports.ArrayEqualityComparator = ArrayEqualityComparator;
  }
});

// node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS({
  "node_modules/.pnpm/antlr4ts@0.5.0-alpha.4/node_modules/antlr4ts/atn/SemanticContext.js"(exports) {
    "use strict";
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticContext = void 0;
    var Array2DHashSet_1 = require_Array2DHashSet();
    var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
    var MurmurHash_1 = require_MurmurHash();
    var Decorators_1 = require_Decorators();
    var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
    var Utils = require_Utils();
    function max(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison < 0) {
          result = current;
        }
      }
      return result;
    }
    function min(items) {
      let result;
      for (let current of items) {
        if (result === void 0) {
          result = current;
          continue;
        }
        let comparison = result.compareTo(current);
        if (comparison > 0) {
          result = current;
        }
      }
      return result;
    }
    var SemanticContext = class _SemanticContext {
      /**
       * The default {@link SemanticContext}, which is semantically equivalent to
       * a predicate of the form `{true}?`.
       */
      static get NONE() {
        if (_SemanticContext._NONE === void 0) {
          _SemanticContext._NONE = new _SemanticContext.Predicate();
        }
        return _SemanticContext._NONE;
      }
      /**
       * Evaluate the precedence predicates for the context and reduce the result.
       *
       * @param parser The parser instance.
       * @param parserCallStack
       * @returns The simplified semantic context after precedence predicates are
       * evaluated, which will be one of the following values.
       *
       * * {@link #NONE}: if the predicate simplifies to `true` after
       *   precedence predicates are evaluated.
       * * `undefined`: if the predicate simplifies to `false` after
       *   precedence predicates are evaluated.
       * * `this`: if the semantic context is not changed as a result of
       *   precedence predicate evaluation.
       * * A non-`undefined` {@link SemanticContext}: the new simplified
       *   semantic context after precedence predicates are evaluated.
       */
      evalPrecedence(parser, parserCallStack) {
        return this;
      }
      static and(a, b) {
        if (!a || a === _SemanticContext.NONE) {
          return b;
        }
        if (b === _SemanticContext.NONE) {
          return a;
        }
        let result = new _SemanticContext.AND(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
      /**
       *
       *  @see ParserATNSimulator#getPredsForAmbigAlts
       */
      static or(a, b) {
        if (!a) {
          return b;
        }
        if (a === _SemanticContext.NONE || b === _SemanticContext.NONE) {
          return _SemanticContext.NONE;
        }
        let result = new _SemanticContext.OR(a, b);
        if (result.opnds.length === 1) {
          return result.opnds[0];
        }
        return result;
      }
    };
    exports.SemanticContext = SemanticContext;
    (function(SemanticContext2) {
      const AND_HASHCODE = 40363613;
      const OR_HASHCODE = 486279973;
      function filterPrecedencePredicates(collection) {
        let result = [];
        for (let i = 0; i < collection.length; i++) {
          let context = collection[i];
          if (context instanceof SemanticContext2.PrecedencePredicate) {
            result.push(context);
            collection.splice(i, 1);
            i--;
          }
        }
        return result;
      }
      class Predicate extends SemanticContext2 {
        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
          super();
          this.ruleIndex = ruleIndex;
          this.predIndex = predIndex;
          this.isCtxDependent = isCtxDependent;
        }
        eval(parser, parserCallStack) {
          let localctx = this.isCtxDependent ? parserCallStack : void 0;
          return parser.sempred(localctx, this.ruleIndex, this.predIndex);
        }
        hashCode() {
          let hashCode = MurmurHash_1.MurmurHash.initialize();
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
          hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
          hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof Predicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
        }
        toString() {
          return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], Predicate.prototype, "toString", null);
      SemanticContext2.Predicate = Predicate;
      class PrecedencePredicate extends SemanticContext2 {
        constructor(precedence) {
          super();
          this.precedence = precedence;
        }
        eval(parser, parserCallStack) {
          return parser.precpred(parserCallStack, this.precedence);
        }
        evalPrecedence(parser, parserCallStack) {
          if (parser.precpred(parserCallStack, this.precedence)) {
            return SemanticContext2.NONE;
          } else {
            return void 0;
          }
        }
        compareTo(o) {
          return this.precedence - o.precedence;
        }
        hashCode() {
          let hashCode = 1;
          hashCode = 31 * hashCode + this.precedence;
          return hashCode;
        }
        equals(obj) {
          if (!(obj instanceof PrecedencePredicate)) {
            return false;
          }
          if (this === obj) {
            return true;
          }
          return this.precedence === obj.precedence;
        }
        toString() {
          return "{" + this.precedence + ">=prec}?";
        }
      }
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "compareTo", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], PrecedencePredicate.prototype, "toString", null);
      SemanticContext2.PrecedencePredicate = PrecedencePredicate;
      class Operator extends SemanticContext2 {
      }
      SemanticContext2.Operator = Operator;
      let AND = class AND2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof AND2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof AND2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = min(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof AND2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
        }
        /**
         * {@inheritDoc}
         *
         * The evaluation of predicates by this context is short-circuiting, but
         * unordered.
         */
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (!opnd.eval(parser, parserCallStack)) {
              return false;
            }
          }
          return true;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated == null) {
              return void 0;
            } else if (evaluated !== SemanticContext2.NONE) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return SemanticContext2.NONE;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.and(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils.join(this.opnds, "&&");
        }
      };
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], AND.prototype, "toString", null);
      AND = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], AND);
      SemanticContext2.AND = AND;
      let OR = class OR2 extends Operator {
        constructor(a, b) {
          super();
          let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
          if (a instanceof OR2) {
            operands.addAll(a.opnds);
          } else {
            operands.add(a);
          }
          if (b instanceof OR2) {
            operands.addAll(b.opnds);
          } else {
            operands.add(b);
          }
          this.opnds = operands.toArray();
          let precedencePredicates = filterPrecedencePredicates(this.opnds);
          let reduced = max(precedencePredicates);
          if (reduced) {
            this.opnds.push(reduced);
          }
        }
        get operands() {
          return this.opnds;
        }
        equals(obj) {
          if (this === obj) {
            return true;
          }
          if (!(obj instanceof OR2)) {
            return false;
          }
          return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
        }
        hashCode() {
          return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
        }
        /**
         * {@inheritDoc}
         *
         * The evaluation of predicates by this context is short-circuiting, but
         * unordered.
         */
        eval(parser, parserCallStack) {
          for (let opnd of this.opnds) {
            if (opnd.eval(parser, parserCallStack)) {
              return true;
            }
          }
          return false;
        }
        evalPrecedence(parser, parserCallStack) {
          let differs = false;
          let operands = [];
          for (let context of this.opnds) {
            let evaluated = context.evalPrecedence(parser, parserCallStack);
            differs = differs || evaluated !== context;
            if (evaluated === SemanticContext2.NONE) {
              return SemanticContext2.NONE;
            } else if (evaluated) {
              operands.push(evaluated);
            }
          }
          if (!differs) {
            return this;
          }
          if (operands.length === 0) {
            return void 0;
          }
          let result = operands[0];
          for (let i = 1; i < operands.length; i++) {
            result = SemanticContext2.or(result, operands[i]);
          }
          return result;
        }
        toString() {
          return Utils.join(this.opnds, "||");
        }
      };
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "operands", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "equals", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "hashCode", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "eval", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "evalPrecedence", null);
      __decorate([
        Decorators_1.Override
      ], OR.prototype, "toString", null);
      OR = __decorate([
        __param(0, Decorators_1.NotNull),
        __param(1, Decorators_1.NotNull)
      ], OR);
      SemanticContext2.OR = OR;
    })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
  }
});

export {
  require_assert,
  require_Transition,
  require_AbstractPredicateTransition,
  require_MurmurHash,
  require_ObjectEqualityComparator,
  require_Array2DHashSet,
  require_ArrayEqualityComparator,
  require_SemanticContext
};
/*! Bundled license information:

antlr4ts/atn/Transition.js:
antlr4ts/atn/AbstractPredicateTransition.js:
antlr4ts/misc/ObjectEqualityComparator.js:
antlr4ts/misc/MurmurHash.js:
antlr4ts/misc/DefaultEqualityComparator.js:
antlr4ts/misc/Array2DHashSet.js:
antlr4ts/misc/ArrayEqualityComparator.js:
antlr4ts/atn/SemanticContext.js:
  (*!
   * Copyright 2016 The ANTLR Project. All rights reserved.
   * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
   *)
*/
//# sourceMappingURL=chunk-ROIGMS2W.js.map
