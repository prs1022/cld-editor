{
  "version": 3,
  "sources": ["browser-external:assert", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/Transition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/AbstractPredicateTransition.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/ObjectEqualityComparator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/MurmurHash.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/DefaultEqualityComparator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/Array2DHashSet.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/misc/ArrayEqualityComparator.ts", "../../.pnpm/antlr4ts@0.5.0-alpha.4/src/atn/SemanticContext.ts"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"assert\" has been externalized for browser compatibility. Cannot access \"assert.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:37.8530496-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { IntervalSet } from \"../misc/IntervalSet\";\r\nimport { NotNull } from \"../Decorators\";\r\nimport { TransitionType } from \"./TransitionType\";\r\n\r\n/** An ATN transition between any two ATN states.  Subclasses define\r\n *  atom, set, epsilon, action, predicate, rule transitions.\r\n *\r\n *  This is a one way link.  It emanates from a state (usually via a list of\r\n *  transitions) and has a target state.\r\n *\r\n *  Since we never have to change the ATN transitions once we construct it,\r\n *  we can fix these transitions as specific classes. The DFA transitions\r\n *  on the other hand need to update the labels as it adds transitions to\r\n *  the states. We'll use the term Edge for the DFA to distinguish them from\r\n *  ATN transitions.\r\n */\r\nexport abstract class Transition {\r\n\tpublic static readonly serializationNames: string[] = [\r\n\t\t\"INVALID\",\r\n\t\t\"EPSILON\",\r\n\t\t\"RANGE\",\r\n\t\t\"RULE\",\r\n\t\t\"PREDICATE\",\r\n\t\t\"ATOM\",\r\n\t\t\"ACTION\",\r\n\t\t\"SET\",\r\n\t\t\"NOT_SET\",\r\n\t\t\"WILDCARD\",\r\n\t\t\"PRECEDENCE\",\r\n\t];\r\n\r\n\t// @SuppressWarnings(\"serial\")\r\n\t// static serializationTypes: Map<Class<? extends Transition>, number> =\r\n\t// \tCollections.unmodifiableMap(new HashMap<Class<? extends Transition>, Integer>() {{\r\n\t// \t\tput(EpsilonTransition.class, EPSILON);\r\n\t// \t\tput(RangeTransition.class, RANGE);\r\n\t// \t\tput(RuleTransition.class, RULE);\r\n\t// \t\tput(PredicateTransition.class, PREDICATE);\r\n\t// \t\tput(AtomTransition.class, ATOM);\r\n\t// \t\tput(ActionTransition.class, ACTION);\r\n\t// \t\tput(SetTransition.class, SET);\r\n\t// \t\tput(NotSetTransition.class, NOT_SET);\r\n\t// \t\tput(WildcardTransition.class, WILDCARD);\r\n\t// \t\tput(PrecedencePredicateTransition.class, PRECEDENCE);\r\n\t// \t}});\r\n\r\n\t/** The target of this transition. */\r\n\t@NotNull\r\n\tpublic target: ATNState;\r\n\r\n\tconstructor(@NotNull target: ATNState) {\r\n\t\tif (target == null) {\r\n\t\t\tthrow new Error(\"target cannot be null.\");\r\n\t\t}\r\n\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\tpublic abstract readonly serializationType: TransitionType;\r\n\r\n\t/**\r\n\t * Determines if the transition is an \"epsilon\" transition.\r\n\t *\r\n\t * The default implementation returns `false`.\r\n\t *\r\n\t * @returns `true` if traversing this transition in the ATN does not\r\n\t * consume an input symbol; otherwise, `false` if traversing this\r\n\t * transition consumes (matches) an input symbol.\r\n\t */\r\n\tget isEpsilon(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget label(): IntervalSet | undefined {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tpublic abstract matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean;\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:24.6596177-07:00\r\n\r\nimport { ATNState } from \"./ATNState\";\r\nimport { Transition } from \"./Transition\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport abstract class AbstractPredicateTransition extends Transition {\r\n\r\n\tconstructor(target: ATNState) {\r\n\t\tsuper(target);\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-03T02:09:42.2127260-07:00\r\nimport { EqualityComparator } from \"./EqualityComparator\";\r\nimport { Override } from \"../Decorators\";\r\nimport { Equatable } from \"./Stubs\";\r\n\r\n/**\r\n * This default implementation of {@link EqualityComparator} uses object equality\r\n * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ObjectEqualityComparator implements EqualityComparator<Equatable | null | undefined> {\r\n\tpublic static readonly INSTANCE: ObjectEqualityComparator = new ObjectEqualityComparator();\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation returns\r\n\t * `obj.`{@link Object#hashCode hashCode()}.\r\n\t */\r\n\t@Override\r\n\tpublic hashCode(obj: Equatable | null | undefined): number {\r\n\t\tif (obj == null) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn obj.hashCode();\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation relies on object equality. If both objects are\r\n\t * `undefined` or `null`, this method returns `true`. Otherwise if only\r\n\t * `a` is `undefined` or `null`, this method returns `false`. Otherwise,\r\n\t * this method returns the result of\r\n\t * `a.`{@link Object#equals equals}`(b)`.\r\n\t */\r\n\t@Override\r\n\tpublic equals(a: Equatable | null | undefined, b: Equatable | null | undefined): boolean {\r\n\t\tif (a == null) {\r\n\t\t\treturn b == null;\r\n\t\t}\r\n\r\n\t\treturn a.equals(b);\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-03T02:09:42.1239660-07:00\r\nimport { Equatable } from \"./Stubs\";\r\n\r\n/**\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport namespace MurmurHash {\r\n\r\n\tconst DEFAULT_SEED: number = 0;\r\n\r\n\t/**\r\n\t * Initialize the hash using the specified `seed`.\r\n\t *\r\n\t * @param seed the seed (optional)\r\n\t * @returns the intermediate hash value\r\n\t */\r\n\texport function initialize(seed: number = DEFAULT_SEED): number {\r\n\t\treturn seed;\r\n\t}\r\n\r\n\t/**\r\n\t * Update the intermediate hash value for the next input `value`.\r\n\t *\r\n\t * @param hash the intermediate hash value\r\n\t * @param value the value to add to the current hash\r\n\t * @returns the updated intermediate hash value\r\n\t */\r\n\texport function update(hash: number, value: number | string | Equatable | null | undefined): number {\r\n\t\tconst c1: number = 0xCC9E2D51;\r\n\t\tconst c2: number = 0x1B873593;\r\n\t\tconst r1: number = 15;\r\n\t\tconst r2: number = 13;\r\n\t\tconst m: number = 5;\r\n\t\tconst n: number = 0xE6546B64;\r\n\r\n\t\tif (value == null) {\r\n\t\t\tvalue = 0;\r\n\t\t} else if (typeof value === \"string\") {\r\n\t\t\tvalue = hashString(value);\r\n\t\t} else if (typeof value === \"object\") {\r\n\t\t\tvalue = value.hashCode();\r\n\t\t}\r\n\r\n\t\tlet k: number = value;\r\n\t\tk = Math.imul(k, c1);\r\n\t\tk = (k << r1) | (k >>> (32 - r1));\r\n\t\tk = Math.imul(k, c2);\r\n\r\n\t\thash = hash ^ k;\r\n\t\thash = (hash << r2) | (hash >>> (32 - r2));\r\n\t\thash = Math.imul(hash, m) + n;\r\n\r\n\t\treturn hash & 0xFFFFFFFF;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Apply the final computation steps to the intermediate value `hash`\r\n\t * to form the final result of the MurmurHash 3 hash function.\r\n\t *\r\n\t * @param hash the intermediate hash value\r\n\t * @param numberOfWords the number of integer values added to the hash\r\n\t * @returns the final hash result\r\n\t */\r\n\texport function finish(hash: number, numberOfWords: number): number {\r\n\t\thash = hash ^ (numberOfWords * 4);\r\n\t\thash = hash ^ (hash >>> 16);\r\n\t\thash = Math.imul(hash, 0x85EBCA6B);\r\n\t\thash = hash ^ (hash >>> 13);\r\n\t\thash = Math.imul(hash, 0xC2B2AE35);\r\n\t\thash = hash ^ (hash >>> 16);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/**\r\n\t * Utility function to compute the hash code of an array using the\r\n\t * MurmurHash algorithm.\r\n\t *\r\n\t * @param <T> the array element type\r\n\t * @param data the array data\r\n\t * @param seed the seed for the MurmurHash algorithm\r\n\t * @returns the hash code of the data\r\n\t */\r\n\texport function hashCode<T extends number | string | Equatable>(data: Iterable<T>, seed: number = DEFAULT_SEED): number {\r\n\t\tlet hash: number = initialize(seed);\r\n\t\tlet length = 0;\r\n\t\tfor (let value of data) {\r\n\t\t\thash = update(hash, value);\r\n\t\t\tlength++;\r\n\t\t}\r\n\r\n\t\thash = finish(hash, length);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/**\r\n\t * Function to hash a string. Based on the implementation found here:\r\n\t * http://stackoverflow.com/a/7616484\r\n\t */\r\n\tfunction hashString(str: string): number {\r\n\t\tlet len = str.length;\r\n\t\tif (len === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tlet hash = 0;\r\n\t\tfor (let i = 0; i < len; i++) {\r\n\t\t\tlet c = str.charCodeAt(i);\r\n\t\t\thash = (((hash << 5) >>> 0) - hash) + c;\r\n\t\t\thash |= 0;\r\n\t\t}\r\n\r\n\t\treturn hash;\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\nimport { EqualityComparator } from \"./EqualityComparator\";\r\nimport { Override } from \"../Decorators\";\r\nimport { Equatable } from \"./Stubs\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\nimport { ObjectEqualityComparator } from \"./ObjectEqualityComparator\";\r\n\r\n/**\r\n * This default implementation of {@link EqualityComparator} uses object equality\r\n * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class DefaultEqualityComparator implements EqualityComparator<any> {\r\n\tpublic static readonly INSTANCE: DefaultEqualityComparator = new DefaultEqualityComparator();\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation returns\r\n\t * `obj.`{@link Object#hashCode hashCode()}.\r\n\t */\r\n\t@Override\r\n\tpublic hashCode(obj: any): number {\r\n\t\tif (obj == null) {\r\n\t\t\treturn 0;\r\n\t\t} else if (typeof obj === \"string\" || typeof obj === \"number\") {\r\n\t\t\treturn MurmurHash.hashCode([obj]);\r\n\t\t} else {\r\n\t\t\treturn ObjectEqualityComparator.INSTANCE.hashCode(obj as Equatable);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation relies on object equality. If both objects are\r\n\t * `undefined` or `null`, this method returns `true`. Otherwise if only\r\n\t * `a` is `undefined` or `null`, this method returns `false`. Otherwise,\r\n\t * this method returns the result of\r\n\t * `a.`{@link Object#equals equals}`(b)`.\r\n\t */\r\n\t@Override\r\n\tpublic equals(a: any, b: any): boolean {\r\n\t\tif (a == null) {\r\n\t\t\treturn b == null;\r\n\t\t} else if (typeof a === \"string\" || typeof a === \"number\") {\r\n\t\t\treturn a === b;\r\n\t\t} else {\r\n\t\t\treturn ObjectEqualityComparator.INSTANCE.equals(a as Equatable, b as Equatable);\r\n\t\t}\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-03T02:09:41.7434086-07:00\r\n\r\nimport * as assert from \"assert\";\r\nimport { DefaultEqualityComparator } from \"./DefaultEqualityComparator\";\r\nimport { EqualityComparator } from \"./EqualityComparator\";\r\nimport { NotNull, Nullable, Override, SuppressWarnings } from \"../Decorators\";\r\nimport { JavaCollection, JavaSet } from \"./Stubs\";\r\nimport { ObjectEqualityComparator } from \"./ObjectEqualityComparator\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\n\r\n/** {@link Set} implementation with closed hashing (open addressing). */\r\n\r\n// NOTE:  JavaScript's Set interface has on significant different diffrence from Java's:\r\n// \t\t  e.g. the return type of add() differs!\r\n//        For this reason I've commented tweaked the implements clause\r\n\r\nconst INITAL_CAPACITY: number = 16; // must be power of 2\r\nconst LOAD_FACTOR: number = 0.75;\r\n\r\nexport class Array2DHashSet<T extends { toString(): string; }> implements JavaSet<T> {\r\n\t@NotNull\r\n\tprotected comparator: EqualityComparator<T>;\r\n\r\n\tprotected buckets: Array<T[] | undefined>;\r\n\r\n\t/** How many elements in set */\r\n\tprotected n: number = 0;\r\n\r\n\tprotected threshold: number = Math.floor(INITAL_CAPACITY * LOAD_FACTOR); // when to expand\r\n\r\n\tconstructor(comparator?: EqualityComparator<T>, initialCapacity?: number);\r\n\tconstructor(set: Array2DHashSet<T>);\r\n\tconstructor(\r\n\t\tcomparatorOrSet?: EqualityComparator<T> | Array2DHashSet<T>,\r\n\t\tinitialCapacity: number = INITAL_CAPACITY) {\r\n\r\n\t\tif (comparatorOrSet instanceof Array2DHashSet) {\r\n\t\t\tthis.comparator = comparatorOrSet.comparator;\r\n\t\t\tthis.buckets = comparatorOrSet.buckets.slice(0);\r\n\t\t\tfor (let i = 0; i < this.buckets.length; i++) {\r\n\t\t\t\tlet bucket = this.buckets[i];\r\n\t\t\t\tif (bucket) {\r\n\t\t\t\t\tthis.buckets[i] = bucket.slice(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.n = comparatorOrSet.n;\r\n\t\t\tthis.threshold = comparatorOrSet.threshold;\r\n\t\t} else {\r\n\t\t\tthis.comparator = comparatorOrSet || DefaultEqualityComparator.INSTANCE;\r\n\t\t\tthis.buckets = this.createBuckets(initialCapacity);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add `o` to set if not there; return existing value if already\r\n\t * there. This method performs the same operation as {@link #add} aside from\r\n\t * the return value.\r\n\t */\r\n\tpublic getOrAdd(o: T): T {\r\n\t\tif (this.n > this.threshold) {\r\n\t\t\tthis.expand();\r\n\t\t}\r\n\t\treturn this.getOrAddImpl(o);\r\n\t}\r\n\r\n\tprotected getOrAddImpl(o: T): T {\r\n\t\tlet b: number = this.getBucket(o);\r\n\t\tlet bucket = this.buckets[b];\r\n\r\n\t\t// NEW BUCKET\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = [o];\r\n\t\t\tthis.buckets[b] = bucket;\r\n\t\t\tthis.n++;\r\n\t\t\treturn o;\r\n\t\t}\r\n\r\n\t\t// LOOK FOR IT IN BUCKET\r\n\t\tfor (let existing of bucket) {\r\n\t\t\tif (this.comparator.equals(existing, o)) {\r\n\t\t\t\treturn existing; // found existing, quit\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// FULL BUCKET, expand and add to end\r\n\t\tbucket.push(o);\r\n\t\tthis.n++;\r\n\t\treturn o;\r\n\t}\r\n\r\n\tpublic get(o: T): T | undefined {\r\n\t\tif (o == null) {\r\n\t\t\treturn o;\r\n\t\t}\r\n\t\tlet b: number = this.getBucket(o);\r\n\t\tlet bucket = this.buckets[b];\r\n\t\tif (!bucket) {\r\n\t\t\t// no bucket\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tfor (let e of bucket) {\r\n\t\t\tif (this.comparator.equals(e, o)) {\r\n\t\t\t\treturn e;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tprotected getBucket(o: T): number {\r\n\t\tlet hash: number = this.comparator.hashCode(o);\r\n\t\tlet b: number = hash & (this.buckets.length - 1); // assumes len is power of 2\r\n\t\treturn b;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic hashCode(): number {\r\n\t\tlet hash: number = MurmurHash.initialize();\r\n\t\tfor (let bucket of this.buckets) {\r\n\t\t\tif (bucket == null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let o of bucket) {\r\n\t\t\t\tif (o == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\thash = MurmurHash.update(hash, this.comparator.hashCode(o));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thash = MurmurHash.finish(hash, this.size);\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic equals(o: any): boolean {\r\n\t\tif (o === this) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (!(o instanceof Array2DHashSet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (o.size !== this.size) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tlet same: boolean = this.containsAll(o);\r\n\t\treturn same;\r\n\t}\r\n\r\n\tprotected expand(): void {\r\n\t\tlet old = this.buckets;\r\n\t\tlet newCapacity: number = this.buckets.length * 2;\r\n\t\tlet newTable: Array<T[] | undefined> = this.createBuckets(newCapacity);\r\n\t\tthis.buckets = newTable;\r\n\t\tthis.threshold = Math.floor(newCapacity * LOAD_FACTOR);\r\n//\t\tSystem.out.println(\"new size=\"+newCapacity+\", thres=\"+threshold);\r\n\t\t// rehash all existing entries\r\n\t\tlet oldSize: number = this.size;\r\n\t\tfor (let bucket of old) {\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let o of bucket) {\r\n\t\t\t\tlet b: number = this.getBucket(o);\r\n\t\t\t\tlet newBucket: T[] | undefined = this.buckets[b];\r\n\t\t\t\tif (!newBucket) {\r\n\t\t\t\t\tnewBucket = [];\r\n\t\t\t\t\tthis.buckets[b] = newBucket;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewBucket.push(o);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tassert(this.n === oldSize);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic add(t: T): boolean {\r\n\t\tlet existing: T = this.getOrAdd(t);\r\n\t\treturn existing === t;\r\n\t}\r\n\r\n\t@Override\r\n\tget size(): number {\r\n\t\treturn this.n;\r\n\t}\r\n\r\n\t@Override\r\n\tget isEmpty(): boolean {\r\n\t\treturn this.n === 0;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic contains(o: any): boolean {\r\n\t\treturn this.containsFast(this.asElementType(o));\r\n\t}\r\n\r\n\tpublic containsFast(@Nullable obj: T): boolean {\r\n\t\tif (obj == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn this.get(obj) != null;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic *[Symbol.iterator](): IterableIterator<T> {\r\n\t\tyield* this.toArray();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toArray(): T[] {\r\n\t\tconst a = new Array<T>(this.size);\r\n\r\n\t\t// Copy elements from the nested arrays into the destination array\r\n\t\tlet i: number = 0; // Position within destination array\r\n\t\tfor (let bucket of this.buckets) {\r\n\t\t\tif (bucket == null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tfor (let o of bucket) {\r\n\t\t\t\tif (o == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\ta[i++] = o;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn a;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic containsAll(collection: JavaCollection<T>): boolean {\r\n\t\tif (collection instanceof Array2DHashSet) {\r\n\t\t\tlet s = collection as any as Array2DHashSet<T>;\r\n\t\t\tfor (let bucket of s.buckets) {\r\n\t\t\t\tif (bucket == null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfor (let o of bucket) {\r\n\t\t\t\t\tif (o == null) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!this.containsFast(this.asElementType(o))) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (let o of collection) {\r\n\t\t\t\tif (!this.containsFast(this.asElementType(o))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic addAll(c: Iterable<T>): boolean {\r\n\t\tlet changed: boolean = false;\r\n\r\n\t\tfor (let o of c) {\r\n\t\t\tlet existing: T = this.getOrAdd(o);\r\n\t\t\tif (existing !== o) {\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic clear(): void {\r\n\t\tthis.buckets = this.createBuckets(INITAL_CAPACITY);\r\n\t\tthis.n = 0;\r\n\t\tthis.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic toString(): string {\r\n\t\tif (this.size === 0) {\r\n\t\t\treturn \"{}\";\r\n\t\t}\r\n\r\n\t\tlet buf = \"{\";\r\n\t\tlet first: boolean = true;\r\n\t\tfor (let bucket of this.buckets) {\r\n\t\t\tif (bucket == null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let o of bucket) {\r\n\t\t\t\tif (o == null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf += \", \";\r\n\t\t\t\t}\r\n\t\t\t\tbuf += o.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\tbuf += \"}\";\r\n\t\treturn buf;\r\n\t}\r\n\r\n\tpublic toTableString(): string {\r\n\t\tlet buf = \"\";\r\n\t\tfor (let bucket of this.buckets) {\r\n\t\t\tif (bucket == null) {\r\n\t\t\t\tbuf += \"null\\n\";\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tbuf += \"[\";\r\n\t\t\tlet first: boolean = true;\r\n\t\t\tfor (let o of bucket) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf += \" \";\r\n\t\t\t\t}\r\n\t\t\t\tif (o == null) {\r\n\t\t\t\t\tbuf += \"_\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbuf += o.toString();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbuf += \"]\\n\";\r\n\t\t}\r\n\t\treturn buf;\r\n\t}\r\n\r\n\t/**\r\n\t * Return `o` as an instance of the element type `T`. If\r\n\t * `o` is non-undefined but known to not be an instance of `T`, this\r\n\t * method returns `undefined`. The base implementation does not perform any\r\n\t * type checks; override this method to provide strong type checks for the\r\n\t * {@link #contains} and {@link #remove} methods to ensure the arguments to\r\n\t * the {@link EqualityComparator} for the set always have the expected\r\n\t * types.\r\n\t *\r\n\t * @param o the object to try and cast to the element type of the set\r\n\t * @returns `o` if it could be an instance of `T`, otherwise\r\n\t * `undefined`.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected asElementType(o: any): T {\r\n\t\treturn o as T;\r\n\t}\r\n\r\n\t/**\r\n\t * Return an array of `T[]` with length `capacity`.\r\n\t *\r\n\t * @param capacity the length of the array to return\r\n\t * @returns the newly constructed array\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprotected createBuckets(capacity: number): Array<T[] | undefined> {\r\n\t\treturn new Array<T[]>(capacity);\r\n\t}\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-03T02:09:42.2127260-07:00\r\nimport { EqualityComparator } from \"./EqualityComparator\";\r\nimport { Override } from \"../Decorators\";\r\nimport { Equatable } from \"./Stubs\";\r\nimport { MurmurHash } from \"./MurmurHash\";\r\nimport { ObjectEqualityComparator } from \"./ObjectEqualityComparator\";\r\n\r\n/**\r\n * This default implementation of {@link EqualityComparator} uses object equality\r\n * for comparisons by calling {@link Object#hashCode} and {@link Object#equals}.\r\n *\r\n * @author Sam Harwell\r\n */\r\nexport class ArrayEqualityComparator implements EqualityComparator<Equatable[]> {\r\n\tpublic static readonly INSTANCE: ArrayEqualityComparator = new ArrayEqualityComparator();\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation returns\r\n\t * `obj.`{@link Object#hashCode hashCode()}.\r\n\t */\r\n\t@Override\r\n\tpublic hashCode(obj: Equatable[]): number {\r\n\t\tif (obj == null) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn MurmurHash.hashCode(obj, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t *\r\n\t * This implementation relies on object equality. If both objects are\r\n\t * `undefined`, this method returns `true`. Otherwise if only\r\n\t * `a` is `undefined`, this method returns `false`. Otherwise,\r\n\t * this method returns the result of\r\n\t * `a.`{@link Object#equals equals}`(b)`.\r\n\t */\r\n\t@Override\r\n\tpublic equals(a: Equatable[], b: Equatable[]): boolean {\r\n\t\tif (a == null) {\r\n\t\t\treturn b == null;\r\n\t\t} else if (b == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (a.length !== b.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < a.length; i++) {\r\n\t\t\tif (!ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n", "/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:36.9521478-07:00\r\n\r\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\r\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\r\nimport { Comparable } from \"../misc/Stubs\";\r\nimport { Equatable } from \"../misc/Stubs\";\r\nimport { MurmurHash } from \"../misc/MurmurHash\";\r\nimport { NotNull, Override } from \"../Decorators\";\r\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\r\nimport { Recognizer } from \"../Recognizer\";\r\nimport { RuleContext } from \"../RuleContext\";\r\nimport * as Utils from \"../misc/Utils\";\r\n\r\nfunction max<T extends Comparable<T>>(items: Iterable<T>): T | undefined {\r\n\tlet result: T | undefined;\r\n\tfor (let current of items) {\r\n\t\tif (result === undefined) {\r\n\t\t\tresult = current;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlet comparison = result.compareTo(current);\r\n\t\tif (comparison < 0) {\r\n\t\t\tresult = current;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction min<T extends Comparable<T>>(items: Iterable<T>): T | undefined {\r\n\tlet result: T | undefined;\r\n\tfor (let current of items) {\r\n\t\tif (result === undefined) {\r\n\t\t\tresult = current;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlet comparison = result.compareTo(current);\r\n\t\tif (comparison > 0) {\r\n\t\t\tresult = current;\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/** A tree structure used to record the semantic context in which\r\n *  an ATN configuration is valid.  It's either a single predicate,\r\n *  a conjunction `p1&&p2`, or a sum of products `p1||p2`.\r\n *\r\n *  I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\r\n *  {@link SemanticContext} within the scope of this outer class.\r\n */\r\nexport abstract class SemanticContext implements Equatable {\r\n\tprivate static _NONE: SemanticContext;\r\n\r\n\t/**\r\n\t * The default {@link SemanticContext}, which is semantically equivalent to\r\n\t * a predicate of the form `{true}?`.\r\n\t */\r\n\tstatic get NONE(): SemanticContext {\r\n\t\tif (SemanticContext._NONE === undefined) {\r\n\t\t\tSemanticContext._NONE = new SemanticContext.Predicate();\r\n\t\t}\r\n\r\n\t\treturn SemanticContext._NONE;\r\n\t}\r\n\r\n\t/**\r\n\t * For context independent predicates, we evaluate them without a local\r\n\t * context (i.e., unedfined context). That way, we can evaluate them without\r\n\t * having to create proper rule-specific context during prediction (as\r\n\t * opposed to the parser, which creates them naturally). In a practical\r\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\r\n\t *\r\n\t * For context dependent predicates, we must pass in a local context so that\r\n\t * references such as $arg evaluate properly as _localctx.arg. We only\r\n\t * capture context dependent predicates in the context in which we begin\r\n\t * prediction, so we passed in the outer context here in case of context\r\n\t * dependent predicate evaluation.\r\n\t */\r\n\tpublic abstract eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean;\r\n\r\n\t/**\r\n\t * Evaluate the precedence predicates for the context and reduce the result.\r\n\t *\r\n\t * @param parser The parser instance.\r\n\t * @param parserCallStack\r\n\t * @returns The simplified semantic context after precedence predicates are\r\n\t * evaluated, which will be one of the following values.\r\n\t *\r\n\t * * {@link #NONE}: if the predicate simplifies to `true` after\r\n\t *   precedence predicates are evaluated.\r\n\t * * `undefined`: if the predicate simplifies to `false` after\r\n\t *   precedence predicates are evaluated.\r\n\t * * `this`: if the semantic context is not changed as a result of\r\n\t *   precedence predicate evaluation.\r\n\t * * A non-`undefined` {@link SemanticContext}: the new simplified\r\n\t *   semantic context after precedence predicates are evaluated.\r\n\t */\r\n\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\r\n\t\treturn this;\r\n\t}\r\n\r\n\tpublic abstract hashCode(): number;\r\n\r\n\tpublic abstract equals(obj: any): boolean;\r\n\r\n\tpublic static and(a: SemanticContext | undefined, b: SemanticContext): SemanticContext {\r\n\t\tif (!a || a === SemanticContext.NONE) {\r\n\t\t\treturn b;\r\n\t\t}\r\n\t\tif (b === SemanticContext.NONE) {\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\tlet result: SemanticContext.AND = new SemanticContext.AND(a, b);\r\n\t\tif (result.opnds.length === 1) {\r\n\t\t\treturn result.opnds[0];\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t *  @see ParserATNSimulator#getPredsForAmbigAlts\r\n\t */\r\n\tpublic static or(a: SemanticContext | undefined, b: SemanticContext): SemanticContext {\r\n\t\tif (!a) {\r\n\t\t\treturn b;\r\n\t\t}\r\n\r\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\r\n\t\t\treturn SemanticContext.NONE;\r\n\t\t}\r\n\t\tlet result: SemanticContext.OR = new SemanticContext.OR(a, b);\r\n\t\tif (result.opnds.length === 1) {\r\n\t\t\treturn result.opnds[0];\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nexport namespace SemanticContext {\r\n\t/**\r\n\t * This random 30-bit prime represents the value of `AND.class.hashCode()`.\r\n\t */\r\n\tconst AND_HASHCODE = 40363613;\r\n\t/**\r\n\t * This random 30-bit prime represents the value of `OR.class.hashCode()`.\r\n\t */\r\n\tconst OR_HASHCODE = 486279973;\r\n\r\n\tfunction filterPrecedencePredicates(collection: SemanticContext[]): SemanticContext.PrecedencePredicate[] {\r\n\t\tlet result: SemanticContext.PrecedencePredicate[] = [];\r\n\t\tfor (let i = 0; i < collection.length; i++) {\r\n\t\t\tlet context: SemanticContext = collection[i];\r\n\t\t\tif (context instanceof SemanticContext.PrecedencePredicate) {\r\n\t\t\t\tresult.push(context);\r\n\r\n\t\t\t\t// Remove the item from 'collection' and move i back so we look at the same index again\r\n\t\t\t\tcollection.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\texport class Predicate extends SemanticContext {\r\n\t\tpublic ruleIndex: number;\r\n\t\tpublic predIndex: number;\r\n\t\tpublic isCtxDependent: boolean;   // e.g., $i ref in pred\r\n\r\n\t\tconstructor();\r\n\t\tconstructor(ruleIndex: number, predIndex: number, isCtxDependent: boolean);\r\n\r\n\t\tconstructor(ruleIndex: number = -1, predIndex: number = -1, isCtxDependent: boolean = false) {\r\n\t\t\tsuper();\r\n\t\t\tthis.ruleIndex = ruleIndex;\r\n\t\t\tthis.predIndex = predIndex;\r\n\t\t\tthis.isCtxDependent = isCtxDependent;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\r\n\t\t\tlet localctx: RuleContext | undefined = this.isCtxDependent ? parserCallStack : undefined;\r\n\t\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\tlet hashCode: number = MurmurHash.initialize();\r\n\t\t\thashCode = MurmurHash.update(hashCode, this.ruleIndex);\r\n\t\t\thashCode = MurmurHash.update(hashCode, this.predIndex);\r\n\t\t\thashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);\r\n\t\t\thashCode = MurmurHash.finish(hashCode, 3);\r\n\t\t\treturn hashCode;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(obj: any): boolean {\r\n\t\t\tif (!(obj instanceof Predicate)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif (this === obj) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn this.ruleIndex === obj.ruleIndex &&\r\n\t\t\t\tthis.predIndex === obj.predIndex &&\r\n\t\t\t\tthis.isCtxDependent === obj.isCtxDependent;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic toString(): string {\r\n\t\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\r\n\t\t}\r\n\t}\r\n\r\n\texport class PrecedencePredicate extends SemanticContext implements Comparable<PrecedencePredicate> {\r\n\t\tpublic precedence: number;\r\n\r\n\t\tconstructor(precedence: number) {\r\n\t\t\tsuper();\r\n\t\t\tthis.precedence = precedence;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\r\n\t\t\treturn parser.precpred(parserCallStack, this.precedence);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\r\n\t\t\tif (parser.precpred(parserCallStack, this.precedence)) {\r\n\t\t\t\treturn SemanticContext.NONE;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic compareTo(o: PrecedencePredicate): number {\r\n\t\t\treturn this.precedence - o.precedence;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\tlet hashCode: number = 1;\r\n\t\t\thashCode = 31 * hashCode + this.precedence;\r\n\t\t\treturn hashCode;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(obj: any): boolean {\r\n\t\t\tif (!(obj instanceof PrecedencePredicate)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif (this === obj) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn this.precedence === obj.precedence;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\t// precedence >= _precedenceStack.peek()\r\n\t\tpublic toString(): string {\r\n\t\t\treturn \"{\" + this.precedence + \">=prec}?\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This is the base class for semantic context \"operators\", which operate on\r\n\t * a collection of semantic context \"operands\".\r\n\t *\r\n\t * @since 4.3\r\n\t */\r\n\texport abstract class Operator extends SemanticContext {\r\n\t\t/**\r\n\t\t * Gets the operands for the semantic context operator.\r\n\t\t *\r\n\t\t * @returns a collection of {@link SemanticContext} operands for the\r\n\t\t * operator.\r\n\t\t *\r\n\t\t * @since 4.3\r\n\t\t */\r\n\t\t// @NotNull\r\n\t\tpublic abstract readonly operands: Iterable<SemanticContext>;\r\n\t}\r\n\r\n\t/**\r\n\t * A semantic context which is true whenever none of the contained contexts\r\n\t * is false.\r\n\t */\r\n\texport class AND extends Operator {\r\n\t\tpublic opnds: SemanticContext[];\r\n\r\n\t\tconstructor(@NotNull a: SemanticContext, @NotNull b: SemanticContext) {\r\n\t\t\tsuper();\r\n\r\n\t\t\tlet operands: Array2DHashSet<SemanticContext> = new Array2DHashSet<SemanticContext>(ObjectEqualityComparator.INSTANCE);\r\n\t\t\tif (a instanceof AND) {\r\n\t\t\t\toperands.addAll(a.opnds);\r\n\t\t\t} else {\r\n\t\t\t\toperands.add(a);\r\n\t\t\t}\r\n\r\n\t\t\tif (b instanceof AND) {\r\n\t\t\t\toperands.addAll(b.opnds);\r\n\t\t\t} else {\r\n\t\t\t\toperands.add(b);\r\n\t\t\t}\r\n\r\n\t\t\tthis.opnds = operands.toArray();\r\n\t\t\tlet precedencePredicates: PrecedencePredicate[] = filterPrecedencePredicates(this.opnds);\r\n\r\n\t\t\t// interested in the transition with the lowest precedence\r\n\t\t\tlet reduced = min(precedencePredicates);\r\n\t\t\tif (reduced) {\r\n\t\t\t\tthis.opnds.push(reduced);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tget operands(): Iterable<SemanticContext> {\r\n\t\t\treturn this.opnds;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(obj: any): boolean {\r\n\t\t\tif (this === obj) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (!(obj instanceof AND)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\treturn MurmurHash.hashCode(this.opnds, AND_HASHCODE);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * {@inheritDoc}\r\n\t\t *\r\n\t\t * The evaluation of predicates by this context is short-circuiting, but\r\n\t\t * unordered.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\r\n\t\t\tfor (let opnd of this.opnds) {\r\n\t\t\t\tif (!opnd.eval(parser, parserCallStack)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\r\n\t\t\tlet differs: boolean = false;\r\n\t\t\tlet operands: SemanticContext[] = [];\r\n\t\t\tfor (let context of this.opnds) {\r\n\t\t\t\tlet evaluated: SemanticContext | undefined = context.evalPrecedence(parser, parserCallStack);\r\n\t\t\t\tdiffers = differs || (evaluated !== context);\r\n\t\t\t\tif (evaluated == null) {\r\n\t\t\t\t\t// The AND context is false if any element is false\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\t\t\t\telse if (evaluated !== SemanticContext.NONE) {\r\n\t\t\t\t\t// Reduce the result by skipping true elements\r\n\t\t\t\t\toperands.push(evaluated);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!differs) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tif (operands.length === 0) {\r\n\t\t\t\t// all elements were true, so the AND context is true\r\n\t\t\t\treturn SemanticContext.NONE;\r\n\t\t\t}\r\n\r\n\t\t\tlet result: SemanticContext = operands[0];\r\n\t\t\tfor (let i = 1; i < operands.length; i++) {\r\n\t\t\t\tresult = SemanticContext.and(result, operands[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic toString(): string {\r\n\t\t\treturn Utils.join(this.opnds, \"&&\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A semantic context which is true whenever at least one of the contained\r\n\t * contexts is true.\r\n\t */\r\n\texport class OR extends Operator {\r\n\t\tpublic opnds: SemanticContext[];\r\n\r\n\t\tconstructor(@NotNull a: SemanticContext, @NotNull b: SemanticContext) {\r\n\t\t\tsuper();\r\n\r\n\t\t\tlet operands: Array2DHashSet<SemanticContext> = new Array2DHashSet<SemanticContext>(ObjectEqualityComparator.INSTANCE);\r\n\t\t\tif (a instanceof OR) {\r\n\t\t\t\toperands.addAll(a.opnds);\r\n\t\t\t} else {\r\n\t\t\t\toperands.add(a);\r\n\t\t\t}\r\n\r\n\t\t\tif (b instanceof OR) {\r\n\t\t\t\toperands.addAll(b.opnds);\r\n\t\t\t} else {\r\n\t\t\t\toperands.add(b);\r\n\t\t\t}\r\n\r\n\t\t\tthis.opnds = operands.toArray();\r\n\t\t\tlet precedencePredicates: PrecedencePredicate[] = filterPrecedencePredicates(this.opnds);\r\n\r\n\t\t\t// interested in the transition with the highest precedence\r\n\t\t\tlet reduced = max(precedencePredicates);\r\n\t\t\tif (reduced) {\r\n\t\t\t\tthis.opnds.push(reduced);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tget operands(): Iterable<SemanticContext> {\r\n\t\t\treturn this.opnds;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic equals(obj: any): boolean {\r\n\t\t\tif (this === obj) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (!(obj instanceof OR)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic hashCode(): number {\r\n\t\t\treturn MurmurHash.hashCode(this.opnds, OR_HASHCODE);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * {@inheritDoc}\r\n\t\t *\r\n\t\t * The evaluation of predicates by this context is short-circuiting, but\r\n\t\t * unordered.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\r\n\t\t\tfor (let opnd of this.opnds) {\r\n\t\t\t\tif (opnd.eval(parser, parserCallStack)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\r\n\t\t\tlet differs: boolean = false;\r\n\t\t\tlet operands: SemanticContext[] = [];\r\n\t\t\tfor (let context of this.opnds) {\r\n\t\t\t\tlet evaluated: SemanticContext | undefined = context.evalPrecedence(parser, parserCallStack);\r\n\t\t\t\tdiffers = differs || (evaluated !== context);\r\n\t\t\t\tif (evaluated === SemanticContext.NONE) {\r\n\t\t\t\t\t// The OR context is true if any element is true\r\n\t\t\t\t\treturn SemanticContext.NONE;\r\n\t\t\t\t} else if (evaluated) {\r\n\t\t\t\t\t// Reduce the result by skipping false elements\r\n\t\t\t\t\toperands.push(evaluated);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!differs) {\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tif (operands.length === 0) {\r\n\t\t\t\t// all elements were false, so the OR context is false\r\n\t\t\t\treturn undefined;\r\n\t\t\t}\r\n\r\n\t\t\tlet result: SemanticContext = operands[0];\r\n\t\t\tfor (let i = 1; i < operands.length; i++) {\r\n\t\t\t\tresult = SemanticContext.or(result, operands[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic toString(): string {\r\n\t\t\treturn Utils.join(this.opnds, \"||\");\r\n\t\t}\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["MurmurHash", "SemanticContext", "AND", "OR"]
}
